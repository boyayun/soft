###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        30/Jan/2016  15:22:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_protocol.c
#    Command line =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_protocol.c
#        -D NDEBUG -lCN
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\
#        -o
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\
#        --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\common\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\drivers\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\freemaster\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\projects\_twr_emeter_demo\
#        -Oh --require_prototypes
#    List file    =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\freemaster_protocol.lst
#    Object file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\freemaster_protocol.o
#
###############################################################################

E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_protocol.c
      1          /******************************************************************************
      2          *
      3          * Freescale Semiconductor Inc.
      4          * (c) Copyright 2004-2010 Freescale Semiconductor
      5          * ALL RIGHTS RESERVED.
      6          *
      7          ****************************************************************************//*!
      8          *
      9          * @file   freemaster_protocol.c
     10          *
     11          * @brief  FreeMASTER protocol handler
     12          *
     13          * @version 1.0.1.0
     14          * 
     15          * @date May-4-2012
     16          * 
     17          *******************************************************************************
     18          *
     19          * This file contains the FreeMASTER protocol decoder and also the handlers 
     20          * of basic protocol commands (read/write memory etc).
     21          * 
     22          *******************************************************************************/
     23          
     24          #include "freemaster.h"
     25          #include "freemaster_private.h"
     26          #include "freemaster_protocol.h"
     27          
     28          /**************************************************************************//*!
     29          *
     30          * @brief    FreeMASTER driver initialization
     31          *
     32          ******************************************************************************/
     33          

   \                                 In section .text, align 2, keep-with-next
     34          FMSTR_BOOL FMSTR_Init(void)
     35          {   
   \                     FMSTR_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     36          #if FMSTR_USE_TSA
     37              /* initialize TSA */
     38              FMSTR_InitTsa();
   \   00000002   0x.... 0x....      BL       FMSTR_InitTsa
     39          #endif
     40          
     41          #if FMSTR_USE_SCOPE
     42              /* initialize Scope */
     43              FMSTR_InitScope();
   \   00000006   0x.... 0x....      BL       FMSTR_InitScope
     44          #endif
     45          
     46          #if FMSTR_USE_RECORDER
     47              /* initialize Recorder */
     48              FMSTR_InitRec();
   \   0000000A   0x.... 0x....      BL       FMSTR_InitRec
     49          #endif
     50          
     51          #if FMSTR_USE_APPCMD
     52              /* initialize application commands */
     53              FMSTR_InitAppCmds();
     54          #endif
     55          
     56          #if FMSTR_USE_SFIO
     57              /* initiazlize SFIO encapsulation layer */
     58              FMSTR_InitSfio();
     59          #endif
     60          
     61          #if FMSTR_USE_PIPES
     62              /* initialize PIPES interface */
     63              FMSTR_InitPipes();
     64          #endif
     65          
     66          #if FMSTR_USE_SCI || FMSTR_USE_JTAG
     67              /* initialize communication and start listening for commands */
     68              FMSTR_InitSerial();
   \   0000000E   0x.... 0x....      BL       FMSTR_InitSerial
     69          #endif  
     70          
     71          #if FMSTR_USE_CAN
     72              /* initialize CAN communication */
     73              FMSTR_InitCan();
     74          #endif  
     75          
     76          #if FMSTR_USE_MQX_IO
     77          	if (!FMSTR_InitMQX())
     78          		return FMSTR_FALSE;
     79          #endif
     80          
     81          return FMSTR_TRUE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
     82          }
     83          
     84          /**************************************************************************//*!
     85          *
     86          * @brief    Decodes the FreeMASTER protocol and calls appropriate handlers 
     87          *
     88          * @param    pMessageIO - message in/out buffer
     89          *
     90          * @return   TRUE if frame was valid and any output was generated to IO buffer
     91          *
     92          * This Function decodes given message and invokes proper command handler
     93          * which fills in the response. The response transmission is initiated
     94          * in this call as well.
     95          *
     96          ******************************************************************************/
     97          

   \                                 In section .text, align 2, keep-with-next
     98          FMSTR_BOOL FMSTR_ProtocolDecoder(FMSTR_BPTR pMessageIO)
     99          {
   \                     FMSTR_ProtocolDecoder: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    100              FMSTR_BPTR pResponseEnd;
    101              FMSTR_U8 nCmd;
    102              
    103              /* no EX access by default */
    104              FMSTR_SetExAddr(FMSTR_FALSE);
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       FMSTR_SetExAddr
    105              
    106              /* command code comes first in the message */
    107              /*lint -e{534} return value is not used */
    108              FMSTR_ValueFromBuffer8(&nCmd, pMessageIO);
    109          
    110              /* process command   */
    111              switch (nCmd)
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD018             BEQ      ??FMSTR_ProtocolDecoder_0
   \   00000010   0x2805             CMP      R0,#+5
   \   00000012   0xD042             BEQ      ??FMSTR_ProtocolDecoder_1
   \   00000014   0x2806             CMP      R0,#+6
   \   00000016   0xD047             BEQ      ??FMSTR_ProtocolDecoder_2
   \   00000018   0x280A             CMP      R0,#+10
   \   0000001A   0xD019             BEQ      ??FMSTR_ProtocolDecoder_3
   \   0000001C   0x280B             CMP      R0,#+11
   \   0000001E   0xD02E             BEQ      ??FMSTR_ProtocolDecoder_4
   \   00000020   0x2812             CMP      R0,#+18
   \   00000022   0xD048             BEQ      ??FMSTR_ProtocolDecoder_5
   \   00000024   0x28C0             CMP      R0,#+192
   \   00000026   0xD054             BEQ      ??FMSTR_ProtocolDecoder_6
   \   00000028   0x28C1             CMP      R0,#+193
   \   0000002A   0xD020             BEQ      ??FMSTR_ProtocolDecoder_7
   \   0000002C   0x28C2             CMP      R0,#+194
   \   0000002E   0xD022             BEQ      ??FMSTR_ProtocolDecoder_8
   \   00000030   0x28C3             CMP      R0,#+195
   \   00000032   0xD018             BEQ      ??FMSTR_ProtocolDecoder_9
   \   00000034   0x28C5             CMP      R0,#+197
   \   00000036   0xD012             BEQ      ??FMSTR_ProtocolDecoder_10
   \   00000038   0x28C9             CMP      R0,#+201
   \   0000003A   0xD027             BEQ      ??FMSTR_ProtocolDecoder_11
   \   0000003C   0x28E6             CMP      R0,#+230
   \   0000003E   0xD041             BEQ      ??FMSTR_ProtocolDecoder_12
   \   00000040   0xE04B             B        ??FMSTR_ProtocolDecoder_13
    112              {
    113              
    114          #if FMSTR_USE_READVAR
    115          
    116                  /* read byte */
    117          #if FMSTR_USE_EX_CMDS       
    118                  case FMSTR_CMD_READVAR8_EX:
    119                      FMSTR_SetExAddr(FMSTR_TRUE);
    120          #endif
    121          #if FMSTR_USE_NOEX_CMDS
    122                  /*lint -fallthrough */
    123                  case FMSTR_CMD_READVAR8:
    124          #endif          
    125                      pResponseEnd = FMSTR_ReadVar(pMessageIO, 1U);
    126                      break;
    127                      
    128                  /* read word */
    129          #if FMSTR_USE_EX_CMDS       
    130                  case FMSTR_CMD_READVAR16_EX:
    131                      FMSTR_SetExAddr(FMSTR_TRUE);
    132          #endif
    133          #if FMSTR_USE_NOEX_CMDS
    134                  /*lint -fallthrough */
    135                  case FMSTR_CMD_READVAR16:
    136          #endif
    137                      pResponseEnd = FMSTR_ReadVar(pMessageIO, 2U);
    138                      break;
    139                      
    140                  /* read dword */
    141          #if FMSTR_USE_EX_CMDS       
    142                  case FMSTR_CMD_READVAR32_EX:
    143                      FMSTR_SetExAddr(FMSTR_TRUE);
    144          #endif
    145          #if FMSTR_USE_NOEX_CMDS
    146                  /*lint -fallthrough */
    147                  case FMSTR_CMD_READVAR32:
    148          #endif
    149                      pResponseEnd = FMSTR_ReadVar(pMessageIO, 4U);
    150                      break;
    151          #endif /* FMSTR_USE_READVAR */
    152          
    153          #if FMSTR_USE_READMEM
    154          
    155                  /* read a block of memory */
    156          #if FMSTR_USE_EX_CMDS       
    157                  case FMSTR_CMD_READMEM_EX:
    158                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_0: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       FMSTR_SetExAddr
    159          #endif
    160          #if FMSTR_USE_NOEX_CMDS
    161                  /*lint -fallthrough */
    162                  case FMSTR_CMD_READMEM:
    163          #endif
    164                      pResponseEnd = FMSTR_ReadMem(pMessageIO);
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       FMSTR_ReadMem
    165                      break;
   \   0000004E   0xE047             B        ??FMSTR_ProtocolDecoder_14
    166                      
    167          #endif /* FMSTR_USE_READMEM */
    168          
    169          #if FMSTR_USE_SCOPE
    170          
    171                  /* prepare scope variables */
    172          #if FMSTR_USE_EX_CMDS       
    173                  case FMSTR_CMD_SETUPSCOPE_EX:
    174                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_3: (+1)
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      BL       FMSTR_SetExAddr
    175          #endif
    176          #if FMSTR_USE_NOEX_CMDS
    177                  /*lint -fallthrough */
    178                  case FMSTR_CMD_SETUPSCOPE:
    179          #endif
    180                      pResponseEnd = FMSTR_SetUpScope(pMessageIO);
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       FMSTR_SetUpScope
    181                      break;  
   \   0000005C   0xE040             B        ??FMSTR_ProtocolDecoder_14
    182                      
    183                  case FMSTR_CMD_READSCOPE:
    184                      pResponseEnd = FMSTR_ReadScope(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_10: (+1)
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       FMSTR_ReadScope
    185                      break;
   \   00000064   0xE03C             B        ??FMSTR_ProtocolDecoder_14
    186          #endif /* FMSTR_USE_SCOPE */
    187          
    188          #if FMSTR_USE_RECORDER
    189          
    190                  /* get recorder status */
    191                  case FMSTR_CMD_GETRECSTS:
    192                      pResponseEnd = FMSTR_GetRecStatus(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_9: (+1)
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       FMSTR_GetRecStatus
    193                      break;
   \   0000006C   0xE038             B        ??FMSTR_ProtocolDecoder_14
    194          
    195                  /* start recorder */
    196                  case FMSTR_CMD_STARTREC:
    197                      pResponseEnd = FMSTR_StartRec(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_7: (+1)
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       FMSTR_StartRec
    198                      break;
   \   00000074   0xE034             B        ??FMSTR_ProtocolDecoder_14
    199          
    200                  /* stop recorder */
    201                  case FMSTR_CMD_STOPREC:
    202                      pResponseEnd = FMSTR_StopRec(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_8: (+1)
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       FMSTR_StopRec
    203                      break;
   \   0000007C   0xE030             B        ??FMSTR_ProtocolDecoder_14
    204          
    205                  /* setup recorder */
    206          #if FMSTR_USE_EX_CMDS       
    207                  case FMSTR_CMD_SETUPREC_EX:                 
    208                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_4: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x.... 0x....      BL       FMSTR_SetExAddr
    209          #endif
    210          #if FMSTR_USE_NOEX_CMDS
    211                  /*lint -fallthrough */
    212                  case FMSTR_CMD_SETUPREC:                    
    213          #endif
    214                      pResponseEnd = FMSTR_SetUpRec(pMessageIO);
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       FMSTR_SetUpRec
    215                      break;
   \   0000008A   0xE029             B        ??FMSTR_ProtocolDecoder_14
    216                      
    217                  /* get recorder buffer information (force EX instead of non-EX) */
    218          #if FMSTR_USE_EX_CMDS       
    219                  case FMSTR_CMD_GETRECBUFF_EX:
    220                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_11: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x.... 0x....      BL       FMSTR_SetExAddr
    221          #elif FMSTR_USE_NOEX_CMDS
    222                  /*lint -fallthrough */
    223                  case FMSTR_CMD_GETRECBUFF:                  
    224          #endif
    225                      pResponseEnd = FMSTR_GetRecBuff(pMessageIO);
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       FMSTR_GetRecBuff
    226                      break; 
   \   00000098   0xE022             B        ??FMSTR_ProtocolDecoder_14
    227          #endif /* FMSTR_USE_RECORDER */
    228           
    229          #if FMSTR_USE_APPCMD
    230          
    231                  /* accept the application command */
    232                  case FMSTR_CMD_SENDAPPCMD:
    233                      pResponseEnd = FMSTR_StoreAppCmd(pMessageIO);
    234                      break;
    235          
    236                  /* get the application command status */
    237                  case FMSTR_CMD_GETAPPCMDSTS:
    238                      pResponseEnd = FMSTR_GetAppCmdStatus(pMessageIO);
    239                      break;
    240          
    241                  /* get the application command data */
    242                  case FMSTR_CMD_GETAPPCMDDATA:
    243                      pResponseEnd = FMSTR_GetAppCmdRespData(pMessageIO);
    244                      break;
    245          #endif /* FMSTR_USE_APPCMD */
    246          
    247          #if FMSTR_USE_WRITEMEM
    248          
    249                  /* write a block of memory */
    250          #if FMSTR_USE_EX_CMDS       
    251                  case FMSTR_CMD_WRITEMEM_EX:
    252                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_1: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x.... 0x....      BL       FMSTR_SetExAddr
    253          #endif          
    254          #if FMSTR_USE_NOEX_CMDS
    255                  /*lint -fallthrough */
    256                  case FMSTR_CMD_WRITEMEM:
    257          #endif
    258                      pResponseEnd = FMSTR_WriteMem(pMessageIO);
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       FMSTR_WriteMem
    259                      break;
   \   000000A6   0xE01B             B        ??FMSTR_ProtocolDecoder_14
    260          #endif /* FMSTR_USE_WRITEMEM */
    261          
    262          #if FMSTR_USE_WRITEMEMMASK
    263          
    264                  /* write block of memory with a bit mask */
    265          #if FMSTR_USE_EX_CMDS       
    266                  case FMSTR_CMD_WRITEMEMMASK_EX:
    267                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_2: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x.... 0x....      BL       FMSTR_SetExAddr
    268          #endif
    269          #if FMSTR_USE_NOEX_CMDS
    270                  /*lint -fallthrough */
    271                  case FMSTR_CMD_WRITEMEMMASK:
    272          #endif
    273                      pResponseEnd = FMSTR_WriteMemMask(pMessageIO);
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       FMSTR_WriteMemMask
    274                      break;
   \   000000B4   0xE014             B        ??FMSTR_ProtocolDecoder_14
    275          #endif /* FMSTR_USE_WRITEMEMMASK */
    276                      
    277          #if FMSTR_USE_WRITEVAR && FMSTR_USE_NOEX_CMDS
    278          
    279                  /* write byte */
    280                  case FMSTR_CMD_WRITEVAR8:
    281                      pResponseEnd = FMSTR_WriteVar(pMessageIO, 1U);
    282                      break;
    283          
    284                  /* write word */
    285                  case FMSTR_CMD_WRITEVAR16:
    286                      pResponseEnd = FMSTR_WriteVar(pMessageIO, 2U);
    287                      break;
    288          
    289                  /* write dword */
    290                  case FMSTR_CMD_WRITEVAR32:
    291                      pResponseEnd = FMSTR_WriteVar(pMessageIO, 4U);
    292                      break;
    293          #endif /* FMSTR_USE_WRITEVAR && FMSTR_USE_NOEX_CMDS */
    294          
    295          #if FMSTR_USE_WRITEVARMASK && FMSTR_USE_NOEX_CMDS
    296          
    297                  /* write byte with mask */
    298                  case FMSTR_CMD_WRITEVAR8MASK:
    299                      pResponseEnd = FMSTR_WriteVarMask(pMessageIO, 1U);
    300                      break;
    301          
    302                  /* write word with mask */
    303                  case FMSTR_CMD_WRITEVAR16MASK:
    304                      pResponseEnd = FMSTR_WriteVarMask(pMessageIO, 2U);
    305                      break;
    306          
    307          #endif /* FMSTR_USE_WRITEVARMASK && FMSTR_USE_NOEX_CMDS */
    308          
    309          #if FMSTR_USE_TSA
    310          
    311                  /* get TSA table (force EX instead of non-EX) */
    312          #if FMSTR_USE_EX_CMDS       
    313                  case FMSTR_CMD_GETTSAINFO_EX:
    314                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_5: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x.... 0x....      BL       FMSTR_SetExAddr
    315          #elif FMSTR_USE_NOEX_CMDS
    316                  /*lint -fallthrough */
    317                  case FMSTR_CMD_GETTSAINFO:
    318          #endif
    319                      pResponseEnd = FMSTR_GetTsaInfo(pMessageIO);
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       FMSTR_GetTsaInfo
    320                      break;
   \   000000C2   0xE00D             B        ??FMSTR_ProtocolDecoder_14
    321                      
    322          #if FMSTR_USE_EX_CMDS
    323                  case FMSTR_CMD_GETSTRLEN_EX:
    324                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_12: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x.... 0x....      BL       FMSTR_SetExAddr
    325          #endif
    326          #if FMSTR_USE_NOEX_CMDS
    327                  /*lint -fallthrough */
    328                  case FMSTR_CMD_GETSTRLEN:
    329          #endif
    330                      pResponseEnd = FMSTR_GetStringLen(pMessageIO);
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       FMSTR_GetStringLen
    331                      break;
   \   000000D0   0xE006             B        ??FMSTR_ProtocolDecoder_14
    332          
    333          #endif /* FMSTR_USE_TSA */
    334          
    335          #if FMSTR_USE_BRIEFINFO
    336                  /* retrieve a subset of board information structure */
    337                  case FMSTR_CMD_GETINFOBRIEF:
    338          #else   
    339                  /* retrieve board information structure */
    340                  case FMSTR_CMD_GETINFO: 
    341          #endif
    342                      pResponseEnd = FMSTR_GetBoardInfo(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_6: (+1)
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       FMSTR_GetBoardInfo
    343                      break;
   \   000000D8   0xE002             B        ??FMSTR_ProtocolDecoder_14
    344          
    345          #if FMSTR_USE_SFIO
    346                  case FMSTR_CMD_SFIOFRAME_0:
    347                  case FMSTR_CMD_SFIOFRAME_1:
    348                      pResponseEnd = FMSTR_SfioFrame(pMessageIO);
    349                      break;
    350                  case FMSTR_CMD_SFIOGETRESP_0:
    351                  case FMSTR_CMD_SFIOGETRESP_1:
    352                      pResponseEnd = FMSTR_SfioGetResp(pMessageIO);
    353                      break;
    354          #endif /* FMSTR_USE_SFIO */
    355          
    356          #if FMSTR_USE_PIPES
    357                  case FMSTR_CMD_PIPE:
    358                      pResponseEnd = FMSTR_PipeFrame(pMessageIO);
    359                      break;
    360          #endif /* FMSTR_USE_PIPES */
    361          
    362                  /* unknown command */
    363                  default:
    364                      pResponseEnd = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_INVCMD);
   \                     ??FMSTR_ProtocolDecoder_13: (+1)
   \   000000DA   0x2081             MOVS     R0,#+129
   \   000000DC   0x7020             STRB     R0,[R4, #+0]
   \   000000DE   0x1C60             ADDS     R0,R4,#+1
    365                      break;          
    366              }
    367              
    368              /* anything to send back? */
    369              if(pResponseEnd != pMessageIO)
   \                     ??FMSTR_ProtocolDecoder_14: (+1)
   \   000000E0   0x42A0             CMP      R0,R4
   \   000000E2   0xD006             BEQ      ??FMSTR_ProtocolDecoder_15
    370              {
    371                  /*lint -e{946,960} subtracting pointers is appropriate here */
    372                  FMSTR_SIZE8 nSize = (FMSTR_SIZE8)(pResponseEnd - pMessageIO);
    373                  FMSTR_SendResponse(pMessageIO, nSize);
   \   000000E4   0x1B01             SUBS     R1,R0,R4
   \   000000E6   0xB2C9             UXTB     R1,R1
   \   000000E8   0x0020             MOVS     R0,R4
   \   000000EA   0x.... 0x....      BL       FMSTR_SendResponse
    374                  return FMSTR_TRUE;
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0xBD10             POP      {R4,PC}
    375              }
    376              else
    377              {
    378                  /* nothing sent out */
    379                  return FMSTR_FALSE;
   \                     ??FMSTR_ProtocolDecoder_15: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xBD10             POP      {R4,PC}          ;; return
    380              }
    381          }
    382          
    383          /**************************************************************************//*!
    384          *
    385          * @brief    Handling GETINFO or GETINFO_BRIEF
    386          *
    387          * @param    pMessageIO - original command (in) and response buffer (out) 
    388          *
    389          * @return   As all command handlers, the return value should be the buffer 
    390          *           pointer where the response output finished (except checksum)
    391          *
    392          ******************************************************************************/
    393          

   \                                 In section .text, align 4, keep-with-next
    394          FMSTR_BPTR FMSTR_GetBoardInfo(FMSTR_BPTR pMessageIO)
    395          {
   \                     FMSTR_GetBoardInfo: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    396              FMSTR_BPTR pResponse = pMessageIO;
    397              FMSTR_U16 wTmp;
    398              FMSTR_U8 *pStr;
    399          
    400              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);              
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    401              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_PROT_VER));            /* protVer */
   \   00000006   0x2203             MOVS     R2,#+3
   \   00000008   0x7042             STRB     R2,[R0, #+1]
    402              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_CFG_FLAGS));           /* cfgFlags */
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    403              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_CFG_BUS_WIDTH));       /* dataBusWdt */
   \   0000000C   0x2401             MOVS     R4,#+1
   \   0000000E   0x70C4             STRB     R4,[R0, #+3]
    404              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_GLOB_VERSION_MAJOR));  /* globVerMajor */
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x7102             STRB     R2,[R0, #+4]
    405              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_GLOB_VERSION_MINOR));  /* globVerMinor */
   \   00000014   0x7141             STRB     R1,[R0, #+5]
    406              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_COMM_BUFFER_SIZE));    /* cmdBuffSize  */
   \   00000016   0x213A             MOVS     R1,#+58
   \   00000018   0x7181             STRB     R1,[R0, #+6]
   \   0000001A   0x1DC5             ADDS     R5,R0,#+7
    407          
    408              /* that is all for brief info */
    409          #if FMSTR_USE_BRIEFINFO
    410              FMSTR_UNUSED(pStr);
    411              FMSTR_UNUSED(wTmp);
    412              
    413          #else /* FMSTR_USE_BRIEFINFO */
    414          
    415          #if FMSTR_USE_RECORDER
    416          
    417              /* recorder buffer size is always mesured in bytes */
    418              wTmp = FMSTR_GetRecBuffSize();
   \   0000001C   0x.... 0x....      BL       FMSTR_GetRecBuffSize
    419              wTmp *= FMSTR_CFG_BUS_WIDTH;
    420          
    421              /* send size and timebase    */
    422              pResponse = FMSTR_ValueToBuffer16(pResponse, wTmp);
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       FMSTR_ValueToBuffer16
    423              pResponse = FMSTR_ConstToBuffer16(pResponse, (FMSTR_U16) FMSTR_REC_TIMEBASE);
   \   00000028   0x....             LDR      R1,??DataTable1  ;; 0x8341
   \   0000002A   0x.... 0x....      BL       FMSTR_ValueToBuffer16
    424          #else /* FMSTR_USE_RECORDER */
    425          
    426              FMSTR_UNUSED(wTmp);
    427          
    428              /* recorder info zeroed */
    429              pResponse = FMSTR_ConstToBuffer16(pResponse, 0);
    430              pResponse = FMSTR_ConstToBuffer16(pResponse, 0);
    431          #endif /* FMSTR_USE_RECORDER */
    432          
    433          #if FMSTR_LIGHT_VERSION
    434          FMSTR_UNUSED(pStr);
    435              pResponse = FMSTR_SkipInBuffer(pResponse, (FMSTR_U8)FMSTR_DESCR_SIZE);
    436          #else
    437              /* description string */
    438              pStr = (FMSTR_U8*)  FMSTR_IDT_STRING;
   \   0000002E   0xBF00             Nop      
   \   00000030   0x....             ADR.N    R2,`?<Constant "Kxx FreeMASTER">`
    439              for(wTmp = 0U; wTmp < (FMSTR_U8)(FMSTR_DESCR_SIZE); wTmp++)
    440              {
    441                  pResponse = FMSTR_ValueToBuffer8(pResponse, *pStr);
   \   00000032   0x234B             MOVS     R3,#+75
   \   00000034   0x7003             STRB     R3,[R0, #+0]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
    442          
    443                  /* terminating zero used to clear the remainder of the buffer */        
    444                  if(*pStr)
    445                  {
    446                      pStr ++;
   \   00000038   0x1C52             ADDS     R2,R2,#+1
   \                     ??FMSTR_GetBoardInfo_0: (+1)
   \   0000003A   0x7811             LDRB     R1,[R2, #+0]
   \   0000003C   0x7001             STRB     R1,[R0, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x7811             LDRB     R1,[R2, #+0]
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD000             BEQ      ??FMSTR_GetBoardInfo_1
   \   00000046   0x1C52             ADDS     R2,R2,#+1
   \                     ??FMSTR_GetBoardInfo_1: (+1)
   \   00000048   0x1C64             ADDS     R4,R4,#+1
   \   0000004A   0x7811             LDRB     R1,[R2, #+0]
   \   0000004C   0x7001             STRB     R1,[R0, #+0]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x7811             LDRB     R1,[R2, #+0]
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD000             BEQ      ??FMSTR_GetBoardInfo_2
   \   00000056   0x1C52             ADDS     R2,R2,#+1
   \                     ??FMSTR_GetBoardInfo_2: (+1)
   \   00000058   0x1C64             ADDS     R4,R4,#+1
   \   0000005A   0x7811             LDRB     R1,[R2, #+0]
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x7811             LDRB     R1,[R2, #+0]
   \   00000062   0x2900             CMP      R1,#+0
   \   00000064   0xD000             BEQ      ??FMSTR_GetBoardInfo_3
   \   00000066   0x1C52             ADDS     R2,R2,#+1
    447                  }
    448              }
   \                     ??FMSTR_GetBoardInfo_3: (+1)
   \   00000068   0x1C64             ADDS     R4,R4,#+1
   \   0000006A   0xB2A4             UXTH     R4,R4
   \   0000006C   0x2C19             CMP      R4,#+25
   \   0000006E   0xDBE4             BLT      ??FMSTR_GetBoardInfo_0
    449          #endif /* SEND_IDT_STRING */
    450              
    451          #endif /* FMSTR_USE_BRIEFINFO */
    452          
    453              return pResponse;   
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    454          }
    455          
    456          /**************************************************************************//*!
    457          *
    458          * @brief    Handling READMEM and READMEM_EX commands
    459          *
    460          * @param    pMessageIO - original command (in) and response buffer (out) 
    461          *
    462          * @return   As all command handlers, the return value should be the buffer 
    463          *           pointer where the response output finished (except checksum)
    464          *
    465          ******************************************************************************/
    466          

   \                                 In section .text, align 2, keep-with-next
    467          FMSTR_BPTR FMSTR_ReadMem(FMSTR_BPTR pMessageIO)
    468          {
   \                     FMSTR_ReadMem: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    469              FMSTR_BPTR pResponse = pMessageIO;
   \   00000002   0x0004             MOVS     R4,R0
    470              FMSTR_ADDR nAddr;
    471              FMSTR_U8 nSize;
    472          
    473              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    474              pMessageIO = FMSTR_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000004   0x7885             LDRB     R5,[R0, #+2]
   \   00000006   0x1CC1             ADDS     R1,R0,#+3
    475              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    476          
    477          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    478              if(!FMSTR_CheckTsaSpace(nAddr, (FMSTR_SIZE8) nSize, FMSTR_FALSE))
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE      ??FMSTR_ReadMem_0
    479              {
    480                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_EACCESS);
   \   0000001C   0x2089             MOVS     R0,#+137
   \   0000001E   0xE002             B.N      ??FMSTR_ReadMem_1
    481              }
    482          #endif
    483          
    484              /* check the response will safely fit into comm buffer */
    485              if(nSize > (FMSTR_U8)FMSTR_COMM_BUFFER_SIZE)
   \                     ??FMSTR_ReadMem_0: (+1)
   \   00000020   0x2D3B             CMP      R5,#+59
   \   00000022   0xDB03             BLT      ??FMSTR_ReadMem_2
    486              {
    487                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_RSPBUFFOVF);
   \   00000024   0x2084             MOVS     R0,#+132
   \                     ??FMSTR_ReadMem_1: (+1)
   \   00000026   0x7020             STRB     R0,[R4, #+0]
   \   00000028   0x1C60             ADDS     R0,R4,#+1
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
    488              }
    489              
    490              /* success  */
    491              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \                     ??FMSTR_ReadMem_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7020             STRB     R0,[R4, #+0]
   \   00000030   0x1C60             ADDS     R0,R4,#+1
    492              
    493              return FMSTR_CopyToBuffer(pResponse, nAddr, (FMSTR_SIZE8) nSize);
   \   00000032   0x002A             MOVS     R2,R5
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0x.... 0x....      BL       FMSTR_CopyToBuffer
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    494          }   
    495          
    496          /**************************************************************************//*!
    497          *
    498          * @brief    Handling READVAR and READVAR_EX commands (for all sizes 1,2,4)
    499          *
    500          * @param    pMessageIO - original command (in) and response buffer (out) 
    501          *
    502          * @return   As all command handlers, the return value should be the buffer 
    503          *           pointer where the response output finished (except checksum)
    504          *
    505          ******************************************************************************/
    506          

   \                                 In section .text, align 2, keep-with-next
    507          FMSTR_BPTR FMSTR_ReadVar(FMSTR_BPTR pMessageIO, FMSTR_SIZE8 nSize)
    508          {
   \                     FMSTR_ReadVar: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    509              FMSTR_BPTR pResponse = pMessageIO;
    510              FMSTR_ADDR nAddr;
    511          
    512              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 1U);
    513              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000006   0x1C61             ADDS     R1,R4,#+1
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    514          
    515          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    516              if(!FMSTR_CheckTsaSpace(nAddr, nSize, FMSTR_FALSE))
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD103             BNE      ??FMSTR_ReadVar_0
    517              {
    518                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_EACCESS);
   \   0000001C   0x2089             MOVS     R0,#+137
   \   0000001E   0x7020             STRB     R0,[R4, #+0]
   \   00000020   0x1C60             ADDS     R0,R4,#+1
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
    519              }
    520          #endif
    521          
    522              /* success  */
    523              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \                     ??FMSTR_ReadVar_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7020             STRB     R0,[R4, #+0]
    524              
    525              return FMSTR_CopyToBuffer(pResponse, nAddr, nSize);
   \   00000028   0x002A             MOVS     R2,R5
   \   0000002A   0x9900             LDR      R1,[SP, #+0]
   \   0000002C   0x1C60             ADDS     R0,R4,#+1
   \   0000002E   0x.... 0x....      BL       FMSTR_CopyToBuffer
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    526          }   
    527          
    528          /**************************************************************************//*!
    529          *
    530          * @brief    Handling WRITEMEM and WRITEMEM_EX commands
    531          *
    532          * @param    pMessageIO - original command (in) and response buffer (out) 
    533          *
    534          * @return   As all command handlers, the return value should be the buffer 
    535          *           pointer where the response output finished (except checksum)
    536          *
    537          ******************************************************************************/
    538          

   \                                 In section .text, align 2, keep-with-next
    539          FMSTR_BPTR FMSTR_WriteMem(FMSTR_BPTR pMessageIO)
    540          {
   \                     FMSTR_WriteMem: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    541              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x0006             MOVS     R6,R0
    542              FMSTR_ADDR nAddr;
    543              FMSTR_U8 nSize,nResponseCode;
    544          
    545              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    546              pMessageIO = FMSTR_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x7884             LDRB     R4,[R0, #+2]
   \   00000008   0x1CC1             ADDS     R1,R0,#+3
    547              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   0000000A   0x....             B.N      ?Subroutine0
    548          
    549          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    550              if(!FMSTR_CheckTsaSpace(nAddr, (FMSTR_SIZE8) nSize, FMSTR_TRUE))
    551              {
    552                  nResponseCode = FMSTR_STC_EACCESS;
    553                  goto FMSTR_WriteMem_exit;
    554              }
    555          #endif
    556          
    557              /*lint -e{534} ignoring function return value */
    558              FMSTR_CopyFromBuffer(nAddr, pMessageIO, (FMSTR_SIZE8) nSize);
    559              nResponseCode = FMSTR_STS_OK;
    560          
    561          FMSTR_WriteMem_exit:
    562              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
    563          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4668             MOV      R0,SP
   \   00000002   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x0021             MOVS     R1,R4
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE      ??Subroutine0_1
   \   00000016   0x2089             MOVS     R0,#+137
   \   00000018   0xE005             B        ??Subroutine0_0
   \                     ??Subroutine0_1: (+1)
   \   0000001A   0x0022             MOVS     R2,R4
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x.... 0x....      BL       FMSTR_CopyFromBuffer
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??Subroutine0_0: (+1)
   \   00000026   0x7030             STRB     R0,[R6, #+0]
   \   00000028   0x1C70             ADDS     R0,R6,#+1
   \   0000002A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    564          
    565          /**************************************************************************//*!
    566          *
    567          * @brief    Handling WRITEVAR command
    568          *
    569          * @param    pMessageIO - original command (in) and response buffer (out) 
    570          * @param    nSize - variable size
    571          *
    572          * @return   As all command handlers, the return value should be the buffer 
    573          *           pointer where the response output finished (except checksum)
    574          *
    575          ******************************************************************************/
    576          

   \                                 In section .text, align 2, keep-with-next
    577          FMSTR_BPTR FMSTR_WriteVar(FMSTR_BPTR pMessageIO, FMSTR_SIZE8 nSize)
    578          {
   \                     FMSTR_WriteVar: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    579              FMSTR_BPTR pResponse = pMessageIO;
   \   00000006   0x0006             MOVS     R6,R0
    580              FMSTR_ADDR nAddr;
    581              FMSTR_U8 nResponseCode;
    582          
    583              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 1U);
    584              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1C41             ADDS     R1,R0,#+1
   \   0000000A                      REQUIRE ?Subroutine0
   \   0000000A                      ;; // Fall through to label ?Subroutine0
    585          
    586          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    587              if(!FMSTR_CheckTsaSpace(nAddr, nSize, FMSTR_TRUE))
    588              {
    589                  nResponseCode = FMSTR_STC_EACCESS;
    590                  goto FMSTR_WriteVar_exit;
    591              }
    592          #endif
    593          
    594              /*lint -e{534} ignoring function return value */
    595              FMSTR_CopyFromBuffer(nAddr, pMessageIO, nSize);
    596              nResponseCode = FMSTR_STS_OK;
    597          
    598          FMSTR_WriteVar_exit:
    599              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
    600          }
    601          
    602          
    603          /**************************************************************************//*!
    604          *
    605          * @brief    Handling WRITEMEMMASK and WRITEMEMMASK_EX commands
    606          *
    607          * @param    pMessageIO - original command (in) and response buffer (out) 
    608          *
    609          * @return   As all command handlers, the return value should be the buffer 
    610          *           pointer where the response output finished (except checksum)
    611          *
    612          ******************************************************************************/
    613          

   \                                 In section .text, align 2, keep-with-next
    614          FMSTR_BPTR FMSTR_WriteMemMask(FMSTR_BPTR pMessageIO)
    615          {
   \                     FMSTR_WriteMemMask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    616              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x0006             MOVS     R6,R0
    617              FMSTR_ADDR nAddr;
    618              FMSTR_U8 nSize,nResponseCode;
    619          
    620              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    621              pMessageIO = FMSTR_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x7884             LDRB     R4,[R0, #+2]
   \   00000008   0x1CC1             ADDS     R1,R0,#+3
    622              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000010   0x0005             MOVS     R5,R0
    623          
    624          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    625              if(!FMSTR_CheckTsaSpace(nAddr, (FMSTR_SIZE8)nSize, FMSTR_TRUE))
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE      ??FMSTR_WriteMemMask_0
    626              {
    627                  nResponseCode = FMSTR_STC_EACCESS;
   \   00000020   0x2089             MOVS     R0,#+137
    628                  goto FMSTR_WriteMemMask_exit;
   \   00000022   0xE005             B        ??FMSTR_WriteMemMask_1
    629              }
    630          #endif
    631          
    632          #if FMSTR_CFG_BUS_WIDTH > 1U
    633              /* size must be divisible by bus width (mask must not begin in half of memory word) */
    634              if(nSize % FMSTR_CFG_BUS_WIDTH)
    635              {
    636                  nResponseCode = FMSTR_STC_INVSIZE;
    637                  goto FMSTR_WriteMemMask_exit;
    638              }
    639          #endif
    640          
    641              /* put the data */
    642              FMSTR_CopyFromBufferWithMask(nAddr, pMessageIO, (FMSTR_SIZE8)nSize);
   \                     ??FMSTR_WriteMemMask_0: (+1)
   \   00000024   0x0022             MOVS     R2,R4
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x.... 0x....      BL       FMSTR_CopyFromBufferWithMask
    643              nResponseCode = FMSTR_STS_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
    644          
    645          FMSTR_WriteMemMask_exit:
    646              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_WriteMemMask_1: (+1)
   \   00000030   0x....             B.N      ??Subroutine0_0
    647          }
    648          
    649          /**************************************************************************//*!
    650          *
    651          * @brief    Handling WRITEVARMASK command
    652          *
    653          * @param    pMessageIO - original command (in) and response buffer (out) 
    654          * @param    nSize - variable size
    655          *
    656          * @return   As all command handlers, the return value should be the buffer 
    657          *           pointer where the response output finished (except checksum)
    658          *
    659          ******************************************************************************/
    660          

   \                                 In section .text, align 2, keep-with-next
    661          FMSTR_BPTR FMSTR_WriteVarMask(FMSTR_BPTR pMessageIO, FMSTR_SIZE8 nSize)
    662          {
   \                     FMSTR_WriteVarMask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    663              FMSTR_BPTR pResponse = pMessageIO;
   \   00000006   0x0006             MOVS     R6,R0
    664              FMSTR_ADDR nAddr;
    665              FMSTR_U8 nResponseCode;
    666              
    667              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 1U);
    668              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1C41             ADDS     R1,R0,#+1
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000010   0x0005             MOVS     R5,R0
    669          
    670          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    671              if(!FMSTR_CheckTsaSpace(nAddr, nSize, FMSTR_TRUE))
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE      ??FMSTR_WriteVarMask_0
    672              {
    673                  nResponseCode = FMSTR_STC_EACCESS;
   \   00000020   0x2089             MOVS     R0,#+137
    674                  goto FMSTR_WriteVarMask_exit;
   \   00000022   0xE005             B        ??FMSTR_WriteVarMask_1
    675              }
    676          #endif
    677          
    678              /* put the data */
    679              FMSTR_CopyFromBufferWithMask(nAddr, pMessageIO, nSize);         
   \                     ??FMSTR_WriteVarMask_0: (+1)
   \   00000024   0x0022             MOVS     R2,R4
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x.... 0x....      BL       FMSTR_CopyFromBufferWithMask
    680              nResponseCode = FMSTR_STS_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
    681          
    682          FMSTR_WriteVarMask_exit:
    683              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_WriteVarMask_1: (+1)
   \   00000030   0x....             B.N      ??Subroutine0_0
    684          }
    685          
    686          
    687          /**************************************************************************//*!
    688          *
    689          * @brief    Private inline implementation of "strlen" used by TSA and Pipes
    690          *
    691          ******************************************************************************/
    692          

   \                                 In section .text, align 2, keep-with-next
    693          FMSTR_U16 FMSTR_StrLen(FMSTR_ADDR nAddr)
    694          {
   \                     FMSTR_StrLen: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    695              const FMSTR_U8* pStr;
    696              FMSTR_U16 nLen = 0U;
   \   00000002   0x2000             MOVS     R0,#+0
    697          
    698              #ifdef __HCS12X__
    699              /* convert from logical to global if needed */
    700              nAddr = FMSTR_FixHcs12xAddr(nAddr);
    701              #endif
    702          
    703              /*lint -e{923} casting address value to pointer */
    704              pStr = (const FMSTR_U8*) nAddr;
   \   00000004   0xE001             B        ??FMSTR_StrLen_0
    705              
    706              while(*pStr++)
   \                     ??FMSTR_StrLen_1: (+1)
   \   00000006   0x1C49             ADDS     R1,R1,#+1
    707              {
    708                  nLen++;
   \   00000008   0x1C40             ADDS     R0,R0,#+1
    709              }
   \                     ??FMSTR_StrLen_0: (+1)
   \   0000000A   0x780A             LDRB     R2,[R1, #+0]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD1FA             BNE      ??FMSTR_StrLen_1
    710                  
    711              return nLen;
   \   00000010   0xB280             UXTH     R0,R0
   \   00000012   0x4770             BX       LR               ;; return
    712          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x00008341         DC32     0x8341

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Kxx FreeMASTER">`:
   \   00000000   0x4B 0x78          DC8 "Kxx FreeMASTER"
   \              0x78 0x20    
   \              0x46 0x72    
   \              0x65 0x65    
   \              0x4D 0x41    
   \              0x53 0x54    
   \              0x45 0x52    
   \              0x00         
   \   0000000F   0x00               DC8 0
    713          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FMSTR_GetBoardInfo
        16   -> FMSTR_GetRecBuffSize
        16   -> FMSTR_ValueToBuffer16
       8   FMSTR_Init
         8   -> FMSTR_InitRec
         8   -> FMSTR_InitScope
         8   -> FMSTR_InitSerial
         8   -> FMSTR_InitTsa
       8   FMSTR_ProtocolDecoder
         8   -> FMSTR_GetBoardInfo
         8   -> FMSTR_GetRecBuff
         8   -> FMSTR_GetRecStatus
         8   -> FMSTR_GetStringLen
         8   -> FMSTR_GetTsaInfo
         8   -> FMSTR_ReadMem
         8   -> FMSTR_ReadScope
         8   -> FMSTR_SendResponse
         8   -> FMSTR_SetExAddr
         8   -> FMSTR_SetUpRec
         8   -> FMSTR_SetUpScope
         8   -> FMSTR_StartRec
         8   -> FMSTR_StopRec
         8   -> FMSTR_WriteMem
         8   -> FMSTR_WriteMemMask
      16   FMSTR_ReadMem
        16   -> FMSTR_AddressFromBuffer
        16   -> FMSTR_CheckTsaSpace
        16   -> FMSTR_CopyToBuffer
      16   FMSTR_ReadVar
        16   -> FMSTR_AddressFromBuffer
        16   -> FMSTR_CheckTsaSpace
        16   -> FMSTR_CopyToBuffer
       0   FMSTR_StrLen
      24   FMSTR_WriteMem
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBuffer
      24   FMSTR_WriteMemMask
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBufferWithMask
      24   FMSTR_WriteVar
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBuffer
      24   FMSTR_WriteVarMask
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBufferWithMask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "Kxx FreeMASTER">
       4  ??DataTable1
      44  ?Subroutine0
     114  FMSTR_GetBoardInfo
      22  FMSTR_Init
     246  FMSTR_ProtocolDecoder
      60  FMSTR_ReadMem
      52  FMSTR_ReadVar
      20  FMSTR_StrLen
      12  FMSTR_WriteMem
      50  FMSTR_WriteMemMask
      10  FMSTR_WriteVar
      50  FMSTR_WriteVarMask

 
 700 bytes in section .text
 
 700 bytes of CODE memory

Errors: none
Warnings: none
