###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        30/Jan/2016  15:22:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\gpio\gpio.c
#    Command line =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\gpio\gpio.c
#        -D NDEBUG -lCN
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\
#        -o
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\
#        --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\common\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\drivers\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\freemaster\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\projects\_twr_emeter_demo\
#        -Oh --require_prototypes
#    List file    =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\gpio.lst
#    Object file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\gpio.o
#
###############################################################################

E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\gpio\gpio.c
      1          /*****************************************************************************
      2           * (c) Copyright 2010-2013, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      gpio.c
      6           * @version   1.0.4.0
      7           * @date      Mar-10-2013
      8           * @brief     General-Purpose Input/Output (GPIO) driver source code.
      9           ******************************************************************************/
     10          #include "common.h"
     11          #include "gpio.h"
     12          
     13          /******************************************************************************
     14           * data type definitions                                                      *
     15           ******************************************************************************/

   \                                 In section .bss, align 4
     16          static PORT_CALLBACK pCallbackPTx=NULL;
   \                     pCallbackPTx:
   \   00000000                      DS8 4
     17          
     18          /******************************************************************************
     19           * interrupt function prototypes                                              *
     20           ******************************************************************************/
     21          void PTx_isr (void);
     22          
     23          /******************************************************************************
     24           * Public function definitions                                                *
     25           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     26          void PORT_InstallCallback (uint8 ip, PORT_CALLBACK pCallback)
     27          {
     28            if (pCallback != NULL) { pCallbackPTx = pCallback; NVIC_SetIsr(INT_PTx,ip); }
   \                     PORT_InstallCallback: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0xD010             BEQ      ??PORT_InstallCallback_0
   \   00000004   0x....             LDR      R2,??DataTable8
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x0289             LSLS     R1,R1,#+10       ;; #+131072
   \   0000000C   0x....             LDR      R2,??DataTable8_1  ;; 0xe000e280
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x430B             ORRS     R3,R3,R1
   \   00000012   0x6013             STR      R3,[R2, #+0]
   \   00000014   0x....             LDR      R2,??DataTable8_2  ;; 0xe000e100
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable8_3  ;; 0xe000e410
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0380             LSLS     R0,R0,#+14
   \   00000022   0x4310             ORRS     R0,R0,R2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     29          }
   \                     ??PORT_InstallCallback_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
     30          
     31          #pragma diag_suppress=Pa082

   \                                 In section .text, align 2, keep-with-next
     32          void PORTA_Init (tPORT port, uint8 pin_mask)
     33          {
   \                     PORTA_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     34            register uint16 i;
     35            
     36            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable8_4  ;; 0x40046000
     37              if(pin_mask & (uint8)(1l << i)) { PORTA_BASE_PTR->PCR[i] = port.PCR; } 
   \                     ??PORTA_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTA_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTA_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTA_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTA_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTA_Init_0
     38            PORTA_ISFR &= ~pin_mask;  
   \   00000028   0x....             LDR      R0,??DataTable8_5  ;; 0x400460a0
   \   0000002A   0x....             B.N      ?Subroutine0
     39          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xB2D2             UXTB     R2,R2
   \   00000004   0x4391             BICS     R1,R1,R2
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0xBCF1             POP      {R0,R4-R7}
   \   0000000A   0x4770             BX       LR               ;; return
     40          

   \                                 In section .text, align 2, keep-with-next
     41          void PORTB_Init (tPORT port, uint8 pin_mask)
     42          {
   \                     PORTB_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     43            register uint16 i;
     44          
     45            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable8_6  ;; 0x40047000
     46              if(pin_mask & (uint8)(1l << i)) { PORTB_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTB_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTB_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTB_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTB_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTB_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTB_Init_0
     47            PORTB_ISFR &= ~pin_mask;  
   \   00000028   0x....             LDR      R0,??DataTable8_7  ;; 0x400470a0
   \   0000002A                      REQUIRE ?Subroutine0
   \   0000002A                      ;; // Fall through to label ?Subroutine0
     48          }
     49          

   \                                 In section .text, align 2, keep-with-next
     50          void PORTC_Init (tPORT port, uint8 pin_mask)
     51          {
   \                     PORTC_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     52            register uint16 i;
     53            
     54            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable8_8  ;; 0x40048000
     55              if(pin_mask & (uint8)(1l << i)) { PORTC_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTC_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTC_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTC_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTC_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTC_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTC_Init_0
     56            PORTC_ISFR &= ~pin_mask;
   \   00000028   0x....             LDR      R0,??DataTable9  ;; 0x400480a0
   \   0000002A   0x....             B.N      ?Subroutine0
     57          }
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void PORTD_Init (tPORT port, uint8 pin_mask)
     60          {
   \                     PORTD_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     61            register uint16 i;
     62          
     63            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable8_9  ;; 0x40049000
     64              if(pin_mask & (uint8)(1l << i)) { PORTD_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTD_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTD_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTD_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTD_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTD_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTD_Init_0
     65            PORTD_ISFR &= ~pin_mask;  
   \   00000028   0x....             LDR      R0,??DataTable9_1  ;; 0x400490a0
   \   0000002A   0x....             B.N      ?Subroutine0
     66          }
     67          

   \                                 In section .text, align 2, keep-with-next
     68          void PORTE_Init (tPORT port, uint8 pin_mask)
     69          {
   \                     PORTE_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     70            register uint16 i;
     71            
     72            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable8_10  ;; 0x4004a000
     73              if(pin_mask & (uint8)(1l << i)) { PORTE_BASE_PTR->PCR[i] = port.PCR; } 
   \                     ??PORTE_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTE_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTE_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTE_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTE_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTE_Init_0
     74            PORTE_DFER |= (port.DFER & pin_mask); /* DFER content OR-ed with pin_mask   */    
   \   00000028   0x....             LDR      R3,??DataTable9_2  ;; 0x4004a0a0
   \   0000002A   0x6A1C             LDR      R4,[R3, #+32]
   \   0000002C   0xB2D2             UXTB     R2,R2
   \   0000002E   0x4011             ANDS     R1,R1,R2
   \   00000030   0x4321             ORRS     R1,R1,R4
   \   00000032   0x6219             STR      R1,[R3, #+32]
     75            PORTE_ISFR &= ~pin_mask;  
   \   00000034   0x6818             LDR      R0,[R3, #+0]
   \   00000036   0x4390             BICS     R0,R0,R2
   \   00000038   0x6018             STR      R0,[R3, #+0]
     76          }
   \   0000003A   0xBCF1             POP      {R0,R4-R7}
   \   0000003C   0x4770             BX       LR               ;; return
     77          

   \                                 In section .text, align 2, keep-with-next
     78          void PORTF_Init (tPORT port, uint8 pin_mask)
     79          {
   \                     PORTF_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     80            register uint16 i;
     81            
     82            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable9_3  ;; 0x4004b000
     83              if(pin_mask & (uint8)(1l << i)) { PORTF_BASE_PTR->PCR[i] = port.PCR; } 
   \                     ??PORTF_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTF_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTF_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTF_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTF_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTF_Init_0
     84            PORTF_ISFR &= ~pin_mask;  
   \   00000028   0x....             LDR      R0,??DataTable9_4  ;; 0x4004b0a0
   \   0000002A   0x....             B.N      ?Subroutine0
     85          }
     86          

   \                                 In section .text, align 2, keep-with-next
     87          void PORTG_Init (tPORT port, uint8 pin_mask)
     88          {
   \                     PORTG_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     89            register uint16 i;
     90            
     91            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable9_5  ;; 0x4004c000
     92              if(pin_mask & (uint8)(1l << i)) { PORTG_BASE_PTR->PCR[i] = port.PCR; } 
   \                     ??PORTG_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTG_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTG_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTG_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTG_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTG_Init_0
     93            PORTG_ISFR &= ~pin_mask;  
   \   00000028   0x....             LDR      R0,??DataTable9_6  ;; 0x4004c0a0
   \   0000002A   0x....             B.N      ?Subroutine0
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          void PORTH_Init (tPORT port, uint8 pin_mask)
     97          {
   \                     PORTH_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
     98            register uint16 i;
     99            
    100            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable9_7  ;; 0x4004d000
    101              if(pin_mask & (uint8)(1l << i)) { PORTH_BASE_PTR->PCR[i] = port.PCR; } 
   \                     ??PORTH_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTH_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTH_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTH_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTH_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTH_Init_0
    102            PORTH_ISFR &= ~pin_mask;  
   \   00000028   0x....             LDR      R0,??DataTable9_8  ;; 0x4004d0a0
   \   0000002A   0x....             B.N      ?Subroutine0
    103          }
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void PORTI_Init (tPORT port, uint8 pin_mask)
    106          {
   \                     PORTI_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
    107            register uint16 i;
    108            
    109            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R4,??DataTable9_9  ;; 0x4004e000
    110              if(pin_mask & (uint8)(1l << i)) { PORTI_BASE_PTR->PCR[i] = port.PCR; } 
   \                     ??PORTI_Init_0: (+1)
   \   00000006   0x2501             MOVS     R5,#+1
   \   00000008   0x2601             MOVS     R6,#+1
   \   0000000A   0x409E             LSLS     R6,R6,R3
   \   0000000C   0xB2D7             UXTB     R7,R2
   \   0000000E   0x4237             TST      R7,R6
   \   00000010   0xD000             BEQ      ??PORTI_Init_1
   \   00000012   0x6020             STR      R0,[R4, #+0]
   \                     ??PORTI_Init_1: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0x409D             LSLS     R5,R5,R3
   \   00000018   0xB2D6             UXTB     R6,R2
   \   0000001A   0x422E             TST      R6,R5
   \   0000001C   0xD000             BEQ      ??PORTI_Init_2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
   \                     ??PORTI_Init_2: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x3408             ADDS     R4,R4,#+8
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xDBEE             BLT      ??PORTI_Init_0
    111            PORTI_ISFR &= ~pin_mask;  
   \   00000028   0x....             LDR      R0,??DataTable9_10  ;; 0x4004e0a0
   \   0000002A   0x....             B.N      ?Subroutine0
    112          }
    113          
    114          /******************************************************************************
    115           * interrupt function definitions                                             *
    116           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    117          void PTx_isr (void) 
    118          { 
   \                     PTx_isr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    119            register uint8 tmp;
    120            
    121            /* process interrupt callback function for PORTA                            */
    122            if (SIM_SCGC5 & SIM_SCGC5_PORTA_MASK)
   \   00000002   0x....             LDR      R4,??DataTable9_11
   \   00000004   0x....             LDR      R5,??DataTable9_12  ;; 0x4003f038
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD50B             BPL      ??PTx_isr_0
    123            {  
    124              tmp = (uint8)PORTA_ISFR;
   \   0000000C   0x....             LDR      R0,??DataTable9_13  ;; 0x400460a0
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
    125              iosetw (PORTA_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   00000010   0xB2C9             UXTB     R1,R1
   \   00000012   0x....             LDR      R0,??DataTable9_14  ;; 0x480460a0
   \   00000014   0x6001             STR      R1,[R0, #+0]
    126              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD004             BEQ      ??PTx_isr_0
   \   0000001A   0x6822             LDR      R2,[R4, #+0]
   \   0000001C   0x0010             MOVS     R0,R2
   \   0000001E   0xD001             BEQ      ??PTx_isr_0
    127                pCallbackPTx (PORTA_CALLBACK, tmp);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4790             BLX      R2
    128            }
    129            
    130            /* process interrupt callback function for PORTB                            */
    131            if (SIM_SCGC5 & SIM_SCGC5_PORTB_MASK)
   \                     ??PTx_isr_0: (+1)
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x0600             LSLS     R0,R0,#+24
   \   00000028   0xD50B             BPL      ??PTx_isr_1
    132            {   
    133              tmp = (uint8)PORTB_ISFR;
   \   0000002A   0x....             LDR      R0,??DataTable9_15  ;; 0x400470a0
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
    134              iosetw (PORTB_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   0000002E   0xB2C9             UXTB     R1,R1
   \   00000030   0x....             LDR      R0,??DataTable9_16  ;; 0x480470a0
   \   00000032   0x6001             STR      R1,[R0, #+0]
    135              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD004             BEQ      ??PTx_isr_1
   \   00000038   0x6822             LDR      R2,[R4, #+0]
   \   0000003A   0x0010             MOVS     R0,R2
   \   0000003C   0xD001             BEQ      ??PTx_isr_1
    136                pCallbackPTx (PORTB_CALLBACK, tmp);
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x4790             BLX      R2
    137            }
    138            
    139            /* process interrupt callback function for PORTC                            */ 
    140            if (SIM_SCGC5 & SIM_SCGC5_PORTC_MASK)
   \                     ??PTx_isr_1: (+1)
   \   00000042   0x0DAE             LSRS     R6,R5,#+22
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0x4030             ANDS     R0,R0,R6
   \   00000048   0xD00B             BEQ      ??PTx_isr_2
    141            {   
    142              tmp = (uint8)PORTC_ISFR;
   \   0000004A   0x....             LDR      R0,??DataTable9  ;; 0x400480a0
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
    143              iosetw (PORTC_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   0000004E   0xB2C9             UXTB     R1,R1
   \   00000050   0x....             LDR      R0,??DataTable9_17  ;; 0x480480a0
   \   00000052   0x6001             STR      R1,[R0, #+0]
    144              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD004             BEQ      ??PTx_isr_2
   \   00000058   0x6822             LDR      R2,[R4, #+0]
   \   0000005A   0x0010             MOVS     R0,R2
   \   0000005C   0xD001             BEQ      ??PTx_isr_2
    145                pCallbackPTx (PORTC_CALLBACK, tmp);
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0x4790             BLX      R2
    146            }
    147            
    148            /* process interrupt callback function for PORTD                            */
    149            if (SIM_SCGC5 & SIM_SCGC5_PORTD_MASK)
   \                     ??PTx_isr_2: (+1)
   \   00000062   0x6828             LDR      R0,[R5, #+0]
   \   00000064   0x0580             LSLS     R0,R0,#+22
   \   00000066   0xD50B             BPL      ??PTx_isr_3
    150            {  
    151              tmp = (uint8)PORTD_ISFR;
   \   00000068   0x....             LDR      R0,??DataTable9_1  ;; 0x400490a0
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
    152              iosetw (PORTD_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   0000006C   0xB2C9             UXTB     R1,R1
   \   0000006E   0x....             LDR      R0,??DataTable9_18  ;; 0x480490a0
   \   00000070   0x6001             STR      R1,[R0, #+0]
    153              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   00000072   0x2900             CMP      R1,#+0
   \   00000074   0xD004             BEQ      ??PTx_isr_3
   \   00000076   0x6822             LDR      R2,[R4, #+0]
   \   00000078   0x0010             MOVS     R0,R2
   \   0000007A   0xD001             BEQ      ??PTx_isr_3
    154                pCallbackPTx (PORTD_CALLBACK, tmp);
   \   0000007C   0x2008             MOVS     R0,#+8
   \   0000007E   0x4790             BLX      R2
    155            }
    156            
    157            /* process interrupt callback function for PORTE                            */
    158            if (SIM_SCGC5 & SIM_SCGC5_PORTE_MASK)
   \                     ??PTx_isr_3: (+1)
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0x0540             LSLS     R0,R0,#+21
   \   00000084   0xD50B             BPL      ??PTx_isr_4
    159            {    
    160              tmp = (uint8)PORTE_ISFR;
   \   00000086   0x....             LDR      R0,??DataTable9_2  ;; 0x4004a0a0
   \   00000088   0x6801             LDR      R1,[R0, #+0]
    161              iosetw (PORTE_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   0000008A   0xB2C9             UXTB     R1,R1
   \   0000008C   0x....             LDR      R0,??DataTable9_19  ;; 0x4804a0a0
   \   0000008E   0x6001             STR      R1,[R0, #+0]
    162              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0xD004             BEQ      ??PTx_isr_4
   \   00000094   0x6822             LDR      R2,[R4, #+0]
   \   00000096   0x0010             MOVS     R0,R2
   \   00000098   0xD001             BEQ      ??PTx_isr_4
    163                pCallbackPTx (PORTE_CALLBACK, tmp);
   \   0000009A   0x2010             MOVS     R0,#+16
   \   0000009C   0x4790             BLX      R2
    164            }
    165            
    166            /* process interrupt callback function for PORTF                            */
    167            if (SIM_SCGC5 & SIM_SCGC5_PORTF_MASK)
   \                     ??PTx_isr_4: (+1)
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0x0500             LSLS     R0,R0,#+20
   \   000000A2   0xD50B             BPL      ??PTx_isr_5
    168            {      
    169              tmp = (uint8)PORTF_ISFR;
   \   000000A4   0x....             LDR      R0,??DataTable9_4  ;; 0x4004b0a0
   \   000000A6   0x6801             LDR      R1,[R0, #+0]
    170              iosetw (PORTF_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   000000A8   0xB2C9             UXTB     R1,R1
   \   000000AA   0x....             LDR      R0,??DataTable9_20  ;; 0x4804b0a0
   \   000000AC   0x6001             STR      R1,[R0, #+0]
    171              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   000000AE   0x2900             CMP      R1,#+0
   \   000000B0   0xD004             BEQ      ??PTx_isr_5
   \   000000B2   0x6822             LDR      R2,[R4, #+0]
   \   000000B4   0x0010             MOVS     R0,R2
   \   000000B6   0xD001             BEQ      ??PTx_isr_5
    172                pCallbackPTx (PORTF_CALLBACK, tmp);
   \   000000B8   0x2020             MOVS     R0,#+32
   \   000000BA   0x4790             BLX      R2
    173            }
    174            
    175            /* process interrupt callback function for PORTG                            */
    176            if (SIM_SCGC5 & SIM_SCGC5_PORTG_MASK)
   \                     ??PTx_isr_5: (+1)
   \   000000BC   0x6828             LDR      R0,[R5, #+0]
   \   000000BE   0x04C0             LSLS     R0,R0,#+19
   \   000000C0   0xD50B             BPL      ??PTx_isr_6
    177            {        
    178              tmp = (uint8)PORTG_ISFR;
   \   000000C2   0x....             LDR      R0,??DataTable9_6  ;; 0x4004c0a0
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
    179              iosetw (PORTG_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   000000C6   0xB2C9             UXTB     R1,R1
   \   000000C8   0x....             LDR      R0,??DataTable9_21  ;; 0x4804c0a0
   \   000000CA   0x6001             STR      R1,[R0, #+0]
    180              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xD004             BEQ      ??PTx_isr_6
   \   000000D0   0x6822             LDR      R2,[R4, #+0]
   \   000000D2   0x0010             MOVS     R0,R2
   \   000000D4   0xD001             BEQ      ??PTx_isr_6
    181                pCallbackPTx (PORTG_CALLBACK, tmp);
   \   000000D6   0x2040             MOVS     R0,#+64
   \   000000D8   0x4790             BLX      R2
    182            }
    183            
    184            /* process interrupt callback function for PORTH                            */
    185            if (SIM_SCGC5 & SIM_SCGC5_PORTH_MASK)
   \                     ??PTx_isr_6: (+1)
   \   000000DA   0x6828             LDR      R0,[R5, #+0]
   \   000000DC   0x0480             LSLS     R0,R0,#+18
   \   000000DE   0xD50B             BPL      ??PTx_isr_7
    186            {        
    187              tmp = (uint8)PORTH_ISFR;
   \   000000E0   0x....             LDR      R0,??DataTable9_8  ;; 0x4004d0a0
   \   000000E2   0x6801             LDR      R1,[R0, #+0]
    188              iosetw (PORTH_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   000000E4   0xB2C9             UXTB     R1,R1
   \   000000E6   0x....             LDR      R0,??DataTable9_22  ;; 0x4804d0a0
   \   000000E8   0x6001             STR      R1,[R0, #+0]
    189              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   000000EA   0x2900             CMP      R1,#+0
   \   000000EC   0xD004             BEQ      ??PTx_isr_7
   \   000000EE   0x6822             LDR      R2,[R4, #+0]
   \   000000F0   0x0010             MOVS     R0,R2
   \   000000F2   0xD001             BEQ      ??PTx_isr_7
    190                pCallbackPTx (PORTH_CALLBACK, tmp);
   \   000000F4   0x2080             MOVS     R0,#+128
   \   000000F6   0x4790             BLX      R2
    191            }
    192            
    193            /* process interrupt callback function for PORTI                            */
    194            if (SIM_SCGC5 & SIM_SCGC5_PORTI_MASK)
   \                     ??PTx_isr_7: (+1)
   \   000000F8   0x6828             LDR      R0,[R5, #+0]
   \   000000FA   0x0440             LSLS     R0,R0,#+17
   \   000000FC   0xD50B             BPL      ??PTx_isr_8
    195            {          
    196              tmp = (uint8)PORTI_ISFR;
   \   000000FE   0x....             LDR      R0,??DataTable9_10  ;; 0x4004e0a0
   \   00000100   0x6801             LDR      R1,[R0, #+0]
    197              iosetw (PORTI_ISFR,tmp);        /* clear peripheral interrupt flags       */
   \   00000102   0xB2C9             UXTB     R1,R1
   \   00000104   0x....             LDR      R0,??DataTable9_23  ;; 0x4804e0a0
   \   00000106   0x6001             STR      R1,[R0, #+0]
    198              if ((tmp != 0) && (pCallbackPTx != (PORT_CALLBACK)NULL)) 
   \   00000108   0x2900             CMP      R1,#+0
   \   0000010A   0xD004             BEQ      ??PTx_isr_8
   \   0000010C   0x6822             LDR      R2,[R4, #+0]
   \   0000010E   0x0010             MOVS     R0,R2
   \   00000110   0xD001             BEQ      ??PTx_isr_8
    199                pCallbackPTx (PORTI_CALLBACK, tmp);
   \   00000112   0x0030             MOVS     R0,R6
   \   00000114   0x4790             BLX      R2
    200            }
    201          }
   \                     ??PTx_isr_8: (+1)
   \   00000116   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     pCallbackPTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0xE000E410         DC32     0xe000e410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40046000         DC32     0x40046000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x400460A0         DC32     0x400460a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x40047000         DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x400470A0         DC32     0x400470a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x40048000         DC32     0x40048000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x400480A0         DC32     0x400480a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4004E000         DC32     0x4004e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x4004E0A0         DC32     0x4004e0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     pCallbackPTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x4003F038         DC32     0x4003f038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x400460A0         DC32     0x400460a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x480460A0         DC32     0x480460a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x400470A0         DC32     0x400470a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x480470A0         DC32     0x480470a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x480480A0         DC32     0x480480a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x480490A0         DC32     0x480490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x4804A0A0         DC32     0x4804a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x4804B0A0         DC32     0x4804b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x4804C0A0         DC32     0x4804c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x4804D0A0         DC32     0x4804d0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x4804E0A0         DC32     0x4804e0a0
    202          /******************************************************************************
    203           * End of module                                                              *
    204           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   PORTA_Init
      20   PORTB_Init
      20   PORTC_Init
      20   PORTD_Init
      20   PORTE_Init
      20   PORTF_Init
      20   PORTG_Init
      20   PORTH_Init
      20   PORTI_Init
       0   PORT_InstallCallback
      16   PTx_isr
        16   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  ?Subroutine0
      44  PORTA_Init
      42  PORTB_Init
      44  PORTC_Init
      44  PORTD_Init
      62  PORTE_Init
      44  PORTF_Init
      44  PORTG_Init
      44  PORTH_Init
      44  PORTI_Init
      40  PORT_InstallCallback
     280  PTx_isr
       4  pCallbackPTx

 
   4 bytes in section .bss
 884 bytes in section .text
 
 884 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
