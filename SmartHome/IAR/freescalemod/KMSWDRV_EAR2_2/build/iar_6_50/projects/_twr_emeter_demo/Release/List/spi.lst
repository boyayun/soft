###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        30/Jan/2016  15:22:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\spi\spi.c
#    Command line =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\spi\spi.c
#        -D NDEBUG -lCN
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\
#        -o
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\
#        --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\common\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\drivers\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\freemaster\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\projects\_twr_emeter_demo\
#        -Oh --require_prototypes
#    List file    =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\spi.lst
#    Object file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\spi.o
#
###############################################################################

E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\spi\spi.c
      1          /*****************************************************************************
      2           * (c) Copyright 2010-2013, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      spi.c
      6           * @version   1.0.3.0
      7           * @date      Mar-12-2013
      8           * @brief     SPI driver source code.
      9          ******************************************************************************/
     10          #include "common.h"
     11          #include "spi.h"
     12          
     13          /******************************************************************************
     14           * data type definitions                                                      *
     15           ******************************************************************************/

   \                                 In section .bss, align 4
     16          static SPI_CALLBACK     volatile pCallbackSPI0=NULL;
   \                     pCallbackSPI0:
   \   00000000                      DS8 4
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
     17          static SPI_CALLBACK     volatile pCallbackSPI1=NULL;
   \                     pCallbackSPI1:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
     18          static SPI_SSCALLBACK   volatile pCallbackSS0=NULL;
     19          static SPI_SSCALLBACK   volatile pCallbackSS1=NULL;
     20          
     21          /******************************************************************************
     22           * interrupt function prototypes                                              *
     23           ******************************************************************************/
     24          void spi0_isr (void); 
     25          void spi1_isr (void); 
     26          
     27          /******************************************************************************
     28           * Public functions definitions                                               *
     29           ******************************************************************************/
     30          #pragma diag_suppress=Pa082 
     31          
     32          /******************************************************************************
     33           * SPI Init functions                                                         *
     34           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     35          void SPI0_Init (tSPI spi,SPI_SSCALLBACK pC2,uint8 ip,SPI_CALLBACK pC1)
     36          {     
   \                     SPI0_Init: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x9804             LDR      R0,[SP, #+16]
     37            /* main callback function initialization */
     38            if (pC1 != NULL)  
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD010             BEQ      ??SPI0_Init_0
     39            { 
     40              pCallbackSPI0 = pC1; 
   \   00000008   0x....             LDR      R1,??DataTable5
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     41              NVIC_SetIsr(INT_SPI0,ip); 
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x....             LDR      R1,??DataTable5_1  ;; 0xe000e280
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x4304             ORRS     R4,R4,R0
   \   00000014   0x600C             STR      R4,[R1, #+0]
   \   00000016   0x....             LDR      R1,??DataTable5_2  ;; 0xe000e100
   \   00000018   0x680C             LDR      R4,[R1, #+0]
   \   0000001A   0x4320             ORRS     R0,R0,R4
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x....             LDR      R0,??DataTable5_3  ;; 0xe000e404
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x061B             LSLS     R3,R3,#+24
   \   00000024   0x0C9B             LSRS     R3,R3,#+18
   \   00000026   0x430B             ORRS     R3,R3,R1
   \   00000028   0x6003             STR      R3,[R0, #+0]
     42            }
     43          
     44            /* initialization of SS callback function where SS will be driven manually */
     45            if (pC2 != NULL) { 
   \                     ??SPI0_Init_0: (+1)
   \   0000002A   0x0010             MOVS     R0,R2
   \   0000002C   0xD004             BEQ      ??SPI0_Init_1
     46              pCallbackSS0 = pC2; 
   \   0000002E   0x....             LDR      R1,??DataTable5
   \   00000030   0x604A             STR      R2,[R1, #+4]
     47              pCallbackSS0 (SS_INIT);     /* SS port initialization */
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x6849             LDR      R1,[R1, #+4]
   \   00000036   0x4788             BLX      R1
     48            }
     49            
     50            /* SPI configuration (without C3 register) */
     51            SPI0_C1      = spi.C1;        /* SPI control register 1 */
   \                     ??SPI0_Init_1: (+1)
   \   00000038   0x....             LDR      R0,??DataTable5_4  ;; 0x40075001
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x7081             STRB     R1,[R0, #+2]
     52            SPI0_C2      = spi.C2;        /* SPI control register 2 */
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7849             LDRB     R1,[R1, #+1]
   \   00000044   0x7041             STRB     R1,[R0, #+1]
     53            SPI0_BR      = spi.BR;        /* SPI baud rate register */
   \   00000046   0x....             B.N      ?Subroutine0
     54            SPI0_ML      = spi.ML;        /* SPI match register low */
     55            SPI0_MH      = spi.MH;        /* SPI match register high */
     56            SPI0_C1 |= SPI_C1_SPE_MASK;   /* Enable SPI */ 
     57            /* Note: FIFO functionality is not supported in SPI0 module */
     58          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4669             MOV      R1,SP
   \   00000002   0x78C9             LDRB     R1,[R1, #+3]
   \   00000004   0x7001             STRB     R1,[R0, #+0]
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x7909             LDRB     R1,[R1, #+4]
   \   0000000A   0x70C1             STRB     R1,[R0, #+3]
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7949             LDRB     R1,[R1, #+5]
   \   00000010   0x7101             STRB     R1,[R0, #+4]
   \   00000012   0x7881             LDRB     R1,[R0, #+2]
   \   00000014   0x2240             MOVS     R2,#+64
   \   00000016   0x430A             ORRS     R2,R2,R1
   \   00000018   0x7082             STRB     R2,[R0, #+2]
   \   0000001A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     59          

   \                                 In section .text, align 2, keep-with-next
     60          void SPI1_Init (tSPI spi,SPI_SSCALLBACK pC2,uint8 ip, SPI_CALLBACK pC1)
     61          {     
   \                     SPI1_Init: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x9804             LDR      R0,[SP, #+16]
     62            /* main callback function initialization */
     63            if (pC1 != NULL)  
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD010             BEQ      ??SPI1_Init_0
     64            { 
     65              pCallbackSPI1 = pC1; 
   \   00000008   0x....             LDR      R1,??DataTable5_5
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     66              NVIC_SetIsr(INT_SPI1,ip); 
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0x....             LDR      R1,??DataTable5_1  ;; 0xe000e280
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x4304             ORRS     R4,R4,R0
   \   00000014   0x600C             STR      R4,[R1, #+0]
   \   00000016   0x....             LDR      R1,??DataTable5_2  ;; 0xe000e100
   \   00000018   0x680C             LDR      R4,[R1, #+0]
   \   0000001A   0x4320             ORRS     R0,R0,R4
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x....             LDR      R0,??DataTable5_3  ;; 0xe000e404
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x061B             LSLS     R3,R3,#+24
   \   00000024   0x0A9B             LSRS     R3,R3,#+10
   \   00000026   0x430B             ORRS     R3,R3,R1
   \   00000028   0x6003             STR      R3,[R0, #+0]
     67            }
     68          
     69            /* initialization of SS callback function where SS will be driven manually */
     70            if (pC2 != NULL) { 
   \                     ??SPI1_Init_0: (+1)
   \   0000002A   0x0010             MOVS     R0,R2
   \   0000002C   0xD004             BEQ      ??SPI1_Init_1
     71              pCallbackSS1 = pC2; 
   \   0000002E   0x....             LDR      R1,??DataTable5_5
   \   00000030   0x604A             STR      R2,[R1, #+4]
     72              pCallbackSS1 (SS_INIT);     /* SS port initialization */
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x6849             LDR      R1,[R1, #+4]
   \   00000036   0x4788             BLX      R1
     73            }
     74            
     75            /* SPI configuration (with C3 register) */
     76            SPI1_C1      = spi.C1;        /* SPI control register 1 */
   \                     ??SPI1_Init_1: (+1)
   \   00000038   0x....             LDR      R0,??DataTable6  ;; 0x40076001
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x7081             STRB     R1,[R0, #+2]
     77            SPI1_C2      = spi.C2;        /* SPI control register 2 */
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7849             LDRB     R1,[R1, #+1]
   \   00000044   0x7041             STRB     R1,[R0, #+1]
     78            SPI1_C3      = spi.C3;        /* SPI control register 3 */
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x7889             LDRB     R1,[R1, #+2]
   \   0000004A   0x7281             STRB     R1,[R0, #+10]
     79            SPI1_BR      = spi.BR;        /* SPI baud rate register */
   \   0000004C                      REQUIRE ?Subroutine0
   \   0000004C                      ;; // Fall through to label ?Subroutine0
     80            SPI1_ML      = spi.ML;        /* SPI match register low */
     81            SPI1_MH      = spi.MH;        /* SPI match register high */
     82            SPI1_C1 |= SPI_C1_SPE_MASK;   /* Enable SPI */ 
     83          }
     84          
     85          /******************************************************************************
     86           * Simple SPI Tx/Rx function (1 word Tx + 1 word Rx)                          *
     87           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     88          uint16 SPI0_TxRxWord(uint16 txdata)
   \                     SPI0_TxRxWord: (+1)
   \   00000000   0x2220             MOVS     R2,#+32
   \   00000002   0x....             LDR      R1,??DataTable7  ;; 0x40075000
   \   00000004   0x....             B.N      ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
     89          {
     90            while (!SPI_TxCompl(SPI0));   /* wait until Tx buffer is empty */
   \                     ?Subroutine1: (+1)
   \   00000000   0x780B             LDRB     R3,[R1, #+0]
   \   00000002   0x4213             TST      R3,R2
   \   00000004   0xD0FC             BEQ      ?Subroutine1
     91            SPI_PutData(SPI0,txdata);     /* write an 16-bit data */
   \   00000006   0x7188             STRB     R0,[R1, #+6]
   \   00000008   0x0A00             LSRS     R0,R0,#+8
   \   0000000A   0x71C8             STRB     R0,[R1, #+7]
   \   0000000C   0x2080             MOVS     R0,#+128
     92            while(!SPI_RxFull(SPI0));     /* wait until Rx buffer is full */
   \                     ??Subroutine1_0: (+1)
   \   0000000E   0x780A             LDRB     R2,[R1, #+0]
   \   00000010   0x4202             TST      R2,R0
   \   00000012   0xD0FC             BEQ      ??Subroutine1_0
     93            return (SPI_GetData(SPI0));   /* read data and exit */
   \   00000014   0x798A             LDRB     R2,[R1, #+6]
   \   00000016   0x79C8             LDRB     R0,[R1, #+7]
   \   00000018   0x0200             LSLS     R0,R0,#+8
   \   0000001A   0x4310             ORRS     R0,R0,R2
   \   0000001C   0x4770             BX       LR               ;; return
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          uint16 SPI1_TxRxWord(uint16 txdata)
   \                     SPI1_TxRxWord: (+1)
   \   00000000   0x2220             MOVS     R2,#+32
   \   00000002   0x....             LDR      R1,??DataTable6_1  ;; 0x40076000
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
     97          {
     98            while (!SPI_TxCompl(SPI1));   /* wait until Tx buffer is empty */
     99            SPI_PutData(SPI1,txdata);     /* write an 16-bit data */
    100            while(!SPI_RxFull(SPI1));     /* wait until Rx buffer is full */
    101            return (SPI_GetData(SPI1));   /* read data and exit */
    102          }
    103          
    104          /******************************************************************************
    105           * Simple SPI Tx/Rx function (1 byte Tx + 1 byte Rx)                          *
    106           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    107          uint8 SPI0_TxRxByte(uint8 txdata)
   \                     SPI0_TxRxByte: (+1)
   \   00000000   0x2220             MOVS     R2,#+32
   \   00000002   0x....             LDR      R1,??DataTable7  ;; 0x40075000
   \   00000004   0x....             B.N      ?Subroutine2

   \                                 In section .text, align 2, keep-with-next
    108          {
    109            while (!SPI_TxCompl(SPI0));   /* wait until Tx buffer is empty */
   \                     ?Subroutine2: (+1)
   \   00000000   0x780B             LDRB     R3,[R1, #+0]
   \   00000002   0x4213             TST      R3,R2
   \   00000004   0xD0FC             BEQ      ?Subroutine2
    110            SPI_PutData(SPI0,txdata);     /* write an 8-bit data */
   \   00000006   0x7188             STRB     R0,[R1, #+6]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x71C8             STRB     R0,[R1, #+7]
   \   0000000C   0x2080             MOVS     R0,#+128
    111            while(!SPI_RxFull(SPI0));     /* wait until Rx buffer is full */
   \                     ??Subroutine2_0: (+1)
   \   0000000E   0x780A             LDRB     R2,[R1, #+0]
   \   00000010   0x4202             TST      R2,R0
   \   00000012   0xD0FC             BEQ      ??Subroutine2_0
    112            return (SPI_GetData(SPI0));   /* read data and exit */
   \   00000014   0x7988             LDRB     R0,[R1, #+6]
   \   00000016   0x79C9             LDRB     R1,[R1, #+7]
   \   00000018   0x4770             BX       LR               ;; return
    113          }
    114          

   \                                 In section .text, align 2, keep-with-next
    115          uint8 SPI1_TxRxByte(uint8 txdata)
   \                     SPI1_TxRxByte: (+1)
   \   00000000   0x2220             MOVS     R2,#+32
   \   00000002   0x....             LDR      R1,??DataTable6_1  ;; 0x40076000
   \   00000004                      REQUIRE ?Subroutine2
   \   00000004                      ;; // Fall through to label ?Subroutine2
    116          {
    117            while (!SPI_TxCompl(SPI1));   /* wait until Tx buffer is empty */
    118            SPI_PutData(SPI1,txdata);     /* write an 8-bit data */
    119            while(!SPI_RxFull(SPI1));     /* wait until Rx buffer is full */
    120            return (SPI_GetData(SPI1));   /* read data and exit */
    121          }
    122          
    123          /******************************************************************************
    124           * Communication via an SPI (Tx+Rx data packet) with driving a slave select   *
    125           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          void SPI0_CommWord(uint16 *txdata, uint16 txcnt,uint16 *rxdata, uint16 rxcnt)
    127          {
   \                     SPI0_CommWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x....             LDR      R0,??DataTable8
   \   0000000A   0x6840             LDR      R0,[R0, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??SPI0_CommWord_0
    128            register uint16 i;
    129          
    130            if (pCallbackSS0 != (SPI_SSCALLBACK)NULL) 
    131            {  
    132              pCallbackSS0 (SS_CLEAR);      /* SS=0 */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR      R1,??DataTable8
   \   00000014   0x6849             LDR      R1,[R1, #+4]
   \   00000016   0x4788             BLX      R1
    133            }
    134            if (txdata != NULL) {           /* any data for transmitting? */
   \                     ??SPI0_CommWord_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD013             BEQ      ??SPI0_CommWord_1
    135              for (i=0; i<txcnt; i++) {     /* writing cycle */
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD011             BEQ      ??SPI0_CommWord_1
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0x....             LDR      R2,??DataTable8_1  ;; 0x40075000
    136                SPI_TxRxWord(SPI0,*txdata);     /* Write an 16-bit data */
   \                     ??SPI0_CommWord_2: (+1)
   \   00000026   0x8823             LDRH     R3,[R4, #+0]
   \                     ??SPI0_CommWord_3: (+1)
   \   00000028   0x7817             LDRB     R7,[R2, #+0]
   \   0000002A   0x420F             TST      R7,R1
   \   0000002C   0xD0FC             BEQ      ??SPI0_CommWord_3
   \   0000002E   0x7193             STRB     R3,[R2, #+6]
   \   00000030   0x0A1B             LSRS     R3,R3,#+8
   \   00000032   0x71D3             STRB     R3,[R2, #+7]
   \                     ??SPI0_CommWord_4: (+1)
   \   00000034   0x7813             LDRB     R3,[R2, #+0]
   \   00000036   0x4203             TST      R3,R0
   \   00000038   0xD0FC             BEQ      ??SPI0_CommWord_4
   \   0000003A   0x7993             LDRB     R3,[R2, #+6]
   \   0000003C   0x79D3             LDRB     R3,[R2, #+7]
    137                txdata++;                   /* increment a source address */
   \   0000003E   0x1CA4             ADDS     R4,R4,#+2
    138              }
   \   00000040   0x1E6D             SUBS     R5,R5,#+1
   \   00000042   0xD1F0             BNE      ??SPI0_CommWord_2
    139            }
    140          
    141            if (rxdata != NULL) {           /* any data for receiving? */      
   \                     ??SPI0_CommWord_1: (+1)
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD01A             BEQ      ??SPI0_CommWord_5
    142              for (i=0; i<rxcnt; i++) {     /* reading cycle */
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x8800             LDRH     R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD016             BEQ      ??SPI0_CommWord_5
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x8803             LDRH     R3,[R0, #+0]
   \   00000054   0x24FF             MOVS     R4,#+255
   \   00000056   0x2080             MOVS     R0,#+128
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x....             LDR      R2,??DataTable8_1  ;; 0x40075000
   \                     ??SPI0_CommWord_6: (+1)
   \   0000005C   0x7815             LDRB     R5,[R2, #+0]
   \   0000005E   0x420D             TST      R5,R1
   \   00000060   0xD0FC             BEQ      ??SPI0_CommWord_6
   \   00000062   0x7194             STRB     R4,[R2, #+6]
   \   00000064   0x2500             MOVS     R5,#+0
   \   00000066   0x71D5             STRB     R5,[R2, #+7]
   \                     ??SPI0_CommWord_7: (+1)
   \   00000068   0x7815             LDRB     R5,[R2, #+0]
   \   0000006A   0x4205             TST      R5,R0
   \   0000006C   0xD0FC             BEQ      ??SPI0_CommWord_7
   \   0000006E   0x7995             LDRB     R5,[R2, #+6]
   \   00000070   0x79D7             LDRB     R7,[R2, #+7]
   \   00000072   0x023F             LSLS     R7,R7,#+8
   \   00000074   0x432F             ORRS     R7,R7,R5
   \   00000076   0x8037             STRH     R7,[R6, #+0]
    143                /* Read an 16-bit data with writing a dummy data to generate SCLK signal */
    144                *rxdata=SPI_TxRxWord(SPI0,0xFF);/* 0xFF is dummy data for writing! */   
    145                rxdata++;                   /* increment a destination address */
   \   00000078   0x1CB6             ADDS     R6,R6,#+2
    146              }
   \   0000007A   0x1E5B             SUBS     R3,R3,#+1
   \   0000007C   0xD1EE             BNE      ??SPI0_CommWord_6
    147            }
    148          
    149            if (pCallbackSS0 != (SPI_SSCALLBACK)NULL) 
   \                     ??SPI0_CommWord_5: (+1)
   \   0000007E   0x....             B.N      ?Subroutine3
    150            {  
    151              pCallbackSS0 (SS_SET);        /* SS=1 */
    152            }
    153          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR      R0,??DataTable8
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ      ??Subroutine3_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR      R1,??DataTable8
   \   0000000C   0x6849             LDR      R1,[R1, #+4]
   \   0000000E   0x4788             BLX      R1
   \                     ??Subroutine3_0: (+1)
   \   00000010   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    154          

   \                                 In section .text, align 2, keep-with-next
    155          void SPI0_CommByte(uint8 *txdata, uint16 txcnt,uint8 *rxdata, uint16 rxcnt)
    156          {
   \                     SPI0_CommByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x....             LDR      R0,??DataTable8
   \   0000000A   0x6840             LDR      R0,[R0, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??SPI0_CommByte_0
    157            register uint16 i;
    158          
    159            if (pCallbackSS0 != (SPI_SSCALLBACK)NULL) 
    160            {  
    161              pCallbackSS0 (SS_CLEAR);      /* SS=0 */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR      R1,??DataTable8
   \   00000014   0x6849             LDR      R1,[R1, #+4]
   \   00000016   0x4788             BLX      R1
    162            }
    163            if (txdata != NULL) {           /* any data for transmitting? */
   \                     ??SPI0_CommByte_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD013             BEQ      ??SPI0_CommByte_1
    164              for (i=0; i<txcnt; i++) {     /* writing cycle */
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD011             BEQ      ??SPI0_CommByte_1
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0x....             LDR      R2,??DataTable7  ;; 0x40075000
    165                SPI_TxRxByte(SPI0,*txdata);     /* Write an 8-bit data */
   \                     ??SPI0_CommByte_2: (+1)
   \   00000026   0x7823             LDRB     R3,[R4, #+0]
   \                     ??SPI0_CommByte_3: (+1)
   \   00000028   0x7817             LDRB     R7,[R2, #+0]
   \   0000002A   0x420F             TST      R7,R1
   \   0000002C   0xD0FC             BEQ      ??SPI0_CommByte_3
   \   0000002E   0x7193             STRB     R3,[R2, #+6]
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x71D3             STRB     R3,[R2, #+7]
   \                     ??SPI0_CommByte_4: (+1)
   \   00000034   0x7813             LDRB     R3,[R2, #+0]
   \   00000036   0x4203             TST      R3,R0
   \   00000038   0xD0FC             BEQ      ??SPI0_CommByte_4
   \   0000003A   0x7993             LDRB     R3,[R2, #+6]
   \   0000003C   0x79D3             LDRB     R3,[R2, #+7]
    166                txdata++;                   /* increment a source address */
   \   0000003E   0x1C64             ADDS     R4,R4,#+1
    167              }
   \   00000040   0x1E6D             SUBS     R5,R5,#+1
   \   00000042   0xD1F0             BNE      ??SPI0_CommByte_2
    168            }
    169          
    170            if (rxdata != NULL) {           /* any data for receiving? */      
   \                     ??SPI0_CommByte_1: (+1)
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD018             BEQ      ??SPI0_CommByte_5
    171              for (i=0; i<rxcnt; i++) {     /* reading cycle */
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x8800             LDRH     R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD014             BEQ      ??SPI0_CommByte_5
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x8803             LDRH     R3,[R0, #+0]
   \   00000054   0x24FF             MOVS     R4,#+255
   \   00000056   0x2080             MOVS     R0,#+128
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x....             LDR      R2,??DataTable7  ;; 0x40075000
   \                     ??SPI0_CommByte_6: (+1)
   \   0000005C   0x7815             LDRB     R5,[R2, #+0]
   \   0000005E   0x420D             TST      R5,R1
   \   00000060   0xD0FC             BEQ      ??SPI0_CommByte_6
   \   00000062   0x7194             STRB     R4,[R2, #+6]
   \   00000064   0x2500             MOVS     R5,#+0
   \   00000066   0x71D5             STRB     R5,[R2, #+7]
   \                     ??SPI0_CommByte_7: (+1)
   \   00000068   0x7815             LDRB     R5,[R2, #+0]
   \   0000006A   0x4205             TST      R5,R0
   \   0000006C   0xD0FC             BEQ      ??SPI0_CommByte_7
   \   0000006E   0x7995             LDRB     R5,[R2, #+6]
   \   00000070   0x79D7             LDRB     R7,[R2, #+7]
   \   00000072   0x7035             STRB     R5,[R6, #+0]
    172                /* Read an 8-bit data with writing a dummy data to generate SCLK signal */
    173                *rxdata=SPI_TxRxByte(SPI0,0xFF);/* 0xFF is dummy data for writing! */   
    174                rxdata++;                   /* increment a destination address */
   \   00000074   0x1C76             ADDS     R6,R6,#+1
    175              }
   \   00000076   0x1E5B             SUBS     R3,R3,#+1
   \   00000078   0xD1F0             BNE      ??SPI0_CommByte_6
    176            }
    177          
    178            if (pCallbackSS0 != (SPI_SSCALLBACK)NULL) 
   \                     ??SPI0_CommByte_5: (+1)
   \   0000007A                      REQUIRE ?Subroutine3
   \   0000007A                      ;; // Fall through to label ?Subroutine3
    179            {  
    180              pCallbackSS0 (SS_SET);        /* SS=1 */
    181            }
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void SPI1_CommWord(uint16 *txdata, uint16 txcnt,uint16 *rxdata, uint16 rxcnt)
    185          {
   \                     SPI1_CommWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001F             MOVS     R7,R3
   \   0000000A   0x....             LDR      R0,??DataTable5_5
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ      ??SPI1_CommWord_0
    186            register uint16 i;
    187          
    188            if (pCallbackSS1 != (SPI_SSCALLBACK)NULL) 
    189            {  
    190              pCallbackSS1 (SS_CLEAR);      /* SS=0 */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR      R1,??DataTable5_5
   \   00000016   0x6849             LDR      R1,[R1, #+4]
   \   00000018   0x4788             BLX      R1
    191            }
    192          
    193            if (txdata != NULL) {           /* any data for transmitting? */
   \                     ??SPI1_CommWord_0: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD007             BEQ      ??SPI1_CommWord_1
    194              for (i=0; i<txcnt; i++) {     /* writing cycle */
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD005             BEQ      ??SPI1_CommWord_1
    195                SPI_TxRxWord(SPI1,*txdata);     /* Write an 16-bit data */
   \                     ??SPI1_CommWord_2: (+1)
   \   00000022   0x8820             LDRH     R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       SPI1_TxRxWord
    196                txdata++;                   /* increment a source address */
   \   00000028   0x1CA4             ADDS     R4,R4,#+2
    197              }
   \   0000002A   0x1E76             SUBS     R6,R6,#+1
   \   0000002C   0xD1F9             BNE      ??SPI1_CommWord_2
    198            }
    199            
    200            if (rxdata != NULL) {           /* any data for receiving? */      
   \                     ??SPI1_CommWord_1: (+1)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD016             BEQ      ??SPI1_CommWord_3
    201              for (i=0; i<rxcnt; i++) {     /* reading cycle */
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD014             BEQ      ??SPI1_CommWord_3
   \   00000036   0x2080             MOVS     R0,#+128
   \   00000038   0x21FF             MOVS     R1,#+255
   \   0000003A   0x2220             MOVS     R2,#+32
   \   0000003C   0x....             LDR      R3,??DataTable8_2  ;; 0x40076000
   \                     ??SPI1_CommWord_4: (+1)
   \   0000003E   0x781C             LDRB     R4,[R3, #+0]
   \   00000040   0x4214             TST      R4,R2
   \   00000042   0xD0FC             BEQ      ??SPI1_CommWord_4
   \   00000044   0x7199             STRB     R1,[R3, #+6]
   \   00000046   0x2400             MOVS     R4,#+0
   \   00000048   0x71DC             STRB     R4,[R3, #+7]
   \                     ??SPI1_CommWord_5: (+1)
   \   0000004A   0x781C             LDRB     R4,[R3, #+0]
   \   0000004C   0x4204             TST      R4,R0
   \   0000004E   0xD0FC             BEQ      ??SPI1_CommWord_5
   \   00000050   0x799C             LDRB     R4,[R3, #+6]
   \   00000052   0x79DE             LDRB     R6,[R3, #+7]
   \   00000054   0x0236             LSLS     R6,R6,#+8
   \   00000056   0x4326             ORRS     R6,R6,R4
   \   00000058   0x802E             STRH     R6,[R5, #+0]
    202                /* Read an 16-bit data with writing a dummy data to generate SCLK signal */
    203                *rxdata=SPI_TxRxWord(SPI1,0xFF);/* 0xFF is dummy data for writing! */   
    204                rxdata++;                   /* increment a destination address */
   \   0000005A   0x1CAD             ADDS     R5,R5,#+2
    205              }
   \   0000005C   0x1E7F             SUBS     R7,R7,#+1
   \   0000005E   0xD1EE             BNE      ??SPI1_CommWord_4
    206            }
    207          
    208            if (pCallbackSS1 != (SPI_SSCALLBACK)NULL) 
   \                     ??SPI1_CommWord_3: (+1)
   \   00000060   0x....             B.N      ?Subroutine4
    209            {  
    210              pCallbackSS1 (SS_SET);        /* SS=1 */
    211            }
    212          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x....             LDR      R0,??DataTable8_3
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ      ??Subroutine4_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR      R1,??DataTable8_3
   \   0000000C   0x6849             LDR      R1,[R1, #+4]
   \   0000000E   0x4788             BLX      R1
   \                     ??Subroutine4_0: (+1)
   \   00000010   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    213          

   \                                 In section .text, align 2, keep-with-next
    214          void SPI1_CommByte(uint8 *txdata, uint16 txcnt,uint8 *rxdata, uint16 rxcnt)
    215          {
   \                     SPI1_CommByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x....             LDR      R0,??DataTable8_3
   \   0000000A   0x6840             LDR      R0,[R0, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??SPI1_CommByte_0
    216            register uint16 i;
    217          
    218            if (pCallbackSS1 != (SPI_SSCALLBACK)NULL) 
    219            {  
    220              pCallbackSS1 (SS_CLEAR);      /* SS=0 */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR      R1,??DataTable8_3
   \   00000014   0x6849             LDR      R1,[R1, #+4]
   \   00000016   0x4788             BLX      R1
    221            }
    222          
    223            if (txdata != NULL) {           /* any data for transmitting? */
   \                     ??SPI1_CommByte_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD013             BEQ      ??SPI1_CommByte_1
    224              for (i=0; i<txcnt; i++) {     /* writing cycle */
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD011             BEQ      ??SPI1_CommByte_1
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0x....             LDR      R2,??DataTable6_1  ;; 0x40076000
    225                SPI_TxRxByte(SPI1,*txdata);     /* Write an 8-bit data */
   \                     ??SPI1_CommByte_2: (+1)
   \   00000026   0x7823             LDRB     R3,[R4, #+0]
   \                     ??SPI1_CommByte_3: (+1)
   \   00000028   0x7817             LDRB     R7,[R2, #+0]
   \   0000002A   0x420F             TST      R7,R1
   \   0000002C   0xD0FC             BEQ      ??SPI1_CommByte_3
   \   0000002E   0x7193             STRB     R3,[R2, #+6]
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x71D3             STRB     R3,[R2, #+7]
   \                     ??SPI1_CommByte_4: (+1)
   \   00000034   0x7813             LDRB     R3,[R2, #+0]
   \   00000036   0x4203             TST      R3,R0
   \   00000038   0xD0FC             BEQ      ??SPI1_CommByte_4
   \   0000003A   0x7993             LDRB     R3,[R2, #+6]
   \   0000003C   0x79D3             LDRB     R3,[R2, #+7]
    226                txdata++;                   /* increment a source address */
   \   0000003E   0x1C64             ADDS     R4,R4,#+1
    227              }
   \   00000040   0x1E6D             SUBS     R5,R5,#+1
   \   00000042   0xD1F0             BNE      ??SPI1_CommByte_2
    228            }
    229            
    230            if (rxdata != NULL) {           /* any data for receiving? */      
   \                     ??SPI1_CommByte_1: (+1)
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD018             BEQ      ??SPI1_CommByte_5
    231              for (i=0; i<rxcnt; i++) {     /* reading cycle */
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x8800             LDRH     R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD014             BEQ      ??SPI1_CommByte_5
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x8803             LDRH     R3,[R0, #+0]
   \   00000054   0x24FF             MOVS     R4,#+255
   \   00000056   0x2080             MOVS     R0,#+128
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x....             LDR      R2,??DataTable6_1  ;; 0x40076000
   \                     ??SPI1_CommByte_6: (+1)
   \   0000005C   0x7815             LDRB     R5,[R2, #+0]
   \   0000005E   0x420D             TST      R5,R1
   \   00000060   0xD0FC             BEQ      ??SPI1_CommByte_6
   \   00000062   0x7194             STRB     R4,[R2, #+6]
   \   00000064   0x2500             MOVS     R5,#+0
   \   00000066   0x71D5             STRB     R5,[R2, #+7]
   \                     ??SPI1_CommByte_7: (+1)
   \   00000068   0x7815             LDRB     R5,[R2, #+0]
   \   0000006A   0x4205             TST      R5,R0
   \   0000006C   0xD0FC             BEQ      ??SPI1_CommByte_7
   \   0000006E   0x7995             LDRB     R5,[R2, #+6]
   \   00000070   0x79D7             LDRB     R7,[R2, #+7]
   \   00000072   0x7035             STRB     R5,[R6, #+0]
    232                /* Read an 8-bit data with writing a dummy data to generate SCLK signal */
    233                *rxdata=SPI_TxRxByte(SPI1,0xFF);/* 0xFF is dummy data for writing! */   
    234                rxdata++;                   /* increment a destination address */
   \   00000074   0x1C76             ADDS     R6,R6,#+1
    235              }
   \   00000076   0x1E5B             SUBS     R3,R3,#+1
   \   00000078   0xD1F0             BNE      ??SPI1_CommByte_6
    236            }
    237            
    238            if (pCallbackSS1 != (SPI_SSCALLBACK)NULL) 
   \                     ??SPI1_CommByte_5: (+1)
   \   0000007A                      REQUIRE ?Subroutine4
   \   0000007A                      ;; // Fall through to label ?Subroutine4
    239            {  
    240              pCallbackSS1 (SS_SET);        /* SS=1 */
    241            }
    242          }
    243          
    244          /******************************************************************************
    245           * interrupt function definitions                                             *
    246           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    247          void spi0_isr (void)
    248          {
   \                     spi0_isr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    249            register uint8 tmp;
    250          
    251            if (pCallbackSPI0 != (SPI_CALLBACK)NULL) 
   \   00000002   0x....             LDR      R6,??DataTable8
   \   00000004   0x6830             LDR      R0,[R6, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD021             BEQ      ??spi0_isr_0
    252            {  
    253          
    254              tmp = SPI0_S & (SPI_S_SPRF_MASK|SPI_S_SPTEF_MASK|SPI_S_SPMF_MASK|
    255                              SPI_S_MODF_MASK);
   \   0000000A   0x....             LDR      R0,??DataTable7  ;; 0x40075000
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x24F0             MOVS     R4,#+240
   \   00000010   0x4004             ANDS     R4,R4,R0
    256              
    257              /* Rx buffer or FIFO buffer is full */
    258              if(tmp & (SPI_S_SPRF_MASK)) 
   \   00000012   0x0620             LSLS     R0,R4,#+24
   \   00000014   0xD503             BPL      ??spi0_isr_1
    259                {pCallbackSPI0 (SPI0_CALLBACK,RXSPI_CALLBACK);}
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x6832             LDR      R2,[R6, #+0]
   \   0000001C   0x4790             BLX      R2
    260              /* SPRF is cleared by reading data registers DH:DL */
    261              
    262              /* Tx buffer or FIFO buffer is empty */
    263              if(tmp & (SPI_S_SPTEF_MASK))
   \                     ??spi0_isr_1: (+1)
   \   0000001E   0x06A0             LSLS     R0,R4,#+26
   \   00000020   0xD503             BPL      ??spi0_isr_2
    264                {pCallbackSPI0 (SPI0_CALLBACK,TXSPI_CALLBACK);}
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x6832             LDR      R2,[R6, #+0]
   \   00000028   0x4790             BLX      R2
    265              /* SPTEF is cleared by writing a value to DH:DL */
    266              
    267              /* Receive data buffer matches the value in MH:ML registers */
    268              if(tmp & (SPI_S_SPMF_MASK))
   \                     ??spi0_isr_2: (+1)
   \   0000002A   0x2540             MOVS     R5,#+64
   \   0000002C   0x422C             TST      R4,R5
   \   0000002E   0xD005             BEQ      ??spi0_isr_3
    269                {pCallbackSPI0 (SPI0_CALLBACK,MATCH_CALLBACK);
   \   00000030   0x2103             MOVS     R1,#+3
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x6832             LDR      R2,[R6, #+0]
   \   00000036   0x4790             BLX      R2
    270                iosetb (SPI0_S,SPI_S_SPMF_MASK); /* clear SPMF flag */ }
   \   00000038   0x....             LDR      R0,??DataTable8_4  ;; 0x48075000
   \   0000003A   0x7005             STRB     R5,[R0, #+0]
    271              
    272              /* Mode fault error detected (Only for MSTR=1, MODFEN=1, SSOE=0) */
    273              if(tmp & (SPI_S_MODF_MASK)) 
   \                     ??spi0_isr_3: (+1)
   \   0000003C   0x2510             MOVS     R5,#+16
   \   0000003E   0x402C             ANDS     R4,R4,R5
   \   00000040   0xD005             BEQ      ??spi0_isr_0
    274                {pCallbackSPI0 (SPI0_CALLBACK,FAULT_CALLBACK);
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x6832             LDR      R2,[R6, #+0]
   \   00000048   0x4790             BLX      R2
    275                iosetb (SPI0_S,SPI_S_MODF_MASK); /* clear MODF flag */ }
   \   0000004A   0x....             LDR      R0,??DataTable8_4  ;; 0x48075000
   \   0000004C   0x7005             STRB     R5,[R0, #+0]
    276            }
    277          }
   \                     ??spi0_isr_0: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    278          

   \                                 In section .text, align 2, keep-with-next
    279          void spi1_isr (void)
    280          {
   \                     spi1_isr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    281            register uint8 tmp;
    282          
    283            if (pCallbackSPI1 != (SPI_CALLBACK)NULL) 
   \   00000002   0x....             LDR      R6,??DataTable8_3
   \   00000004   0x6830             LDR      R0,[R6, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD021             BEQ      ??spi1_isr_0
    284            {  
    285          
    286              tmp = SPI1_S & (SPI_S_SPRF_MASK|SPI_S_SPTEF_MASK|SPI_S_SPMF_MASK|
    287                              SPI_S_MODF_MASK);
   \   0000000A   0x....             LDR      R0,??DataTable8_2  ;; 0x40076000
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x24F0             MOVS     R4,#+240
   \   00000010   0x4004             ANDS     R4,R4,R0
    288              
    289              /* Rx buffer or FIFO buffer is full */
    290              if(tmp & (SPI_S_SPRF_MASK)) 
   \   00000012   0x0620             LSLS     R0,R4,#+24
   \   00000014   0xD503             BPL      ??spi1_isr_1
    291                {pCallbackSPI1 (SPI1_CALLBACK,RXSPI_CALLBACK);}
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x6832             LDR      R2,[R6, #+0]
   \   0000001C   0x4790             BLX      R2
    292              /* SPRF is cleared by reading data registers DH:DL */
    293              
    294              /* Tx buffer or FIFO buffer is empty */
    295              if(tmp & (SPI_S_SPTEF_MASK))
   \                     ??spi1_isr_1: (+1)
   \   0000001E   0x06A0             LSLS     R0,R4,#+26
   \   00000020   0xD503             BPL      ??spi1_isr_2
    296                {pCallbackSPI1 (SPI1_CALLBACK,TXSPI_CALLBACK);}
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x6832             LDR      R2,[R6, #+0]
   \   00000028   0x4790             BLX      R2
    297              /* SPTEF is cleared by writing a value to DH:DL */
    298              
    299              /* Receive data buffer matches the value in MH:ML registers */
    300              if(tmp & (SPI_S_SPMF_MASK))
   \                     ??spi1_isr_2: (+1)
   \   0000002A   0x2540             MOVS     R5,#+64
   \   0000002C   0x422C             TST      R4,R5
   \   0000002E   0xD005             BEQ      ??spi1_isr_3
    301                {pCallbackSPI1 (SPI1_CALLBACK,MATCH_CALLBACK);
   \   00000030   0x2103             MOVS     R1,#+3
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x6832             LDR      R2,[R6, #+0]
   \   00000036   0x4790             BLX      R2
    302                iosetb (SPI1_S,SPI_S_SPMF_MASK); /* clear SPMF flag */ }
   \   00000038   0x....             LDR      R0,??DataTable8_5  ;; 0x48076000
   \   0000003A   0x7005             STRB     R5,[R0, #+0]
    303              
    304              /* Mode fault error detected (Only for MSTR=1, MODFEN=1, SSOE=0) */
    305              if(tmp & (SPI_S_MODF_MASK)) 
   \                     ??spi1_isr_3: (+1)
   \   0000003C   0x2510             MOVS     R5,#+16
   \   0000003E   0x402C             ANDS     R4,R4,R5
   \   00000040   0xD005             BEQ      ??spi1_isr_0
    306                {pCallbackSPI1 (SPI1_CALLBACK,FAULT_CALLBACK);
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x6832             LDR      R2,[R6, #+0]
   \   00000048   0x4790             BLX      R2
    307                iosetb (SPI1_S,SPI_S_MODF_MASK); /* clear MODF flag */ }
   \   0000004A   0x....             LDR      R0,??DataTable8_5  ;; 0x48076000
   \   0000004C   0x7005             STRB     R5,[R0, #+0]
    308            }
    309          }
   \                     ??spi1_isr_0: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     pCallbackSPI0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0xE000E404         DC32     0xe000e404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40075001         DC32     0x40075001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     pCallbackSPI1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40076001         DC32     0x40076001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40076000         DC32     0x40076000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40075000         DC32     0x40075000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     pCallbackSPI0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x40075000         DC32     0x40075000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40076000         DC32     0x40076000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     pCallbackSPI1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x48075000         DC32     0x48075000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x48076000         DC32     0x48076000
    310          
    311          /******************************************************************************
    312           * End of module                                                              *
    313           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SPI0_CommByte
        24   -- Indirect call
      24   SPI0_CommWord
        24   -- Indirect call
      16   SPI0_Init
        16   -- Indirect call
       0   SPI0_TxRxByte
       0   SPI0_TxRxWord
      24   SPI1_CommByte
        24   -- Indirect call
      24   SPI1_CommWord
        24   -- Indirect call
        24   -> SPI1_TxRxWord
      16   SPI1_Init
        16   -- Indirect call
       0   SPI1_TxRxByte
       0   SPI1_TxRxWord
      16   spi0_isr
        16   -- Indirect call
      16   spi1_isr
        16   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
      28  ?Subroutine0
      30  ?Subroutine1
      26  ?Subroutine2
      18  ?Subroutine3
      18  ?Subroutine4
     122  SPI0_CommByte
     128  SPI0_CommWord
      72  SPI0_Init
       6  SPI0_TxRxByte
       6  SPI0_TxRxWord
     122  SPI1_CommByte
      98  SPI1_CommWord
      76  SPI1_Init
       4  SPI1_TxRxByte
       4  SPI1_TxRxWord
       8  pCallbackSPI0
          pCallbackSS0
       8  pCallbackSPI1
          pCallbackSS1
      80  spi0_isr
      80  spi1_isr

 
  16 bytes in section .bss
 978 bytes in section .text
 
 978 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
