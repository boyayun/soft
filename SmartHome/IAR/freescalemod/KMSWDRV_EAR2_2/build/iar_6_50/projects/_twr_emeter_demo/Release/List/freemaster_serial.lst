###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        30/Jan/2016  15:22:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_serial.c
#    Command line =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_serial.c
#        -D NDEBUG -lCN
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\
#        -o
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\
#        --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\common\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\drivers\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\freemaster\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\projects\_twr_emeter_demo\
#        -Oh --require_prototypes
#    List file    =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\freemaster_serial.lst
#    Object file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\freemaster_serial.o
#
###############################################################################

E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_serial.c
      1          /******************************************************************************
      2          *
      3          * Freescale Semiconductor Inc.
      4          * (c) Copyright 2004-2010 Freescale Semiconductor
      5          * ALL RIGHTS RESERVED.
      6          *
      7          ****************************************************************************//*!
      8          *
      9          * @file   freemaster_serial.c
     10          *
     11          * @brief  FreeMASTER SCI communication routines
     12          *
     13          * @version 1.1.1.0
     14          * 
     15          * @date May-4-2012
     16          * 
     17          *******************************************************************************/
     18          
     19          #include "freemaster.h"
     20          #include "freemaster_private.h"
     21          #include "freemaster_protocol.h"
     22          
     23          #if FMSTR_USE_SCI || FMSTR_USE_JTAG
     24          
     25          /***********************************
     26          *  local variables 
     27          ***********************************/
     28          
     29          /* FreeMASTER communication buffer (in/out) plus the STS and LEN bytes */

   \                                 In section .bss, align 4
     30          static FMSTR_BCHR pcm_pCommBuffer[FMSTR_COMM_BUFFER_SIZE+3];    
     31          
     32          /* FreeMASTER runtime flags */
     33          /*lint -e{960} using union */
     34          typedef volatile union 
     35          {
     36              FMSTR_FLAGS all;
     37              
     38              struct
     39              {
     40                  unsigned bTxActive : 1;         /* response is being transmitted */
     41                  unsigned bTxWaitTC : 1;         /* response sent, wait for transmission complete */
     42                  unsigned bTxLastCharSOB : 1;    /* last transmitted char was equal to SOB  */
     43                  unsigned bRxLastCharSOB : 1;    /* last received character was SOB */
     44                  unsigned bRxMsgLengthNext : 1;  /* expect the length byte next time */
     45                  unsigned bJtagRIEPending : 1;   /* JTAG RIE bit failed to be set, try again later */
     46              } flg;
     47              
     48          } FMSTR_SERIAL_FLAGS;
     49          
     50          static FMSTR_SERIAL_FLAGS pcm_wFlags;
     51          
     52          /* receive and transmit buffers and counters */
     53          static FMSTR_SIZE8 pcm_nTxTodo;     /* transmission to-do counter (0 when tx is idle) */
     54          static FMSTR_SIZE8 pcm_nRxTodo;     /* reception to-do counter (0 when rx is idle) */
     55          static FMSTR_BPTR  pcm_pTxBuff;     /* pointer to next byte to transmit */
     56          static FMSTR_BPTR  pcm_pRxBuff;     /* pointer to next free place in RX buffer */
     57          static FMSTR_BCHR  pcm_nRxCheckSum; /* checksum of data being received */
   \                     pcm_nRxCheckSum:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 64
   \   00000044                      DS8 4

   \                                 In section .bss, align 4
   \                     pcm_nTxTodo:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 4
   \   00000008                      DS8 4
     58          
     59          /* SHORT_INTR receive queue (circular buffer) */
     60          #if FMSTR_SHORT_INTR
     61          static FMSTR_BCHR  pcm_pRQueueBuffer[FMSTR_COMM_RQUEUE_SIZE];
     62          static FMSTR_BPTR  pcm_pRQueueRP;   /* SHORT_INTR queue read-pointer */
     63          static FMSTR_BPTR  pcm_pRQueueWP;   /* SHORT_INTR queue write-pointer */
     64          #endif
     65          
     66          #if FMSTR_USE_JTAG
     67          static FMSTR_U32 pcm_wJtagTxData;   /* four bytes buffer to be sent over JTAG (LSB first) */
     68          static FMSTR_SIZE8 pcm_wJtagTxCtr;  /* counter of bytes in pcm_wJtagTxData */
     69          #endif
     70          
     71          /***********************************
     72          *  local function prototypes
     73          ***********************************/
     74          
     75          static void FMSTR_Listen(void);
     76          static void FMSTR_SendError(FMSTR_BCHR nErrCode);
     77          static void FMSTR_Tx(void);
     78          static void FMSTR_Rx(FMSTR_BCHR nRxChar);
     79          static void FMSTR_RxQueue(FMSTR_BCHR nRxChar);
     80          static void FMSTR_RxDequeue(void);
     81          
     82          /*lint -esym(752,FMSTR_RxQueue) this may be unreferenced in some cases */
     83          /*lint -esym(752,FMSTR_RxDequeue) this may be unreferenced in some cases */
     84          
     85          /**************************************************************************//*!
     86          *
     87          * @brief    Serial communication initialization
     88          *
     89          ******************************************************************************/
     90          

   \                                 In section .text, align 2, keep-with-next
     91          void FMSTR_InitSerial(void)
     92          {   
     93              /* initialize all state variables */
     94              pcm_wFlags.all = 0U;
   \                     FMSTR_InitSerial: (+1)
   \   00000000   0x....             LDR      R0,??DataTable4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7101             STRB     R1,[R0, #+4]
     95              pcm_nTxTodo = 0U;
   \   00000006   0x7001             STRB     R1,[R0, #+0]
     96          
     97              
     98          #if FMSTR_USE_SCI && FMSTR_SCI_TWOWIRE_ONLY
     99              /* to enable TX and RX together in FreeMASTER initialization */
    100              FMSTR_SCI_TE_RE();
    101          #endif
    102              
    103          #if FMSTR_SHORT_INTR
    104              pcm_pRQueueRP = pcm_pRQueueBuffer;
    105              pcm_pRQueueWP = pcm_pRQueueBuffer;
    106          #endif
    107          
    108              /* start listening for commands */
    109              FMSTR_Listen();
   \   00000008   0x....             B.N      ?Subroutine0
    110          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x7041             STRB     R1,[R0, #+1]
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x4391             BICS     R1,R1,R2
   \   00000008   0x6041             STR      R1,[R0, #+4]
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0x4391             BICS     R1,R1,R2
   \   00000010   0x6041             STR      R1,[R0, #+4]
   \   00000012   0x....             LDR      R0,??DataTable4_1  ;; 0x4006b003
   \   00000014   0x7801             LDRB     R1,[R0, #+0]
   \   00000016   0x22F7             MOVS     R2,#+247
   \   00000018   0x400A             ANDS     R2,R2,R1
   \   0000001A   0x7002             STRB     R2,[R0, #+0]
   \   0000001C   0x7801             LDRB     R1,[R0, #+0]
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0x430A             ORRS     R2,R2,R1
   \   00000022   0x7002             STRB     R2,[R0, #+0]
   \   00000024   0x7801             LDRB     R1,[R0, #+0]
   \   00000026   0x0649             LSLS     R1,R1,#+25
   \   00000028   0x0E49             LSRS     R1,R1,#+25
   \   0000002A   0x7001             STRB     R1,[R0, #+0]
   \   0000002C   0x7801             LDRB     R1,[R0, #+0]
   \   0000002E   0x2220             MOVS     R2,#+32
   \   00000030   0x430A             ORRS     R2,R2,R1
   \   00000032   0x7002             STRB     R2,[R0, #+0]
   \   00000034   0x4770             BX       LR               ;; return
    111          
    112          /**************************************************************************//*!
    113          *
    114          * @brief    Start listening on a serial line
    115          *
    116          * Reset the receiver machine and start listening on a serial line
    117          *
    118          ******************************************************************************/
    119          

   \                                 In section .text, align 2, keep-with-next
    120          static void FMSTR_Listen(void)
    121          {
    122              pcm_nRxTodo = 0U;
   \                     FMSTR_Listen: (+1)
   \   00000000   0x....             LDR      R0,??DataTable4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004                      REQUIRE ?Subroutine0
   \   00000004                      ;; // Fall through to label ?Subroutine0
    123          
    124              /* disable transmitter state machine */
    125              pcm_wFlags.flg.bTxActive = 0U;
    126              pcm_wFlags.flg.bTxWaitTC = 0U;
    127          
    128              /* disable transmitter, enable receiver (enables single-wire connection) */
    129          #if FMSTR_USE_SCI && !FMSTR_SCI_TWOWIRE_ONLY
    130              FMSTR_SCI_TD();
    131              FMSTR_SCI_RE();
    132          #endif
    133          
    134              /* disable transmit, enable receive interrupts */
    135          #if FMSTR_SHORT_INTR || FMSTR_LONG_INTR
    136          #if FMSTR_USE_SCI
    137              FMSTR_SCI_DTXI();   /* disable SCI transmit interrupt */
    138              FMSTR_SCI_ERXI();   /* enable SCI recieve interrupt */
    139              
    140          #elif FMSTR_USE_JTAG
    141              FMSTR_JTAG_DTXI();  /* disable JTAG transmit interrupt  */
    142              FMSTR_JTAG_ERXI();  /* enable JTAG recieve interrupt  */
    143          
    144              /* RIE bit is forced low by HW until EONCE is first accesed, we will try again in FMSTR_Poll */
    145              if(!FMSTR_JTAG_ERXI_CHECK())
    146                  pcm_wFlags.flg.bJtagRIEPending = 1;
    147                  
    148          #endif
    149          #endif  
    150          }
    151          
    152          /**************************************************************************//*!
    153          *
    154          * @brief    Send response of given error code (no data) 
    155          *
    156          * @param    nErrCode - error code to be sent
    157          *
    158          ******************************************************************************/
    159          
    160          static void FMSTR_SendError(FMSTR_BCHR nErrCode)
    161          {
    162              /* fill & send single-byte response */
    163              *pcm_pCommBuffer = nErrCode;
    164              FMSTR_SendResponse(pcm_pCommBuffer, 1U);
    165          }
    166          
    167          /**************************************************************************//*!
    168          *
    169          * @brief    Finalize transmit buffer before transmitting 
    170          *
    171          * @param    nLength - response length (1 for status + data length)
    172          *
    173          *
    174          * This Function takes the data already prepared in the transmit buffer 
    175          * (inlcuding the status byte). It computes the check sum and kicks on tx.
    176          *
    177          ******************************************************************************/
    178          

   \                                 In section .text, align 2, keep-with-next
    179          void FMSTR_SendResponse(FMSTR_BPTR pResponse, FMSTR_SIZE8 nLength)
    180          {
   \                     FMSTR_SendResponse: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0xB082             SUB      SP,SP,#+8
    181              FMSTR_U16 chSum = 0U;
   \   00000004   0x2300             MOVS     R3,#+0
    182              FMSTR_U8 i, c;
    183          
    184              /* remeber the buffer to be sent */
    185              pcm_pTxBuff = pResponse;
   \   00000006   0x....             LDR      R2,??DataTable4
   \   00000008   0x6090             STR      R0,[R2, #+8]
    186              
    187              /* status byte and data are already there, compute checksum only     */
    188              for (i=0U; i<nLength; i++)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD006             BEQ      ??FMSTR_SendResponse_0
   \   0000000E   0x000C             MOVS     R4,R1
    189              {
    190                  c = 0U;
    191                  pResponse = FMSTR_ValueFromBuffer8(&c, pResponse);
   \                     ??FMSTR_SendResponse_1: (+1)
   \   00000010   0x7805             LDRB     R5,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
    192                  /* add character to checksum */
    193                  chSum += c;
    194                  /* prevent saturation to happen on DSP platforms */
    195                  chSum &= 0xffU;
   \   00000014   0x195B             ADDS     R3,R3,R5
   \   00000016   0xB2DB             UXTB     R3,R3
    196              }
   \   00000018   0x1E64             SUBS     R4,R4,#+1
   \   0000001A   0xD1F9             BNE      ??FMSTR_SendResponse_1
    197              
    198              /* store checksum after the message */
    199              pResponse = FMSTR_ValueToBuffer8(pResponse, (FMSTR_U8) (((FMSTR_U16)~(chSum)) + 1U));
   \                     ??FMSTR_SendResponse_0: (+1)
   \   0000001C   0x43DC             MVNS     R4,R3
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \   00000020   0x7004             STRB     R4,[R0, #+0]
    200          
    201              /* send the message and the checksum and the SOB */
    202              pcm_nTxTodo = (FMSTR_SIZE8) (nLength + 1U); 
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \   00000024   0x7011             STRB     R1,[R2, #+0]
    203              
    204              /* now transmitting the response */
    205              pcm_wFlags.flg.bTxActive = 1U;
   \   00000026   0x6850             LDR      R0,[R2, #+4]
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x6051             STR      R1,[R2, #+4]
    206              pcm_wFlags.flg.bTxWaitTC = 0U;
   \   0000002E   0x6850             LDR      R0,[R2, #+4]
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x4388             BICS     R0,R0,R1
   \   00000034   0x6050             STR      R0,[R2, #+4]
    207          
    208              /* do not replicate the initial SOB  */
    209              pcm_wFlags.flg.bTxLastCharSOB = 0U;
   \   00000036   0x6850             LDR      R0,[R2, #+4]
   \   00000038   0x2104             MOVS     R1,#+4
   \   0000003A   0x4388             BICS     R0,R0,R1
   \   0000003C   0x6050             STR      R0,[R2, #+4]
    210              
    211          #if FMSTR_USE_SCI       
    212              {
    213                  /*lint -esym(550, dummySR) */        
    214                  volatile FMSTR_SCISR dummySR;
    215          
    216                  /* disable receiver, enable transmitter (single-wire communication) */
    217          #if !FMSTR_SCI_TWOWIRE_ONLY
    218                  FMSTR_SCI_RD();
   \   0000003E   0x....             LDR      R0,??DataTable4_1  ;; 0x4006b003
   \   00000040   0x7801             LDRB     R1,[R0, #+0]
   \   00000042   0x22FB             MOVS     R2,#+251
   \   00000044   0x400A             ANDS     R2,R2,R1
   \   00000046   0x7002             STRB     R2,[R0, #+0]
    219                  FMSTR_SCI_TE();
   \   00000048   0x7801             LDRB     R1,[R0, #+0]
   \   0000004A   0x2208             MOVS     R2,#+8
   \   0000004C   0x430A             ORRS     R2,R2,R1
   \   0000004E   0x7002             STRB     R2,[R0, #+0]
    220          #endif        
    221                  /* kick on the SCI transmission (also clears TX Empty flag on some platforms) */
    222                  dummySR = FMSTR_SCI_GETSR();
   \   00000050   0x7841             LDRB     R1,[R0, #+1]
   \   00000052   0x466A             MOV      R2,SP
   \   00000054   0x7011             STRB     R1,[R2, #+0]
    223                  FMSTR_SCI_PUTCHAR(FMSTR_SOB);
   \   00000056   0x212B             MOVS     R1,#+43
   \   00000058   0x7101             STRB     R1,[R0, #+4]
    224              }
    225              
    226          #elif FMSTR_USE_JTAG
    227              /* kick on the JTAG transmission */
    228              pcm_wJtagTxData = FMSTR_SOB;
    229              pcm_wJtagTxCtr = 1U;
    230              
    231              /* send the next two bytes immediatelly (we can be sure there are two bytes) */
    232              FMSTR_Tx();
    233              FMSTR_Tx();
    234              
    235              /* send the third byte (if any) or flush the 32bit JTAG word */
    236              FMSTR_Tx();
    237                  
    238          #endif
    239          
    240              /* TX interrupt enable, RX interrupt disable */
    241          #if FMSTR_LONG_INTR || FMSTR_SHORT_INTR
    242          #if FMSTR_USE_SCI       
    243              FMSTR_SCI_DRXI();
   \   0000005A   0x7801             LDRB     R1,[R0, #+0]
   \   0000005C   0x22DF             MOVS     R2,#+223
   \   0000005E   0x400A             ANDS     R2,R2,R1
   \   00000060   0x7002             STRB     R2,[R0, #+0]
    244              FMSTR_SCI_ETXI();
   \   00000062   0x7801             LDRB     R1,[R0, #+0]
   \   00000064   0x2280             MOVS     R2,#+128
   \   00000066   0x430A             ORRS     R2,R2,R1
   \   00000068   0x7002             STRB     R2,[R0, #+0]
    245              
    246          #elif FMSTR_USE_JTAG
    247          #if FMSTR_USE_JTAG_TXFIX
    248              /* in TX-bugfix mode, keep the RX interrupt enabled as it */
    249              /* is used as "able-to-TX" notification from the PC */
    250              FMSTR_JTAG_ERXI();
    251          #else
    252              /* otherwise, JTAG is very same as the SCI */
    253              FMSTR_JTAG_DRXI();
    254              FMSTR_JTAG_ETXI();
    255          #endif              
    256          
    257          #endif
    258          #endif      
    259          }
   \   0000006A   0xBC33             POP      {R0,R1,R4,R5}
   \   0000006C   0x4770             BX       LR               ;; return
    260          
    261          /**************************************************************************//*!
    262          *
    263          * @brief    Output buffer transmission
    264          *
    265          * This function sends one character of the transmit buffer. It handles 
    266          * replicating of the SOB characted inside the message body.
    267          *
    268          ******************************************************************************/
    269          
    270          static void FMSTR_Tx(void)
    271          {
    272              FMSTR_U8 ch = 0U;
    273              
    274              if (pcm_nTxTodo)
    275              {
    276                  /* fetch & send character ready to transmit */
    277                  /*lint -e{534} ignoring return value */
    278                  FMSTR_ValueFromBuffer8(&ch, pcm_pTxBuff);
    279                  
    280          #if FMSTR_USE_SCI       
    281                  /* just put the byte into the SCI transmit buffer */
    282                  FMSTR_SCI_PUTCHAR((FMSTR_U8) ch);
    283                  
    284          #elif FMSTR_USE_JTAG
    285                  /* put byte to 32bit JTAG buffer */
    286                  pcm_wJtagTxData = (pcm_wJtagTxData << 8) | ch;
    287          
    288                  /* another byte  */
    289                  pcm_wJtagTxCtr++;
    290                  
    291                  /* all four bytes ready?  */
    292                  if(pcm_wJtagTxCtr & 0x4U)
    293                  {
    294                      FMSTR_JTAG_PUTDWORD(pcm_wJtagTxData);
    295                      pcm_wJtagTxCtr = 0U;
    296                  }
    297                      
    298          #endif
    299          
    300                  /* first, handle the replicated SOB characters */
    301                  if (ch == FMSTR_SOB)
    302                  {
    303                      pcm_wFlags.flg.bTxLastCharSOB ^= 1U;
    304                      if ((pcm_wFlags.flg.bTxLastCharSOB))
    305                      {
    306                      /* yes, repeat the SOB next time */
    307                      goto FMSTR_Tx_Exit;
    308                      }
    309                  }
    310                  /* no, advance tx buffer pointer */
    311                  pcm_nTxTodo--;
    312                  pcm_pTxBuff = FMSTR_SkipInBuffer(pcm_pTxBuff, 1U);
    313              }
    314          #if FMSTR_USE_JTAG  
    315              /* on JTAG, the some bytes may still be pending in a 32bit buffer */
    316              else if(pcm_wJtagTxCtr > 0U)
    317              {
    318                  /* add padding bytes */
    319                  while(!(pcm_wJtagTxCtr & 4U))
    320                  {
    321                      pcm_wJtagTxData = (pcm_wJtagTxData << 8U) | 0xffU;
    322                      pcm_wJtagTxCtr++;
    323                  }
    324          
    325                  /* send the word just completed */
    326                  FMSTR_JTAG_PUTDWORD(pcm_wJtagTxData);
    327          
    328                  /* done, bTxActive will be deactivated next time */
    329                  pcm_wJtagTxCtr = 0U;
    330              }
    331          #endif  
    332              /* transmission finished, start listening again */
    333              else
    334              {
    335                  /* when SCI TX buffering is enabled, we must first wait until all 
    336                    characters are physically transmitted (before disabling transmitter) */
    337          #if FMSTR_USE_SCI && FMSTR_SCI_HAS_TXQUEUE
    338                  pcm_wFlags.flg.bTxWaitTC = 1;
    339          
    340                  /* wait for SCI TC interrupt */
    341                  #if FMSTR_SHORT_INTR || FMSTR_LONG_INTR
    342                  FMSTR_SCI_ETCI();
    343                  #endif
    344          #else
    345                  /* start listening immediatelly */
    346                  FMSTR_Listen();
    347          #endif
    348              }
    349          FMSTR_Tx_Exit: ;
    350          }
    351          
    352          
    353          /**************************************************************************//*!
    354          *
    355          * @brief  Handle received character 
    356          *
    357          * @param  nRxChar  The character to be processed 
    358          * 
    359          * Handle the character received and -if the message is complete- call the 
    360          * protocol decode routine. 
    361          *
    362          ******************************************************************************/
    363          

   \                                 In section .text, align 2, keep-with-next
    364          static void FMSTR_Rx(FMSTR_BCHR nRxChar)
    365          {
   \                     FMSTR_Rx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0001             MOVS     R1,R0
    366              FMSTR_SERIAL_FLAGS * pflg = &pcm_wFlags;
    367              /* first, handle the replicated SOB characters */
    368              if(nRxChar == FMSTR_SOB)
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x....             LDR      R2,??DataTable4
   \   00000008   0x292B             CMP      R1,#+43
   \   0000000A   0xD107             BNE      ??FMSTR_Rx_0
    369              {
    370                  pflg->flg.bRxLastCharSOB ^= 1;
   \   0000000C   0x6853             LDR      R3,[R2, #+4]
   \   0000000E   0x2408             MOVS     R4,#+8
   \   00000010   0x405C             EORS     R4,R4,R3
   \   00000012   0x6054             STR      R4,[R2, #+4]
    371                  if(pflg->flg.bRxLastCharSOB)
   \   00000014   0x6853             LDR      R3,[R2, #+4]
   \   00000016   0x08DB             LSRS     R3,R3,#+3
   \   00000018   0x4003             ANDS     R3,R3,R0
   \   0000001A   0xD152             BNE      ??FMSTR_Rx_1
    372                  {
    373                      /* this is either the first byte of replicated SOB or a  */
    374                      /* real Start-of-Block mark - we will decide next time in FMSTR_Rx */
    375                      return;
    376                  }
    377              }
    378              
    379              /* we have got a common character preceeded by the SOB -  */
    380              /* this is the command code! */
    381              if(pflg->flg.bRxLastCharSOB)
   \                     ??FMSTR_Rx_0: (+1)
   \   0000001C   0x6853             LDR      R3,[R2, #+4]
   \   0000001E   0x08DB             LSRS     R3,R3,#+3
   \   00000020   0x4003             ANDS     R3,R3,R0
   \   00000022   0xD01B             BEQ      ??FMSTR_Rx_2
    382              {
    383                  /* reset reciving process */
    384                  pcm_pRxBuff = pcm_pCommBuffer;
    385                  *pcm_pRxBuff++ = nRxChar;
   \   00000024   0x....             LDR      R0,??DataTable4_2
   \   00000026   0x7101             STRB     R1,[R0, #+4]
   \   00000028   0x1D43             ADDS     R3,R0,#+5
   \   0000002A   0x6443             STR      R3,[R0, #+68]
    386                  
    387                  /* start computing the checksum */
    388                  pcm_nRxCheckSum = nRxChar;
   \   0000002C   0x7001             STRB     R1,[R0, #+0]
    389                  pcm_nRxTodo = 0U;
   \   0000002E   0x2000             MOVS     R0,#+0
    390                  
    391                  /* if the standard command was received, the message length will come in next byte */
    392                  pflg->flg.bRxMsgLengthNext = 1U;
   \   00000030   0x6853             LDR      R3,[R2, #+4]
   \   00000032   0x2410             MOVS     R4,#+16
   \   00000034   0x431C             ORRS     R4,R4,R3
   \   00000036   0x6054             STR      R4,[R2, #+4]
    393          
    394                  /* fast command? */
    395                  if(!((~nRxChar) & FMSTR_FASTCMD))
   \   00000038   0x43CB             MVNS     R3,R1
   \   0000003A   0x24C0             MOVS     R4,#+192
   \   0000003C   0x4223             TST      R3,R4
   \   0000003E   0xD107             BNE      ??FMSTR_Rx_3
    396                  {
    397                      /* fast command received, there will be no length information */
    398                      pflg->flg.bRxMsgLengthNext = 0U;
   \   00000040   0x6850             LDR      R0,[R2, #+4]
   \   00000042   0x2310             MOVS     R3,#+16
   \   00000044   0x4398             BICS     R0,R0,R3
   \   00000046   0x6050             STR      R0,[R2, #+4]
    399                      /* as it is encoded in the command byte directly */
    400                      pcm_nRxTodo = (FMSTR_SIZE8) 
    401                          (((((FMSTR_SIZE8)nRxChar) & FMSTR_FASTCMD_DATALEN_MASK) >> FMSTR_FASTCMD_DATALEN_SHIFT) + 1U);
   \   00000048   0x08C9             LSRS     R1,R1,#+3
   \   0000004A   0x2006             MOVS     R0,#+6
   \   0000004C   0x4008             ANDS     R0,R0,R1
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \                     ??FMSTR_Rx_3: (+1)
   \   00000050   0x7050             STRB     R0,[R2, #+1]
    402                  }
    403          
    404                  /* command code stored & processed */
    405                  pflg->flg.bRxLastCharSOB = 0U;
   \   00000052   0x6850             LDR      R0,[R2, #+4]
   \   00000054   0x2108             MOVS     R1,#+8
   \   00000056   0x4388             BICS     R0,R0,R1
   \   00000058   0x6050             STR      R0,[R2, #+4]
    406                  return;
   \   0000005A   0xBD10             POP      {R4,PC}
    407              }
    408          
    409              /* we are waiting for the length byte */
    410              if(pflg->flg.bRxMsgLengthNext)
   \                     ??FMSTR_Rx_2: (+1)
   \   0000005C   0x6853             LDR      R3,[R2, #+4]
   \   0000005E   0x091B             LSRS     R3,R3,#+4
   \   00000060   0x4018             ANDS     R0,R0,R3
   \   00000062   0xD005             BEQ      ??FMSTR_Rx_4
    411              {
    412                  /* this byte, total data length and the checksum */
    413                  pcm_nRxTodo = (FMSTR_SIZE8) (1U + ((FMSTR_SIZE8)nRxChar) + 1U);
   \   00000064   0x1C88             ADDS     R0,R1,#+2
   \   00000066   0x7050             STRB     R0,[R2, #+1]
    414                  /* now read the data bytes */
    415                  pflg->flg.bRxMsgLengthNext = 0U;
   \   00000068   0x6850             LDR      R0,[R2, #+4]
   \   0000006A   0x2310             MOVS     R3,#+16
   \   0000006C   0x4398             BICS     R0,R0,R3
   \   0000006E   0x6050             STR      R0,[R2, #+4]
    416          
    417              }
    418          
    419              /* waiting for a data byte? */
    420              if(pcm_nRxTodo)
   \                     ??FMSTR_Rx_4: (+1)
   \   00000070   0x7853             LDRB     R3,[R2, #+1]
   \   00000072   0x2B00             CMP      R3,#+0
   \   00000074   0xD025             BEQ      ??FMSTR_Rx_1
    421              {
    422                  /* add this byte to checksum */
    423                  pcm_nRxCheckSum += nRxChar;
   \   00000076   0x....             LDR      R0,??DataTable4_2
   \   00000078   0x7804             LDRB     R4,[R0, #+0]
   \   0000007A   0x1864             ADDS     R4,R4,R1
   \   0000007C   0x7004             STRB     R4,[R0, #+0]
    424                  
    425                  /* decrease number of expected bytes */
    426                  pcm_nRxTodo--;
   \   0000007E   0x1E5B             SUBS     R3,R3,#+1
   \   00000080   0x7053             STRB     R3,[R2, #+1]
    427                  /* was it the last byte of the message (checksum)? */
    428                  if(!pcm_nRxTodo)
   \   00000082   0x6C42             LDR      R2,[R0, #+68]
   \   00000084   0x061B             LSLS     R3,R3,#+24
   \   00000086   0xD110             BNE      ??FMSTR_Rx_5
    429                  {
    430                      /* receive buffer overflow? */
    431                      if(pcm_pRxBuff == NULL)
   \   00000088   0x2A00             CMP      R2,#+0
   \   0000008A   0xD101             BNE      ??FMSTR_Rx_6
    432                      {
    433                          FMSTR_SendError(FMSTR_STC_CMDTOOLONG);
   \   0000008C   0x2183             MOVS     R1,#+131
   \   0000008E   0xE002             B.N      ??FMSTR_Rx_7
    434                      }
    435                      /* checksum error? */
    436                      else if((pcm_nRxCheckSum & 0xffU) != 0U)
   \                     ??FMSTR_Rx_6: (+1)
   \   00000090   0x0624             LSLS     R4,R4,#+24
   \   00000092   0xD006             BEQ      ??FMSTR_Rx_8
    437                      {
    438                          FMSTR_SendError(FMSTR_STC_CMDCSERR);
   \   00000094   0x2182             MOVS     R1,#+130
   \                     ??FMSTR_Rx_7: (+1)
   \   00000096   0x7101             STRB     R1,[R0, #+4]
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x1D00             ADDS     R0,R0,#+4
   \   0000009C   0x.... 0x....      BL       FMSTR_SendResponse
    439                      }
   \   000000A0   0xBD10             POP      {R4,PC}
    440                      /* message is okay */
    441                      else 
    442                      {
    443                          /* do decode now! */
    444                          FMSTR_ProtocolDecoder(pcm_pCommBuffer);
   \                     ??FMSTR_Rx_8: (+1)
   \   000000A2   0x1D00             ADDS     R0,R0,#+4
   \   000000A4   0x.... 0x....      BL       FMSTR_ProtocolDecoder
   \   000000A8   0xBD10             POP      {R4,PC}
    445                      }
    446                  }
    447                  /* not the last character yet */
    448                  else 
    449                  {   
    450                      /* is there still a space in the buffer? */
    451                      if(pcm_pRxBuff)
   \                     ??FMSTR_Rx_5: (+1)
   \   000000AA   0x2A00             CMP      R2,#+0
   \   000000AC   0xD009             BEQ      ??FMSTR_Rx_1
    452                      {
    453                          /*lint -e{946} pointer arithmetic is okay here (same array) */
    454                          if(pcm_pRxBuff < (pcm_pCommBuffer + FMSTR_COMM_BUFFER_SIZE))
   \   000000AE   0x0003             MOVS     R3,R0
   \   000000B0   0x333E             ADDS     R3,R3,#+62
   \   000000B2   0x429A             CMP      R2,R3
   \   000000B4   0xD203             BCS      ??FMSTR_Rx_9
    455                          {
    456                              /* store byte  */
    457                              *pcm_pRxBuff++ = nRxChar;
   \   000000B6   0x7011             STRB     R1,[R2, #+0]
   \   000000B8   0x1C52             ADDS     R2,R2,#+1
   \   000000BA   0x6442             STR      R2,[R0, #+68]
   \   000000BC   0xBD10             POP      {R4,PC}
    458                          }
    459                          /* buffer is full! */
    460                          else
    461                          {
    462                              /* NULL rx pointer means buffer overflow - but we still need */
    463                              /* to receive all message characters (for the single-wire mode) */
    464                              /* so keep "receiving" - but throw away all characters from now */
    465                              pcm_pRxBuff = NULL;
   \                     ??FMSTR_Rx_9: (+1)
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x6441             STR      R1,[R0, #+68]
    466                          }
    467                      }
    468                  }
    469              }
    470          }
   \                     ??FMSTR_Rx_1: (+1)
   \   000000C2   0xBD10             POP      {R4,PC}          ;; return
    471          
    472          /*******************************************************************************
    473          *
    474          * @brief    Routine to quick-receive a character (put to a queue only)
    475          *
    476          * This function puts received character into a queue and exits as soon as possible.
    477          *
    478          *******************************************************************************/
    479          
    480          #if FMSTR_SHORT_INTR
    481          
    482          static void FMSTR_RxQueue(FMSTR_BCHR nRxChar)
    483          { 
    484              /* future value of write pointer */
    485              FMSTR_BPTR wpnext = pcm_pRQueueWP + 1;
    486              
    487              /*lint -e{946} pointer arithmetic is okay here (same array) */
    488              if(wpnext >= (pcm_pRQueueBuffer + FMSTR_COMM_RQUEUE_SIZE))
    489              {
    490                  wpnext = pcm_pRQueueBuffer;
    491              }
    492              
    493              /* any space in queue? */
    494              if(wpnext != pcm_pRQueueRP)
    495              {
    496                  *pcm_pRQueueWP = (FMSTR_U8) nRxChar;
    497                  pcm_pRQueueWP = wpnext;
    498              }
    499          }
    500          
    501          #endif /* FMSTR_SHORT_INTR  */
    502          
    503          /*******************************************************************************
    504          *
    505          * @brief    Late processing of queued characters
    506          *
    507          * This function takes the queued characters and calls FMSTR_Rx() for each of them,
    508          * just like as the characters would be received from SCI one by one.
    509          *
    510          *******************************************************************************/
    511          
    512          #if FMSTR_SHORT_INTR
    513          
    514          static void FMSTR_RxDequeue(void)
    515          { 
    516              FMSTR_BCHR nChar = 0U;
    517              
    518              /* get all queued characters */
    519              while(pcm_pRQueueRP != pcm_pRQueueWP)
    520              {
    521                  nChar = *pcm_pRQueueRP++;
    522          
    523                  /*lint -e{946} pointer arithmetic is okay here (same array) */
    524                  if(pcm_pRQueueRP >= (pcm_pRQueueBuffer + FMSTR_COMM_RQUEUE_SIZE))
    525                  {
    526                      pcm_pRQueueRP = pcm_pRQueueBuffer;
    527                  }
    528                  
    529                  /* emulate the SCI receive event */
    530                  if(!pcm_wFlags.flg.bTxActive)
    531                  {
    532                      FMSTR_Rx(nChar);
    533                  }
    534              }
    535          }
    536          
    537          #endif /* FMSTR_SHORT_INTR */
    538          
    539          /**************************************************************************//*!
    540          *
    541          * @brief    Handle SCI communication (both TX and RX)
    542          *
    543          * This function checks the SCI flags and calls the Rx and/or Tx functions
    544          *
    545          * @note This function can be called either from SCI ISR or from the polling routine
    546          *
    547          ******************************************************************************/
    548          
    549          #if FMSTR_USE_SCI
    550          

   \                                 In section .text, align 2, keep-with-next
    551          void FMSTR_ProcessSCI(void)
    552          {
   \                     FMSTR_ProcessSCI: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    553              /* read & clear status     */
    554              FMSTR_SCISR wSciSR = FMSTR_SCI_RDCLRSR();
   \   00000002   0x....             LDR      R4,??DataTable4_3  ;; 0x4006b004
   \   00000004   0x7825             LDRB     R5,[R4, #+0]
    555          
    556              /* transmitter active and empty? */
    557              if (pcm_wFlags.flg.bTxActive)
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR      R1,??DataTable4
   \   0000000A   0x684A             LDR      R2,[R1, #+4]
   \   0000000C   0x4002             ANDS     R2,R2,R0
   \   0000000E   0xD01E             BEQ      ??FMSTR_ProcessSCI_0
    558              {
    559                  /* able to accept another character? */
    560                  if(wSciSR & FMSTR_SCISR_TDRE)
   \   00000010   0x062A             LSLS     R2,R5,#+24
   \   00000012   0xD516             BPL      ??FMSTR_ProcessSCI_1
    561                  {
    562                      FMSTR_Tx();
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD011             BEQ      ??FMSTR_ProcessSCI_2
   \   0000001A   0x688B             LDR      R3,[R1, #+8]
   \   0000001C   0x781E             LDRB     R6,[R3, #+0]
   \   0000001E   0x70E6             STRB     R6,[R4, #+3]
   \   00000020   0x2E2B             CMP      R6,#+43
   \   00000022   0xD107             BNE      ??FMSTR_ProcessSCI_3
   \   00000024   0x684E             LDR      R6,[R1, #+4]
   \   00000026   0x2704             MOVS     R7,#+4
   \   00000028   0x4077             EORS     R7,R7,R6
   \   0000002A   0x604F             STR      R7,[R1, #+4]
   \   0000002C   0x684E             LDR      R6,[R1, #+4]
   \   0000002E   0x08B6             LSRS     R6,R6,#+2
   \   00000030   0x4030             ANDS     R0,R0,R6
   \   00000032   0xD106             BNE      ??FMSTR_ProcessSCI_1
   \                     ??FMSTR_ProcessSCI_3: (+1)
   \   00000034   0x1E50             SUBS     R0,R2,#+1
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   \   00000038   0x1C5B             ADDS     R3,R3,#+1
   \   0000003A   0x608B             STR      R3,[R1, #+8]
   \   0000003C   0xE001             B        ??FMSTR_ProcessSCI_1
   \                     ??FMSTR_ProcessSCI_2: (+1)
   \   0000003E   0x.... 0x....      BL       FMSTR_Listen
    563                  }
    564                  
    565          #if FMSTR_SCI_HAS_TXQUEUE
    566                  /* waiting for transmission complete flag? */
    567                  if(pcm_wFlags.flg.bTxWaitTC && (wSciSR & FMSTR_SCISR_TC))
    568                  {
    569                      /* after TC, we can switch to listen mode safely */
    570                      FMSTR_Listen();
    571                  }
    572          #endif
    573          
    574          
    575          #if !FMSTR_SCI_TWOWIRE_ONLY
    576                  /* read-out and ignore any received character (loopback) */
    577                  if(wSciSR & FMSTR_SCISR_RDRF)
   \                     ??FMSTR_ProcessSCI_1: (+1)
   \   00000042   0x06A8             LSLS     R0,R5,#+26
   \   00000044   0xD508             BPL      ??FMSTR_ProcessSCI_4
    578                  {
    579                      /*lint -esym(550, nRxChar) */
    580                      volatile FMSTR_U16 nRxChar;
    581                      nRxChar = FMSTR_SCI_GETCHAR(); 
   \   00000046   0x78E0             LDRB     R0,[R4, #+3]
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x8008             STRH     R0,[R1, #+0]
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}
    582                  }
    583          #endif
    584              }
    585              /* transmitter not active, able to receive */
    586              else
    587              {
    588                  /* data byte received? */
    589                  if (wSciSR & FMSTR_SCISR_RDRF)
   \                     ??FMSTR_ProcessSCI_0: (+1)
   \   0000004E   0x06A8             LSLS     R0,R5,#+26
   \   00000050   0xD502             BPL      ??FMSTR_ProcessSCI_4
    590                  {
    591                      FMSTR_BCHR nRxChar = 0U;
    592                      nRxChar = (FMSTR_BCHR) FMSTR_SCI_GETCHAR();
   \   00000052   0x78E0             LDRB     R0,[R4, #+3]
    593          
    594          #if FMSTR_SHORT_INTR
    595                      FMSTR_RxQueue(nRxChar);
    596          #else
    597                      FMSTR_Rx(nRxChar);  
   \   00000054   0x.... 0x....      BL       FMSTR_Rx
    598          #endif          
    599                  }
    600              }
    601          }
   \                     ??FMSTR_ProcessSCI_4: (+1)
   \   00000058   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    602          
    603          #endif
    604          
    605          /**************************************************************************//*!
    606          *
    607          * @brief    Handle JTAG communication (both TX and RX)
    608          *
    609          * This function checks the JTAG flags and calls the Rx and/or Tx functions
    610          *
    611          * @note This function can be called either from JTAG ISR or from the polling routine
    612          *
    613          ******************************************************************************/
    614          
    615          #if FMSTR_USE_JTAG
    616          
    617          void FMSTR_ProcessJTAG(void)
    618          {
    619              /* read & clear status     */
    620              register FMSTR_U16 wJtagSR = FMSTR_JTAG_GETSR();
    621          
    622              /* transmitter active? */
    623              if (pcm_wFlags.flg.bTxActive)
    624              {
    625                  /* able to transmit a new character? (TX must be empty = read-out by PC) */
    626                  if(!(wJtagSR & FMSTR_JTAG_OTXRXSR_TDF))
    627                  {
    628                  
    629          #if FMSTR_USE_JTAG_TXFIX
    630                      /* if TDF bit is useless due to silicon bug, use the RX flag */
    631                      /* instead (PC sends us a dummy word to kick the RX flag on) */
    632                      if(wJtagSR & FMSTR_JTAG_OTXRXSR_RDF)
    633          #endif
    634                      {
    635                          /* send one byte always */
    636                          FMSTR_Tx();
    637                          
    638                          /* try to fill-up the full 32bit JTAG word */
    639                          while(pcm_wFlags.flg.bTxActive && pcm_wJtagTxCtr)
    640                          {
    641                              FMSTR_Tx();
    642                          }
    643                      }               
    644                  }
    645          
    646                  /* ignore (read-out) the JTAG-received word */
    647                  if(wJtagSR & FMSTR_JTAG_OTXRXSR_RDF)
    648                  {
    649                      /*lint -esym(550, nRxWord) */
    650                      volatile FMSTR_U16 nRxWord;
    651                      nRxWord = FMSTR_JTAG_GETWORD();
    652                  }
    653              }
    654              /* transmitter not active */
    655              else
    656              {
    657                  /* JTAG 32bit word (four bytes) received? */
    658                  if(wJtagSR & FMSTR_JTAG_OTXRXSR_RDF)
    659                  {
    660                      register FMSTR_U32 nRxDWord;
    661                      FMSTR_INDEX i;
    662                      
    663                      nRxDWord = FMSTR_JTAG_GETDWORD();
    664                      
    665                      /* process all bytes, MSB first */
    666                      for(i=0; i<4; i++)
    667                      {
    668          #if FMSTR_SHORT_INTR
    669                          FMSTR_RxQueue((FMSTR_BCHR)((nRxDWord >> 24U) & 0xffU));
    670                          
    671          #else
    672                          FMSTR_Rx((FMSTR_BCHR)((nRxDWord >> 24U) & 0xffU));
    673                      
    674                          /* ignore the rest if previous bytes triggered a transmission */
    675                          /* (i.e. the packet was complete and only filled-up to 32bit word) */
    676                          if(pcm_wFlags.flg.bTxActive)
    677                          {
    678                              break;
    679                          }
    680          #endif          
    681                          /* next byte of 32bit word */
    682                          nRxDWord = nRxDWord << 8;
    683                      }
    684                  }
    685              }
    686          }
    687          
    688          #endif
    689          
    690          /*******************************************************************************
    691          *
    692          * @brief    API: Main "Polling" call from the application main loop
    693          *
    694          * This function either handles all the SCI communictaion (polling-only mode = 
    695          * FMSTR_POLL_DRIVEN) or decodes messages received on the background by SCI interrupt
    696          * (short-interrupt mode = FMSTR_SHORT_INTR). 
    697          *
    698          * In the JTAG interrupt-driven mode (both short and long), this function also checks
    699          * if setting the JTAG RIE bit failed recently. This may happen because of the 
    700          * RIE is held low by the EONCE hardware until the EONCE is first accessed from host.
    701          * FMSTR_Init (->FMSTR_Listen) is often called while the PC-side FreeMASTER is still 
    702          * turned off. So really, the JTAG is not enabled by this time and RIE bit is not set.
    703          * This problem is detected (see how bJtagRIEPending is set above in FSMTR_Listen)
    704          * and it is tried to be fixed periodically here in FMSTR_Poll.
    705          *
    706          *******************************************************************************/
    707          

   \                                 In section .text, align 2, keep-with-next
    708          void FMSTR_Poll(void)
    709          { 
    710          #if !FMSTR_POLL_DRIVEN && FMSTR_USE_JTAG
    711              /* in the interrupt-driven JTAG mode, the JTAG RIE may have failed to be set recently */
    712              if(pcm_wFlags.flg.bJtagRIEPending)
    713              {
    714                  FMSTR_JTAG_ERXI();  /* try to enable JTAG recieve interrupt now */
    715          
    716                  /* succeeded? */
    717                  if(FMSTR_JTAG_ERXI_CHECK())
    718                      pcm_wFlags.flg.bJtagRIEPending = 0; /* yes!, enough until it fails again (never?) */
    719              }
    720          #endif    
    721          
    722          #if FMSTR_POLL_DRIVEN
    723          
    724          #if FMSTR_USE_SCI
    725              /* polled SCI mode */
    726              FMSTR_ProcessSCI(); 
    727              
    728          #elif FMSTR_USE_JTAG
    729              /* polled JTAG mode */
    730              FMSTR_ProcessJTAG(); 
    731              
    732          #endif
    733              
    734          #elif FMSTR_SHORT_INTR
    735          
    736              /* process queued SCI characters */
    737              FMSTR_RxDequeue(); 
    738            
    739          #endif
    740          }
   \                     FMSTR_Poll: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     pcm_nTxTodo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x4006B003         DC32     0x4006b003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     pcm_nRxCheckSum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x4006B004         DC32     0x4006b004
    741          
    742          #else /* FMSTR_USE_SCI || FMSTR_USE_JTAG */
    743          
    744          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    745          
    746          #endif /* FMSTR_USE_SCI || FMSTR_USE_JTAG */
    747          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMSTR_InitSerial
       0   FMSTR_Listen
       0   FMSTR_Poll
      24   FMSTR_ProcessSCI
        24   -> FMSTR_Listen
        24   -> FMSTR_Rx
       8   FMSTR_Rx
         8   -> FMSTR_ProtocolDecoder
         8   -> FMSTR_SendResponse
      16   FMSTR_SendResponse


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
      54  ?Subroutine0
      10  FMSTR_InitSerial
       4  FMSTR_Listen
       2  FMSTR_Poll
      90  FMSTR_ProcessSCI
     196  FMSTR_Rx
     110  FMSTR_SendResponse
      72  pcm_nRxCheckSum
          pcm_pCommBuffer
          pcm_pRxBuff
      12  pcm_nTxTodo
          pcm_nRxTodo
          pcm_wFlags
          pcm_pTxBuff

 
  84 bytes in section .bss
 482 bytes in section .text
 
 482 bytes of CODE memory
  84 bytes of DATA memory

Errors: none
Warnings: none
