###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        30/Jan/2016  15:22:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_rec.c
#    Command line =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_rec.c
#        -D NDEBUG -lCN
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\
#        -o
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\
#        --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\common\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\drivers\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\freemaster\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\projects\_twr_emeter_demo\
#        -Oh --require_prototypes
#    List file    =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\freemaster_rec.lst
#    Object file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\freemaster_rec.o
#
###############################################################################

E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\freemaster\freemaster_rec.c
      1          /******************************************************************************
      2          *
      3          * Freescale Semiconductor Inc.
      4          * (c) Copyright 2004-2010 Freescale Semiconductor
      5          * ALL RIGHTS RESERVED.
      6          *
      7          ****************************************************************************//*!
      8          *
      9          * @file   freemaster_rec.c
     10          *
     11          * @brief  FreeMASTER Recorder implementation.
     12          *
     13          * @version 1.0.1.0
     14          * 
     15          * @date May-4-2012
     16          * 
     17          *******************************************************************************/
     18          
     19          #include "freemaster.h"
     20          #include "freemaster_private.h"
     21          #include "freemaster_protocol.h"
     22          
     23          #if FMSTR_USE_RECORDER
     24          
     25          #include "freemaster_rec.h"
     26          
     27          #if FMSTR_USE_FASTREC
     28          #include "freemaster_fastrec.h"
     29          #endif
     30          
     31          /********************************************************
     32          *  global variables (shared with FastRecorder if used)
     33          ********************************************************/
     34          
     35          /* configuration variables */

   \                                 In section .bss, align 4
     36          FMSTR_U16  pcm_wRecTotalSmps;        /* number of samples to measure */
     37          
     38          #if FMSTR_REC_STATIC_POSTTRIG == 0
     39          FMSTR_U16  pcm_wRecPostTrigger;      /* number of post-trigger samples to keep */
     40          #endif
     41          
     42          #if (FMSTR_USE_FASTREC) == 0
     43          FMSTR_U8   pcm_nRecTriggerMode;      /* triger mode (0 = disabled, 1 = _/, 2 = \_) */
   \                     pcm_nRecTriggerMode:
   \   00000000                      DS8 1
     44          #endif
     45          
     46          #if (FMSTR_REC_STATIC_DIVISOR) == 0
     47          FMSTR_U16  pcm_wRecTimeDiv;          /* divisor of recorder "clock" */
     48          #endif
     49          
     50          FMSTR_U8    pcm_nRecVarCount;        /* number of active recorder variables */
   \                     pcm_nRecVarCount:
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
     51          FMSTR_ADDR  pcm_pRecVarAddr[FMSTR_MAX_SCOPE_VARS]; /* addresses of recorded variables */
     52          FMSTR_SIZE8 pcm_pRecVarSize[FMSTR_MAX_SCOPE_VARS]; /* sizes of recorded variables */
   \                     pcm_pRecVarSize:
   \   00000004                      DS8 8
     53          
     54          /* runtime variables  */
     55          #if (FMSTR_REC_STATIC_DIVISOR) != 1
     56          FMSTR_U16  pcm_wRecTimeDivCtr;       /* recorder "clock" divisor counter */
     57          #endif
     58          
     59          FMSTR_U16  pcm_wStoprecCountDown;    /* post-trigger countdown counter */
     60          
     61          /* recorder flags */
     62          FMSTR_REC_FLAGS pcm_wRecFlags;
   \                     pcm_wRecFlags:
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \                     pcm_wRecTotalSmps:
   \   00000014                      DS8 2
   \                     pcm_wRecPostTrigger:
   \   00000016                      DS8 2
   \                     pcm_wRecTimeDiv:
   \   00000018                      DS8 2
   \                     pcm_wRecTimeDivCtr:
   \   0000001A                      DS8 2
   \                     pcm_wStoprecCountDown:
   \   0000001C                      DS8 2
     63          
     64          /***********************************
     65          *  local variables 
     66          ***********************************/
     67          
     68          #if (FMSTR_USE_FASTREC) == 0
     69          FMSTR_U16   pcm_wRecBuffStartIx;     /* first sample index */
   \                     pcm_wRecBuffStartIx:
   \   0000001E                      DS8 2
   \                     pcm_pRecVarAddr:
   \   00000020                      DS8 32
     70          
     71          /* Recorder buffer pointers */
     72          FMSTR_ADDR pcm_dwRecWritePtr;        /* write pointer in recorder buffer */
   \                     pcm_dwRecWritePtr:
   \   00000040                      DS8 4
     73          FMSTR_ADDR pcm_dwRecEndBuffPtr;      /* pointer to end of active recorder buffer */
   \                     pcm_dwRecEndBuffPtr:
   \   00000044                      DS8 4
   \   00000048                      DS8 4
   \   0000004C                      DS8 4
   \   00000050                      DS8 4
   \   00000054                      DS8 4096
     74          
     75          /* configuration variables */
     76          static FMSTR_ADDR pcm_nTrgVarAddr;          /* trigger variable address */
     77          static FMSTR_U8   pcm_nTrgVarSize;          /* trigger variable threshold size */
     78          static FMSTR_U8   pcm_bTrgVarSigned;        /* trigger compare mode (0 = unsigned, 1 = signed) */
     79          
     80          /*lint -e{960} using union */
     81          static union 
     82          {
     83          #if FMSTR_CFG_BUS_WIDTH == 1
     84              FMSTR_U8  u8; 
     85              FMSTR_S8  s8;
     86          #endif
     87              FMSTR_U16 u16;
     88              FMSTR_S16 s16;
     89              FMSTR_U32 u32;
     90              FMSTR_S32 s32;
     91          } pcm_uTrgThreshold;                        /* trigger threshold level (1,2 or 4 bytes) */
     92          #endif /* (FMSTR_USE_FASTREC) == 0 */
     93          
     94          static FMSTR_ADDR  pcm_nRecBuffAddr;        /* recorder buffer address */

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
     95          static FMSTR_SIZE  pcm_wRecBuffSize;        /* recorder buffer size */
     96          
     97          /* compare functions prototype */
     98          typedef FMSTR_BOOL (*FMSTR_PCOMPAREFUNC)(void);
     99          
    100          /*/ pointer to active compare function */
    101          static FMSTR_PCOMPAREFUNC pcm_pCompareFunc;
    102          
    103          #if !FMSTR_REC_OWNBUFF && (FMSTR_USE_FASTREC) == 0
    104          /* put buffer into far memory ? */
    105          #if FMSTR_REC_FARBUFF
    106          #pragma section fardata begin
    107          #endif /* FMSTR_REC_FARBUFF */
    108          /* statically allocated recorder buffer (FMSTR_REC_OWNBUFF is FALSE) */
    109          static FMSTR_U8 pcm_pOwnRecBuffer[FMSTR_REC_BUFF_SIZE];
    110          /* end of far memory section */
    111          #if FMSTR_REC_FARBUFF
    112          #pragma section fardata end
    113          #endif /* FMSTR_REC_FARBUFF */
    114          #endif /* FMSTR_REC_OWNBUFF */
    115          
    116          /***********************************
    117          *  local functions
    118          ***********************************/
    119          
    120          static FMSTR_BOOL FMSTR_Compare8S(void);
    121          static FMSTR_BOOL FMSTR_Compare8U(void);
    122          static FMSTR_BOOL FMSTR_Compare16S(void);
    123          static FMSTR_BOOL FMSTR_Compare16U(void);
    124          static FMSTR_BOOL FMSTR_Compare32S(void);
    125          static FMSTR_BOOL FMSTR_Compare32U(void);
    126          static void FMSTR_Recorder2(void);
    127          
    128          /**************************************************************************//*!
    129          *
    130          * @brief    Recorder Initialization
    131          *
    132          ******************************************************************************/
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void FMSTR_InitRec(void)
    135          {   
    136              /* initialize Recorder flags*/
    137              pcm_wRecFlags.all = 0U;
   \                     FMSTR_InitRec: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7301             STRB     R1,[R0, #+12]
    138          
    139              /* setup buffer pointer and size so IsInRecBuffer works even  
    140                 before the recorder is first initialized and used */
    141              
    142          #if FMSTR_REC_OWNBUFF
    143              /* user wants to use his own buffer */
    144              pcm_nRecBuffAddr = 0U;
    145              pcm_wRecBuffSize = 0U;
    146          #elif FMSTR_USE_FASTREC
    147              /* Initialize Fast Recorder Buffer  */
    148              FMSTR_InitFastRec();
    149          #else
    150              /* size in native sizeof units (=bytes on most platforms) */
    151              pcm_wRecBuffSize = (FMSTR_SIZE) FMSTR_REC_BUFF_SIZE;
    152              FMSTR_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x3154             ADDS     R1,R1,#+84
   \   0000000A   0x64C1             STR      R1,[R0, #+76]
    153              
    154              /*lint -esym(528, pcm_pOwnRecBuffer) this symbol is used outside of lint sight */
    155          #endif
    156          
    157          }
   \   0000000C   0x4770             BX       LR               ;; return
    158          
    159          /**************************************************************************//*!
    160          *
    161          * @brief    Abort and de-initialize recorder
    162          *
    163          ******************************************************************************/
    164          
    165          #if defined(FMSTR_PLATFORM_HC08) || defined(FMSTR_PLATFORM_HC12)
    166            #pragma INLINE
    167          #else 
    168            static inline
    169          #endif
    170          void FMSTR_AbortRec(void)
    171          {
    172              /* clear flags */
    173              pcm_wRecFlags.all = 0U;
    174          }
    175          
    176          /**************************************************************************//*!
    177          *
    178          * @brief    API: Replacing the recorder buffer with the user's one
    179          *
    180          * @param    pBuffer - user buffer pointer
    181          * @param    wBuffSize - buffer size
    182          *
    183          * @note Use the FMSTR_SetUpBuff32 to pass the forced 32bit address in SDM
    184          *
    185          ******************************************************************************/
    186          

   \                                 In section .text, align 2, keep-with-next
    187          void FMSTR_SetUpRecBuff(FMSTR_ADDR pBuffer, FMSTR_SIZE nBuffSize)
    188          {    
    189              pcm_nRecBuffAddr = pBuffer;
   \                     FMSTR_SetUpRecBuff: (+1)
   \   00000000   0x....             LDR      R1,??DataTable12
   \   00000002   0x64C8             STR      R0,[R1, #+76]
    190              pcm_wRecBuffSize = nBuffSize;
    191          }
   \   00000004   0x4770             BX       LR               ;; return
    192          
    193          /**************************************************************************//*!
    194          *
    195          * @brief    Handling SETUPREC and SETUPREC_EX commands
    196          *
    197          * @param    pMessageIO - original command (in) and response buffer (out) 
    198          *
    199          * @return   As all command handlers, the return value should be the buffer 
    200          *           pointer where the response output finished (except checksum)
    201          *
    202          ******************************************************************************/
    203          

   \                                 In section .text, align 2, keep-with-next
    204          FMSTR_BPTR FMSTR_SetUpRec(FMSTR_BPTR pMessageIO)
    205          {
   \                     FMSTR_SetUpRec: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    206              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x9003             STR      R0,[SP, #+12]
   \   00000006   0x....             LDR      R4,??DataTable12
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7321             STRB     R1,[R4, #+12]
    207              FMSTR_SIZE8 nRecVarsetSize;
    208              FMSTR_SIZE blen;
    209              FMSTR_U8 i, sz;
    210              FMSTR_U8 nResponseCode;
    211              
    212              /* de-initialize first   */
    213              FMSTR_AbortRec();
    214          
    215          #if FMSTR_REC_OWNBUFF
    216              /* user wants to use his own buffer, check if it is valid */
    217              if(!pcm_nRecBuffAddr || !pcm_wRecBuffSize)
    218              {
    219                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVBUFF);
    220              }
    221          #elif (FMSTR_USE_FASTREC) == 0
    222              /* size in native sizeof units (=bytes on most platforms) */
    223              pcm_wRecBuffSize = (FMSTR_SIZE)FMSTR_REC_BUFF_SIZE;
    224              FMSTR_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x3154             ADDS     R1,R1,#+84
   \   00000010   0x64E1             STR      R1,[R4, #+76]
    225          #endif
    226          
    227              /* seek the setup data */
    228          #if (FMSTR_USE_FASTREC) == 0
    229              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    230              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nRecTriggerMode, pMessageIO);
   \   00000012   0x7881             LDRB     R1,[R0, #+2]
   \   00000014   0x7021             STRB     R1,[R4, #+0]
   \   00000016   0x1CC1             ADDS     R1,R0,#+3
    231          #else /* (FMSTR_USE_FASTREC) == 0 */
    232              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 3U);
    233          #endif /* (FMSTR_USE_FASTREC) == 0 */
    234          
    235              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecTotalSmps, pMessageIO);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x3014             ADDS     R0,R0,#+20
   \   0000001C   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
    236          
    237          #if (FMSTR_REC_STATIC_POSTTRIG) == 0
    238              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecPostTrigger, pMessageIO);
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x3016             ADDS     R0,R0,#+22
   \   00000026   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
    239          #else /* (FMSTR_REC_STATIC_POSTTRIG) == 0 */
    240              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    241          #endif /* (FMSTR_REC_STATIC_POSTTRIG) == 0 */
    242          
    243          #if (FMSTR_REC_STATIC_DIVISOR) == 0
    244              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecTimeDiv, pMessageIO);
   \   0000002A   0x0001             MOVS     R1,R0
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x3018             ADDS     R0,R0,#+24
   \   00000030   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
    245          #else /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    246              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    247          #endif /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    248          
    249          #if (FMSTR_USE_FASTREC) == 0
    250              /* address & size of trigger variable */
    251              pMessageIO = FMSTR_AddressFromBuffer(&pcm_nTrgVarAddr, pMessageIO);
   \   00000034   0x0001             MOVS     R1,R0
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x3048             ADDS     R0,R0,#+72
   \   0000003A   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    252              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nTrgVarSize, pMessageIO);
   \   0000003E   0x7801             LDRB     R1,[R0, #+0]
   \   00000040   0x70A1             STRB     R1,[R4, #+2]
    253          
    254              /* trigger compare mode  */
    255              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_bTrgVarSigned, pMessageIO);
   \   00000042   0x7841             LDRB     R1,[R0, #+1]
   \   00000044   0x70E1             STRB     R1,[R4, #+3]
   \   00000046   0x1C81             ADDS     R1,R0,#+2
    256          
    257              /* threshold value  */
    258              pMessageIO = FMSTR_ValueFromBuffer32(&pcm_uTrgThreshold.u32, pMessageIO);
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x3010             ADDS     R0,R0,#+16
   \   0000004C   0x.... 0x....      BL       FMSTR_ValueFromBuffer32
    259          #else /* (FMSTR_USE_FASTREC) == 0 */
    260              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 8U);
    261          #endif /* (FMSTR_USE_FASTREC) == 0 */
    262              
    263              /* recorder variable count */
    264              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nRecVarCount, pMessageIO);
   \   00000050   0x7801             LDRB     R1,[R0, #+0]
   \   00000052   0x7061             STRB     R1,[R4, #+1]
   \   00000054   0x1C47             ADDS     R7,R0,#+1
    265          
    266              /* rec variable information must fit into our buffers */
    267              if(!pcm_nRecVarCount || pcm_nRecVarCount > (FMSTR_U8)FMSTR_MAX_REC_VARS)
   \   00000056   0x2900             CMP      R1,#+0
   \   00000058   0xD001             BEQ      ??FMSTR_SetUpRec_0
   \   0000005A   0x2909             CMP      R1,#+9
   \   0000005C   0xDB01             BLT      ??FMSTR_SetUpRec_1
    268              {
    269          #if FMSTR_REC_COMMON_ERR_CODES
    270                  goto FMSTR_SetUpRec_exit_error;
    271          #else
    272                  nResponseCode = FMSTR_STC_INVBUFF;
   \                     ??FMSTR_SetUpRec_0: (+1)
   \   0000005E   0x2085             MOVS     R0,#+133
    273                  goto FMSTR_SetUpRec_exit;
   \   00000060   0xE068             B        ??FMSTR_SetUpRec_2
    274          #endif
    275              }
    276          
    277              /* calculate sum of sizes of all variables */
    278              nRecVarsetSize = 0U;
   \                     ??FMSTR_SetUpRec_1: (+1)
   \   00000062   0x2500             MOVS     R5,#+0
    279          
    280              /* get all addresses and sizes */
    281              for(i=0U; i<pcm_nRecVarCount; i++)
   \   00000064   0x9502             STR      R5,[SP, #+8]
   \   00000066   0x1D20             ADDS     R0,R4,#+4
   \   00000068   0x9001             STR      R0,[SP, #+4]
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x3020             ADDS     R0,R0,#+32
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xE011             B        ??FMSTR_SetUpRec_3
    282              {
    283                  /* variable size */
    284                  pMessageIO = FMSTR_ValueFromBuffer8(&sz, pMessageIO);
    285                  
    286                  pcm_pRecVarSize[i] = sz;
    287                  nRecVarsetSize += sz;
    288                  
    289                  /* variable address */
    290                  pMessageIO = FMSTR_AddressFromBuffer(&pcm_pRecVarAddr[i], pMessageIO);
    291          
    292                  /* valid numeric variable sizes only */
    293                  if(sz == 0U || sz > 8U)
    294                  {
    295          #if FMSTR_REC_COMMON_ERR_CODES
    296                      goto FMSTR_SetUpRec_exit_error;
    297          #else
    298                      nResponseCode = FMSTR_STC_INVSIZE;
    299                      goto FMSTR_SetUpRec_exit;
    300          #endif
    301                  }
    302          
    303          #if FMSTR_CFG_BUS_WIDTH > 1U
    304                  /* even sizes only */
    305                  if(sz & 0x1)
    306                  {
    307          #if FMSTR_REC_COMMON_ERR_CODES
    308                      goto FMSTR_SetUpRec_exit_error;
    309          #else
    310                      nResponseCode = FMSTR_STC_INVSIZE;
    311                      goto FMSTR_SetUpRec_exit;
    312          #endif
    313                  }
    314          #endif /* FMSTR_CFG_BUS_WIDTH > 1U */
    315                  
    316          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    317                  if(!FMSTR_CheckTsaSpace(pcm_pRecVarAddr[i], (FMSTR_SIZE8)sz, 0U))
   \                     ??FMSTR_SetUpRec_4: (+1)
   \   00000072   0x2200             MOVS     R2,#+0
   \   00000074   0x0031             MOVS     R1,R6
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD028             BEQ      ??FMSTR_SetUpRec_5
   \   00000082   0x9802             LDR      R0,[SP, #+8]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0x9002             STR      R0,[SP, #+8]
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x1D00             ADDS     R0,R0,#+4
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9801             LDR      R0,[SP, #+4]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0x9001             STR      R0,[SP, #+4]
   \                     ??FMSTR_SetUpRec_3: (+1)
   \   00000096   0x9802             LDR      R0,[SP, #+8]
   \   00000098   0x7861             LDRB     R1,[R4, #+1]
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xDA0E             BGE      ??FMSTR_SetUpRec_6
   \   0000009E   0x783E             LDRB     R6,[R7, #+0]
   \   000000A0   0x1C79             ADDS     R1,R7,#+1
   \   000000A2   0x9801             LDR      R0,[SP, #+4]
   \   000000A4   0x7006             STRB     R6,[R0, #+0]
   \   000000A6   0x19AD             ADDS     R5,R5,R6
   \   000000A8   0xB2ED             UXTB     R5,R5
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
   \   000000AC   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   000000B0   0x0007             MOVS     R7,R0
   \   000000B2   0x2E00             CMP      R6,#+0
   \   000000B4   0xD034             BEQ      ??FMSTR_SetUpRec_7
   \   000000B6   0x2E09             CMP      R6,#+9
   \   000000B8   0xD3DB             BCC      ??FMSTR_SetUpRec_4
   \   000000BA   0xE031             B.N      ??FMSTR_SetUpRec_7
    318                  {
    319          #if FMSTR_REC_COMMON_ERR_CODES
    320                      goto FMSTR_SetUpRec_exit_error;
    321          #else
    322                      nResponseCode = FMSTR_STC_EACCESS;
    323                      goto FMSTR_SetUpRec_exit;
    324          #endif
    325                  }
    326          #endif /* FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY */
    327              }
    328          
    329              /* fast recorder handles trigger by itself */
    330          #if (FMSTR_USE_FASTREC) == 0
    331              /* any trigger? */
    332              pcm_pCompareFunc = NULL;
   \                     ??FMSTR_SetUpRec_6: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x6520             STR      R0,[R4, #+80]
    333              if(pcm_nRecTriggerMode)
   \   000000C0   0x7820             LDRB     R0,[R4, #+0]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD015             BEQ      ??FMSTR_SetUpRec_8
    334              {
    335                  /* access to trigger variable? */
    336          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    337                  if(!FMSTR_CheckTsaSpace(pcm_nTrgVarAddr, (FMSTR_SIZE8)pcm_nTrgVarSize, 0U))
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0x78A1             LDRB     R1,[R4, #+2]
   \   000000CA   0x6CA0             LDR      R0,[R4, #+72]
   \   000000CC   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD101             BNE      ??FMSTR_SetUpRec_9
    338                  {
    339          #if FMSTR_REC_COMMON_ERR_CODES
    340                      goto FMSTR_SetUpRec_exit_error;
    341          #else
    342                      nResponseCode = FMSTR_STC_EACCESS;
   \                     ??FMSTR_SetUpRec_5: (+1)
   \   000000D4   0x2089             MOVS     R0,#+137
    343                      goto FMSTR_SetUpRec_exit;
   \   000000D6   0xE02D             B        ??FMSTR_SetUpRec_2
    344          #endif
    345                  }
    346          #endif /* FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY */
    347                  /* get compare function */
    348                  switch(pcm_nTrgVarSize)
   \                     ??FMSTR_SetUpRec_9: (+1)
   \   000000D8   0x78A0             LDRB     R0,[R4, #+2]
   \   000000DA   0x2801             CMP      R0,#+1
   \   000000DC   0xD004             BEQ      ??FMSTR_SetUpRec_10
   \   000000DE   0x2802             CMP      R0,#+2
   \   000000E0   0xD010             BEQ      ??FMSTR_SetUpRec_11
   \   000000E2   0x2804             CMP      R0,#+4
   \   000000E4   0xD015             BEQ      ??FMSTR_SetUpRec_12
   \   000000E6   0xE01B             B        ??FMSTR_SetUpRec_7
    349                  {
    350          #if FMSTR_CFG_BUS_WIDTH == 1U
    351                  case 1: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare8S : FMSTR_Compare8U; break;
   \                     ??FMSTR_SetUpRec_10: (+1)
   \   000000E8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD008             BEQ      ??FMSTR_SetUpRec_13
   \   000000EE   0x....             LDR      R0,??DataTable14
   \                     ??FMSTR_SetUpRec_14: (+1)
   \   000000F0   0x6520             STR      R0,[R4, #+80]
    352          #endif
    353                  case 2: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare16S : FMSTR_Compare16U; break;
    354                  case 4: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare32S : FMSTR_Compare32U; break;
    355                  
    356                  /* invalid trigger variable size  */
    357                  default:
    358          #if FMSTR_REC_COMMON_ERR_CODES
    359                      goto FMSTR_SetUpRec_exit_error;
    360          #else
    361                      nResponseCode = FMSTR_STC_INVSIZE;
    362                      goto FMSTR_SetUpRec_exit;
    363          #endif
    364                  }
    365              }
    366          #endif /* (FMSTR_USE_FASTREC) == 0 */
    367              
    368              /* total recorder buffer length in native sizeof units (=bytes on most platforms) */
    369              blen = (FMSTR_SIZE) (pcm_wRecTotalSmps * nRecVarsetSize / FMSTR_CFG_BUS_WIDTH);
   \                     ??FMSTR_SetUpRec_8: (+1)
   \   000000F2   0x8AA0             LDRH     R0,[R4, #+20]
   \   000000F4   0x4345             MULS     R5,R0,R5
   \   000000F6   0xB2AD             UXTH     R5,R5
    370          
    371              /* recorder memory available? */
    372              if(blen > FMSTR_GetRecBuffSize())
   \   000000F8   0x....             LDR      R0,??DataTable14_1  ;; 0x1001
   \   000000FA   0x4285             CMP      R5,R0
   \   000000FC   0xDB12             BLT      ??FMSTR_SetUpRec_15
    373              {
    374          #if FMSTR_REC_COMMON_ERR_CODES
    375                  goto FMSTR_SetUpRec_exit_error;
    376          #else
    377                  nResponseCode = FMSTR_STC_INVSIZE;
   \   000000FE   0xE00F             B.N      ??FMSTR_SetUpRec_7
    378                  goto FMSTR_SetUpRec_exit;
    379          #endif
    380              }
   \                     ??FMSTR_SetUpRec_13: (+1)
   \   00000100   0x....             LDR      R0,??DataTable15
   \   00000102   0xE7F5             B        ??FMSTR_SetUpRec_14
   \                     ??FMSTR_SetUpRec_11: (+1)
   \   00000104   0x78E0             LDRB     R0,[R4, #+3]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD001             BEQ      ??FMSTR_SetUpRec_16
   \   0000010A   0x....             LDR      R0,??DataTable15_1
   \   0000010C   0xE7F0             B        ??FMSTR_SetUpRec_14
   \                     ??FMSTR_SetUpRec_16: (+1)
   \   0000010E   0x....             LDR      R0,??DataTable15_2
   \   00000110   0xE7EE             B        ??FMSTR_SetUpRec_14
   \                     ??FMSTR_SetUpRec_12: (+1)
   \   00000112   0x78E0             LDRB     R0,[R4, #+3]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD001             BEQ      ??FMSTR_SetUpRec_17
   \   00000118   0x....             LDR      R0,??DataTable15_3
   \   0000011A   0xE7E9             B        ??FMSTR_SetUpRec_14
   \                     ??FMSTR_SetUpRec_17: (+1)
   \   0000011C   0x....             LDR      R0,??DataTable15_4
   \   0000011E   0xE7E7             B        ??FMSTR_SetUpRec_14
   \                     ??FMSTR_SetUpRec_7: (+1)
   \   00000120   0x2086             MOVS     R0,#+134
   \   00000122   0xE007             B        ??FMSTR_SetUpRec_2
    381          
    382          #if (FMSTR_USE_FASTREC) == 0
    383              /* remember the effective end of circular buffer */
    384              pcm_dwRecEndBuffPtr = pcm_nRecBuffAddr + blen;
   \                     ??FMSTR_SetUpRec_15: (+1)
   \   00000124   0x6CE0             LDR      R0,[R4, #+76]
   \   00000126   0x1940             ADDS     R0,R0,R5
   \   00000128   0x6460             STR      R0,[R4, #+68]
    385          #endif /* (FMSTR_USE_FASTREC) == 0 */
    386          
    387          #if FMSTR_USE_FASTREC
    388              if(!FMSTR_SetUpFastRec())
    389              {
    390          #if FMSTR_REC_COMMON_ERR_CODES
    391                  goto FMSTR_SetUpRec_exit_error;
    392          #else /* FMSTR_REC_COMMON_ERR_CODES */
    393                  nResponseCode = FMSTR_STC_FASTRECERR;
    394                  goto FMSTR_SetUpRec_exit;
    395          #endif /* FMSTR_REC_COMMON_ERR_CODES */
    396              }
    397          #endif /* FMSTR_USE_FASTREC */
    398          
    399              /* everything is okay    */
    400              pcm_wRecFlags.flg.bIsConfigured = 1U;
   \   0000012A   0x68E0             LDR      R0,[R4, #+12]
   \   0000012C   0x2101             MOVS     R1,#+1
   \   0000012E   0x4301             ORRS     R1,R1,R0
   \   00000130   0x60E1             STR      R1,[R4, #+12]
    401              nResponseCode = FMSTR_STS_OK;
   \   00000132   0x2000             MOVS     R0,#+0
    402          #if FMSTR_REC_COMMON_ERR_CODES
    403              goto FMSTR_SetUpRec_exit;
    404          FMSTR_SetUpRec_exit_error:
    405              nResponseCode = FMSTR_STC_INVSIZE;
    406          #endif
    407          FMSTR_SetUpRec_exit:
    408              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_SetUpRec_2: (+1)
   \   00000134   0x9903             LDR      R1,[SP, #+12]
   \   00000136   0x7008             STRB     R0,[R1, #+0]
   \   00000138   0x9803             LDR      R0,[SP, #+12]
   \   0000013A   0x1C40             ADDS     R0,R0,#+1
   \   0000013C   0xB005             ADD      SP,SP,#+20
   \   0000013E   0xBDF0             POP      {R4-R7,PC}       ;; return
    409          }
    410          
    411          /**************************************************************************//*!
    412          *
    413          * @brief    API: Pull the trigger of the recorder
    414          *
    415          * This function starts the post-trigger stop countdown
    416          *
    417          ******************************************************************************/
    418          

   \                                 In section .text, align 2, keep-with-next
    419          void FMSTR_TriggerRec(void)
    420          {
    421              if(!pcm_wRecFlags.flg.bIsStopping)
   \                     FMSTR_TriggerRec: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x074A             LSLS     R2,R1,#+29
   \   00000006   0x0FD2             LSRS     R2,R2,#+31
   \   00000008   0xD105             BNE      ??FMSTR_TriggerRec_0
    422              {
    423                  pcm_wRecFlags.flg.bIsStopping = 1U;
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x60C2             STR      R2,[R0, #+12]
    424          #if (FMSTR_REC_STATIC_POSTTRIG) == 0
    425                  pcm_wStoprecCountDown = pcm_wRecPostTrigger;
   \   00000012   0x8AC1             LDRH     R1,[R0, #+22]
   \   00000014   0x8381             STRH     R1,[R0, #+28]
    426          #else
    427                  pcm_wStoprecCountDown = FMSTR_REC_STATIC_POSTTRIG;
    428          #endif
    429              }
    430          }
   \                     ??FMSTR_TriggerRec_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    431          
    432          /**************************************************************************//*!
    433          *
    434          * @brief    Handling STARTREC command
    435          *
    436          * @param    pMessageIO - original command (in) and response buffer (out) 
    437          *
    438          * @return   As all command handlers, the return value should be the length
    439          *           of the response filled into the buffer (including status byte)
    440          *
    441          * This function starts recording (initializes internal recording variables 
    442          * and flags)
    443          *
    444          ******************************************************************************/
    445          

   \                                 In section .text, align 2, keep-with-next
    446          FMSTR_BPTR FMSTR_StartRec(FMSTR_BPTR pMessageIO)
    447          {
   \                     FMSTR_StartRec: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    448               FMSTR_U8 nResponseCode;   
    449              /* must be configured */
    450              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x....             LDR      R1,??DataTable12
   \   00000006   0x68CB             LDR      R3,[R1, #+12]
   \   00000008   0x4013             ANDS     R3,R3,R2
   \   0000000A   0xD101             BNE      ??FMSTR_StartRec_0
    451              {
    452          #if FMSTR_REC_COMMON_ERR_CODES
    453                  goto FMSTR_StartRec_exit_error;
    454          #else
    455                  nResponseCode = FMSTR_STC_NOTINIT;
   \   0000000C   0x2288             MOVS     R2,#+136
    456                  goto FMSTR_StartRec_exit;
   \   0000000E   0xE018             B        ??FMSTR_StartRec_1
    457          #endif
    458              }
    459                  
    460              /* already running ? */
    461              if(pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_StartRec_0: (+1)
   \   00000010   0x68CB             LDR      R3,[R1, #+12]
   \   00000012   0x085B             LSRS     R3,R3,#+1
   \   00000014   0x4013             ANDS     R3,R3,R2
   \   00000016   0xD114             BNE      ??FMSTR_StartRec_1
    462              {
    463          #if FMSTR_REC_COMMON_ERR_CODES
    464                  goto FMSTR_StartRec_exit_error;
    465          #else
    466                  nResponseCode = FMSTR_STS_RECRUN;
    467                  goto FMSTR_StartRec_exit;
    468          #endif
    469              }
    470          
    471          #if (FMSTR_USE_FASTREC) == 0
    472              /* initialize write pointer */
    473              pcm_dwRecWritePtr = pcm_nRecBuffAddr;
   \   00000018   0x6CCA             LDR      R2,[R1, #+76]
   \   0000001A   0x640A             STR      R2,[R1, #+64]
    474          
    475              /* current (first) sample index */
    476              pcm_wRecBuffStartIx = 0U;
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x83CA             STRH     R2,[R1, #+30]
    477          #endif /* (FMSTR_USE_FASTREC) == 0 */
    478          
    479              /* initialize time divisor */
    480          #if (FMSTR_REC_STATIC_DIVISOR) != 1
    481              pcm_wRecTimeDivCtr = 0U;
   \   00000020   0x834A             STRH     R2,[R1, #+26]
    482          #endif
    483          
    484              /* initiate virgin cycle */
    485              pcm_wRecFlags.flg.bIsStopping = 0U;          /* no trigger active */
   \   00000022   0x68CB             LDR      R3,[R1, #+12]
   \   00000024   0x2404             MOVS     R4,#+4
   \   00000026   0x43A3             BICS     R3,R3,R4
   \   00000028   0x60CB             STR      R3,[R1, #+12]
    486              pcm_wRecFlags.flg.bTrgCrossActive = 0U;      /* waiting for threshold crossing */
   \   0000002A   0x68CB             LDR      R3,[R1, #+12]
   \   0000002C   0x2410             MOVS     R4,#+16
   \   0000002E   0x43A3             BICS     R3,R3,R4
   \   00000030   0x60CB             STR      R3,[R1, #+12]
    487              pcm_wRecFlags.flg.bInvirginCycle = 1U;       /* initial cycle */
   \   00000032   0x68CB             LDR      R3,[R1, #+12]
   \   00000034   0x2408             MOVS     R4,#+8
   \   00000036   0x431C             ORRS     R4,R4,R3
   \   00000038   0x60CC             STR      R4,[R1, #+12]
    488              /* run now */
    489          
    490              /* start fast recorder */
    491          #if FMSTR_USE_FASTREC
    492              FMSTR_StartFastRec();
    493          #endif /* (MSTR_USE_FASTREC */
    494          
    495              /* run now */
    496              pcm_wRecFlags.flg.bIsRunning = 1U;           /* is running now! */
   \   0000003A   0x68CB             LDR      R3,[R1, #+12]
   \   0000003C   0x2402             MOVS     R4,#+2
   \   0000003E   0x431C             ORRS     R4,R4,R3
   \   00000040   0x60CC             STR      R4,[R1, #+12]
    497          
    498              nResponseCode = FMSTR_STS_OK;
    499          #if FMSTR_REC_COMMON_ERR_CODES
    500              goto FMSTR_StartRec_exit;
    501          FMSTR_StartRec_exit_error:
    502              nResponseCode = FMSTR_STC_NOTINIT;
    503          #endif
    504          
    505          FMSTR_StartRec_exit:
    506              return FMSTR_ConstToBuffer8(pMessageIO, nResponseCode);
   \                     ??FMSTR_StartRec_1: (+1)
   \   00000042   0x7002             STRB     R2,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0xBC12             POP      {R1,R4}
   \   00000048   0x4770             BX       LR               ;; return
    507          }
    508          
    509          /**************************************************************************//*!
    510          *
    511          * @brief    Handling STOPREC command
    512          *
    513          * @param    pMessageIO - original command (in) and response buffer (out) 
    514          *
    515          * @return   As all command handlers, the return value should be the length
    516          *           of the response filled into the buffer (including status byte)
    517          *
    518          * This function stops recording (same as manual trigger)
    519          *
    520          ******************************************************************************/
    521          

   \                                 In section .text, align 2, keep-with-next
    522          FMSTR_BPTR FMSTR_StopRec(FMSTR_BPTR pMessageIO)
    523          {
    524              FMSTR_U8 nResponseCode;
    525              /* must be configured */
    526              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     FMSTR_StopRec: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x....             LDR      R1,??DataTable12
   \   00000004   0x68CB             LDR      R3,[R1, #+12]
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0xD101             BNE      ??FMSTR_StopRec_0
    527              {
    528                  nResponseCode = FMSTR_STC_NOTINIT;
   \   0000000A   0x2188             MOVS     R1,#+136
    529                  goto FMSTR_StopRec_exit;
   \   0000000C   0xE010             B        ??FMSTR_StopRec_1
    530              }
    531                  
    532              /* already stopped ? */
    533              if(!pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_StopRec_0: (+1)
   \   0000000E   0x68CB             LDR      R3,[R1, #+12]
   \   00000010   0x085B             LSRS     R3,R3,#+1
   \   00000012   0x4013             ANDS     R3,R3,R2
   \   00000014   0xD101             BNE      ??FMSTR_StopRec_2
    534              {
    535                  nResponseCode = FMSTR_STS_RECDONE;
   \   00000016   0x2102             MOVS     R1,#+2
    536                  goto FMSTR_StopRec_exit;
   \   00000018   0xE00A             B        ??FMSTR_StopRec_1
    537              }
    538              
    539              /* simulate trigger */
    540              FMSTR_TriggerRec();
   \                     ??FMSTR_StopRec_2: (+1)
   \   0000001A   0x68CB             LDR      R3,[R1, #+12]
   \   0000001C   0x089B             LSRS     R3,R3,#+2
   \   0000001E   0x401A             ANDS     R2,R2,R3
   \   00000020   0xD105             BNE      ??FMSTR_StopRec_3
   \   00000022   0x68CA             LDR      R2,[R1, #+12]
   \   00000024   0x2304             MOVS     R3,#+4
   \   00000026   0x4313             ORRS     R3,R3,R2
   \   00000028   0x60CB             STR      R3,[R1, #+12]
   \   0000002A   0x8ACA             LDRH     R2,[R1, #+22]
   \   0000002C   0x838A             STRH     R2,[R1, #+28]
    541              nResponseCode = FMSTR_STS_OK;
   \                     ??FMSTR_StopRec_3: (+1)
   \   0000002E   0x2100             MOVS     R1,#+0
    542              
    543          FMSTR_StopRec_exit:
    544              return FMSTR_ConstToBuffer8(pMessageIO, nResponseCode);
   \                     ??FMSTR_StopRec_1: (+1)
   \   00000030   0x7001             STRB     R1,[R0, #+0]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x4770             BX       LR               ;; return
    545          }
    546          
    547          /**************************************************************************//*!
    548          *
    549          * @brief    Handling GETRECSTS command
    550          *
    551          * @param    pMessageIO - original command (in) and response buffer (out) 
    552          *
    553          * @return   As all command handlers, the return value should be the buffer 
    554          *           pointer where the response output finished (except checksum)
    555          *
    556          * This function returns current recorder status
    557          *
    558          ******************************************************************************/
    559          

   \                                 In section .text, align 2, keep-with-next
    560          FMSTR_BPTR FMSTR_GetRecStatus(FMSTR_BPTR pMessageIO)
    561          {
    562              FMSTR_U16 nResponseCode = (FMSTR_U16) (pcm_wRecFlags.flg.bIsRunning ? 
    563                  FMSTR_STS_RECRUN : FMSTR_STS_RECDONE);
   \                     FMSTR_GetRecStatus: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR      R2,??DataTable12
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0x085B             LSRS     R3,R3,#+1
   \   00000008   0x400B             ANDS     R3,R3,R1
   \   0000000A   0xD100             BNE      ??FMSTR_GetRecStatus_0
   \   0000000C   0x2302             MOVS     R3,#+2
    564              
    565              /* must be configured */
    566              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     ??FMSTR_GetRecStatus_0: (+1)
   \   0000000E   0x68D2             LDR      R2,[R2, #+12]
   \   00000010   0x4011             ANDS     R1,R1,R2
   \   00000012   0xD100             BNE      ??FMSTR_GetRecStatus_1
    567              {
    568                  nResponseCode = FMSTR_STC_NOTINIT;
   \   00000014   0x2388             MOVS     R3,#+136
    569              }
    570                  
    571              /* get run/stop status */
    572              return FMSTR_ConstToBuffer8(pMessageIO, (FMSTR_U8) nResponseCode);
   \                     ??FMSTR_GetRecStatus_1: (+1)
   \   00000016   0x7003             STRB     R3,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x4770             BX       LR               ;; return
    573          }
    574          
    575          /* now follows the recorder only routines, skip that if FastRecorder is used */
    576          #if (FMSTR_USE_FASTREC) == 0
    577          
    578          /**************************************************************************//*!
    579          *
    580          * @brief    Get recorder memory size 
    581          *
    582          * @return   Recorder memory size in native sizeof units (=bytes on most platforms)
    583          *
    584          ******************************************************************************/
    585          

   \                                 In section .text, align 2, keep-with-next
    586          FMSTR_SIZE FMSTR_GetRecBuffSize()
    587          {
    588          #if FMSTR_REC_OWNBUFF
    589              return pcm_wRecBuffSize;
    590          #else
    591              return (FMSTR_SIZE) FMSTR_REC_BUFF_SIZE;
   \                     FMSTR_GetRecBuffSize: (+1)
   \   00000000   0x2080             MOVS     R0,#+128
   \   00000002   0x0140             LSLS     R0,R0,#+5        ;; #+4096
   \   00000004   0x4770             BX       LR               ;; return
    592          #endif
    593          }
    594          
    595          /**************************************************************************//*!
    596          *
    597          * @brief    Check wether given memory region is inside the recorder buffer
    598          *
    599          * @param    dwAddr - address of the memory to be checked
    600          * @param    wSize  - size of the memory to be checked
    601          *
    602          * @return   This function returns non-zero if user space is in recorder buffer
    603          *
    604          * This function is called as a pert of TSA-checking process when the PC host
    605          * is requesting memory contents
    606          *
    607          ******************************************************************************/
    608          

   \                                 In section .text, align 2, keep-with-next
    609          FMSTR_BOOL FMSTR_IsInRecBuffer(FMSTR_ADDR dwAddr, FMSTR_SIZE8 nSize)
    610          {
   \                     FMSTR_IsInRecBuffer: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x0002             MOVS     R2,R0
    611              FMSTR_BOOL bRet = 0U;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR      R3,??DataTable12
   \   00000008   0x6CDB             LDR      R3,[R3, #+76]
   \   0000000A   0x429A             CMP      R2,R3
   \   0000000C   0xD306             BCC      ??FMSTR_IsInRecBuffer_0
    612              
    613              if(dwAddr >= pcm_nRecBuffAddr)
    614              {
    615                  bRet = (FMSTR_BOOL)((dwAddr + nSize) <= (pcm_nRecBuffAddr + FMSTR_GetRecBuffSize()) ? FMSTR_TRUE : FMSTR_FALSE);    
   \   0000000E   0x2480             MOVS     R4,#+128
   \   00000010   0x0164             LSLS     R4,R4,#+5        ;; #+4096
   \   00000012   0x191B             ADDS     R3,R3,R4
   \   00000014   0x1851             ADDS     R1,R2,R1
   \   00000016   0x428B             CMP      R3,R1
   \   00000018   0xD300             BCC      ??FMSTR_IsInRecBuffer_0
   \   0000001A   0x2001             MOVS     R0,#+1
    616              }
    617              
    618              return bRet;
   \                     ??FMSTR_IsInRecBuffer_0: (+1)
   \   0000001C   0xBC12             POP      {R1,R4}
   \   0000001E   0x4770             BX       LR               ;; return
    619          }
    620          
    621          
    622          /**************************************************************************//*!
    623          *
    624          * @brief    Handling GETRECBUFF and GETRECBUFF_EX command
    625          *
    626          * @param    pMessageIO - original command (in) and response buffer (out) 
    627          *
    628          * @return   As all command handlers, the return value should be the buffer 
    629          *           pointer where the response output finished (except checksum)
    630          *
    631          * This function returns recorder buffer information
    632          *
    633          ******************************************************************************/
    634          

   \                                 In section .text, align 2, keep-with-next
    635          FMSTR_BPTR FMSTR_GetRecBuff(FMSTR_BPTR pMessageIO)
    636          {
   \                     FMSTR_GetRecBuff: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    637              /* must be configured */
    638              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x....             LDR      R4,??DataTable12
   \   00000006   0x68E2             LDR      R2,[R4, #+12]
   \   00000008   0x400A             ANDS     R2,R2,R1
   \   0000000A   0xD101             BNE      ??FMSTR_GetRecBuff_0
    639              {
    640                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_NOTINIT);
   \   0000000C   0x2188             MOVS     R1,#+136
   \   0000000E   0xE004             B.N      ??FMSTR_GetRecBuff_1
    641              }
    642              
    643              /* must be stopped */
    644              if(pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_GetRecBuff_0: (+1)
   \   00000010   0x68E2             LDR      R2,[R4, #+12]
   \   00000012   0x0852             LSRS     R2,R2,#+1
   \   00000014   0x4011             ANDS     R1,R1,R2
   \   00000016   0xD003             BEQ      ??FMSTR_GetRecBuff_2
    645              {
    646                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_SERVBUSY);
   \   00000018   0x2187             MOVS     R1,#+135
   \                     ??FMSTR_GetRecBuff_1: (+1)
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0xBD10             POP      {R4,PC}
    647              }
    648              
    649              /* fill the return info */
    650              pMessageIO = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STS_OK);
   \                     ??FMSTR_GetRecBuff_2: (+1)
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
    651              pMessageIO = FMSTR_AddressToBuffer(pMessageIO, pcm_nRecBuffAddr);
   \   00000024   0x6CE1             LDR      R1,[R4, #+76]
   \   00000026   0x.... 0x....      BL       FMSTR_AddressToBuffer
    652              return FMSTR_ValueToBuffer16(pMessageIO, pcm_wRecBuffStartIx);
   \   0000002A   0x8BE1             LDRH     R1,[R4, #+30]
   \   0000002C   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    653          }
    654          
    655          /**************************************************************************//*!
    656          *
    657          * @brief    Compare macro used in trigger detection
    658          *
    659          * @param    v - original command 
    660          * @param    t - response buffer
    661          *
    662          * @return   zero when value is lower than threshold.
    663          * @return   non-zero when value is greater than or equal as treshold
    664          *
    665          ******************************************************************************/
    666          
    667          #define CMP(v,t) ((FMSTR_BOOL)(((v) < (t)) ? 0 : 1))
    668          
    669          #if FMSTR_CFG_BUS_WIDTH == 1U
    670          

   \                                 In section .text, align 2, keep-with-next
    671          static FMSTR_BOOL FMSTR_Compare8S()
    672          {
    673              return CMP(FMSTR_GetS8(pcm_nTrgVarAddr), pcm_uTrgThreshold.s8);
   \                     FMSTR_Compare8S: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x5689             LDRSB    R1,[R1, R2]
   \   00000008   0x2210             MOVS     R2,#+16
   \   0000000A   0x5680             LDRSB    R0,[R0, R2]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xDA01             BGE      ??FMSTR_Compare8S_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??FMSTR_Compare8S_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    674          }
    675          

   \                                 In section .text, align 2, keep-with-next
    676          static FMSTR_BOOL FMSTR_Compare8U()
    677          {
    678              return CMP(FMSTR_GetU8(pcm_nTrgVarAddr), pcm_uTrgThreshold.u8);
   \                     FMSTR_Compare8U: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x7C02             LDRB     R2,[R0, #+16]
   \   00000008   0x....             B.N      ?Subroutine0
    679          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4291             CMP      R1,R2
   \                     ??Subroutine0_0: (+1)
   \   00000002   0x4180             SBCS     R0,R0,R0
   \   00000004   0x43C0             MVNS     R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
   \   00000008   0x4770             BX       LR               ;; return
    680          
    681          #endif
    682          

   \                                 In section .text, align 2, keep-with-next
    683          static FMSTR_BOOL FMSTR_Compare16S()
    684          {
    685              return CMP(FMSTR_GetS16(pcm_nTrgVarAddr), pcm_uTrgThreshold.s16);
   \                     FMSTR_Compare16S: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x5E89             LDRSH    R1,[R1, R2]
   \   00000008   0x2210             MOVS     R2,#+16
   \   0000000A   0x5E80             LDRSH    R0,[R0, R2]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xDA01             BGE      ??FMSTR_Compare16S_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??FMSTR_Compare16S_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    686          }
    687          

   \                                 In section .text, align 2, keep-with-next
    688          static FMSTR_BOOL FMSTR_Compare16U()
    689          {
    690              return CMP(FMSTR_GetU16(pcm_nTrgVarAddr), pcm_uTrgThreshold.u16);
   \                     FMSTR_Compare16U: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x8809             LDRH     R1,[R1, #+0]
   \   00000006   0x8A02             LDRH     R2,[R0, #+16]
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    691          }
    692          

   \                                 In section .text, align 2, keep-with-next
    693          static FMSTR_BOOL FMSTR_Compare32S()
    694          {
    695              return CMP(FMSTR_GetS32(pcm_nTrgVarAddr), pcm_uTrgThreshold.s32);
   \                     FMSTR_Compare32S: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xDA01             BGE      ??FMSTR_Compare32S_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
   \                     ??FMSTR_Compare32S_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
    696          }
    697          

   \                                 In section .text, align 2, keep-with-next
    698          static FMSTR_BOOL FMSTR_Compare32U()
    699          {
    700              return CMP(FMSTR_GetU32(pcm_nTrgVarAddr), pcm_uTrgThreshold.u32);
   \                     FMSTR_Compare32U: (+1)
   \   00000000   0x....             LDR      R0,??DataTable15_5
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x....             B.N      ??Subroutine0_0
    701          }
    702          
    703          /**************************************************************************//*!
    704          *
    705          * @brief    API: Recorder worker routine - can be called from application's Timer ISR
    706          *
    707          *
    708          * This returns quickly if recorder is not running, otherwise it calls quite lengthy 
    709          * recorder routine which does all the recorder work (sampling, triggering)
    710          *
    711          ******************************************************************************/
    712          
    713          #if defined(FMSTR_PLATFORM_56F8xxx) || defined(FMSTR_PLATFORM_56F8xx)
    714          #pragma interrupt called
    715          #endif
    716          

   \                                 In section .text, align 2, keep-with-next
    717          void FMSTR_Recorder(void)
    718          {
    719              /* recorder not active */
    720              if(!pcm_wRecFlags.flg.bIsRunning)
   \                     FMSTR_Recorder: (+1)
   \   00000000   0x....             LDR      R0,??DataTable15_5
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x0781             LSLS     R1,R0,#+30
   \   00000006   0x0FC9             LSRS     R1,R1,#+31
   \   00000008   0xD100             BNE      ??FMSTR_Recorder_0
   \   0000000A   0x4770             BX       LR
    721              {
    722                  return ;
    723              }
    724              
    725              /* do the hard work      */
    726              FMSTR_Recorder2();
   \                     ??FMSTR_Recorder_0: (+1)
   \   0000000C   0xB580             PUSH     {R7,LR}
   \   0000000E   0x.... 0x....      BL       FMSTR_Recorder2
    727          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    728          
    729          /**************************************************************************//*!
    730          *
    731          * @brief    Recorder function called when recorder is active
    732          *
    733          ******************************************************************************/
    734          
    735          #if defined(FMSTR_PLATFORM_56F8xxx) || defined(FMSTR_PLATFORM_56F8xx)
    736          #pragma interrupt called
    737          #endif
    738          

   \                                 In section .text, align 2, keep-with-next
    739          static void FMSTR_Recorder2(void)
    740          {
   \                     FMSTR_Recorder2: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    741              FMSTR_SIZE8 sz;
    742              FMSTR_BOOL cmp;
    743              FMSTR_U8 i;
    744          
    745          #if (FMSTR_REC_STATIC_DIVISOR) != 1
    746              /* skip this call ? */
    747              if(pcm_wRecTimeDivCtr)
   \   00000004   0x....             LDR      R4,??DataTable15_5
   \   00000006   0x8B60             LDRH     R0,[R4, #+26]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ      ??FMSTR_Recorder2_0
    748              {
    749                  /* maybe next time... */
    750                  pcm_wRecTimeDivCtr--;
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x8360             STRH     R0,[R4, #+26]
    751                  return;
   \   00000010   0xE061             B        ??FMSTR_Recorder2_1
    752              }
    753              
    754              /* re-initialize divider */
    755          #if (FMSTR_REC_STATIC_DIVISOR) == 0
    756              pcm_wRecTimeDivCtr = pcm_wRecTimeDiv;
   \                     ??FMSTR_Recorder2_0: (+1)
   \   00000012   0x8B20             LDRH     R0,[R4, #+24]
   \   00000014   0x8360             STRH     R0,[R4, #+26]
    757          #else 
    758              pcm_wRecTimeDivCtr = FMSTR_REC_STATIC_DIVISOR;
    759          #endif /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    760          #endif /* (FMSTR_REC_STATIC_DIVISOR) != 1 */
    761          
    762              /* take snapshot of variable values */
    763              for (i=0U; i<pcm_nRecVarCount; i++)
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0x2600             MOVS     R6,#+0
   \   0000001A   0x1D20             ADDS     R0,R4,#+4
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x3020             ADDS     R0,R0,#+32
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xE011             B        ??FMSTR_Recorder2_2
    764              {
    765                  sz = pcm_pRecVarSize[i];
   \                     ??FMSTR_Recorder2_3: (+1)
   \   00000026   0x9901             LDR      R1,[SP, #+4]
   \   00000028   0x780D             LDRB     R5,[R1, #+0]
    766                  FMSTR_CopyMemory(pcm_dwRecWritePtr, pcm_pRecVarAddr[i], sz);
   \   0000002A   0x002A             MOVS     R2,R5
   \   0000002C   0x9900             LDR      R1,[SP, #+0]
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x.... 0x....      BL       FMSTR_CopyMemory
    767                  sz /= FMSTR_CFG_BUS_WIDTH;
    768                  pcm_dwRecWritePtr += sz;
   \   00000034   0x6C20             LDR      R0,[R4, #+64]
   \   00000036   0x1940             ADDS     R0,R0,R5
   \   00000038   0x6420             STR      R0,[R4, #+64]
    769              }
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \   0000003C   0xB2F6             UXTB     R6,R6
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x1D00             ADDS     R0,R0,#+4
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x9801             LDR      R0,[SP, #+4]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \                     ??FMSTR_Recorder2_2: (+1)
   \   0000004A   0x6C20             LDR      R0,[R4, #+64]
   \   0000004C   0x7861             LDRB     R1,[R4, #+1]
   \   0000004E   0x428E             CMP      R6,R1
   \   00000050   0xDBE9             BLT      ??FMSTR_Recorder2_3
    770              
    771              /* another sample taken (startIx "points" after sample just taken) */
    772              /* i.e. it points to the oldest sample */
    773              pcm_wRecBuffStartIx++;
   \   00000052   0x8BE1             LDRH     R1,[R4, #+30]
   \   00000054   0x1C49             ADDS     R1,R1,#+1
   \   00000056   0x83E1             STRH     R1,[R4, #+30]
    774              
    775              /* wrap around (circular buffer) ? */
    776              if(pcm_dwRecWritePtr >= pcm_dwRecEndBuffPtr)
   \   00000058   0x6C61             LDR      R1,[R4, #+68]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD306             BCC      ??FMSTR_Recorder2_4
    777              {   
    778                  pcm_dwRecWritePtr = pcm_nRecBuffAddr;
   \   0000005E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000060   0x6420             STR      R0,[R4, #+64]
    779                  pcm_wRecFlags.flg.bInvirginCycle = 0U;
   \   00000062   0x68E0             LDR      R0,[R4, #+12]
   \   00000064   0x2108             MOVS     R1,#+8
   \   00000066   0x4388             BICS     R0,R0,R1
   \   00000068   0x60E0             STR      R0,[R4, #+12]
    780                  pcm_wRecBuffStartIx = 0U;
   \   0000006A   0x83E7             STRH     R7,[R4, #+30]
    781              }
    782          
    783              /* no trigger testing in virgin cycle */
    784              if(pcm_wRecFlags.flg.bInvirginCycle)
   \                     ??FMSTR_Recorder2_4: (+1)
   \   0000006C   0x2501             MOVS     R5,#+1
   \   0000006E   0x68E0             LDR      R0,[R4, #+12]
   \   00000070   0x08C0             LSRS     R0,R0,#+3
   \   00000072   0x4028             ANDS     R0,R0,R5
   \   00000074   0xD12F             BNE      ??FMSTR_Recorder2_1
    785              {
    786                  return;
    787              }
    788              
    789              /* test trigger condition if still running */
    790              if(!pcm_wRecFlags.flg.bIsStopping && pcm_pCompareFunc != NULL)
   \   00000076   0x68E0             LDR      R0,[R4, #+12]
   \   00000078   0x0880             LSRS     R0,R0,#+2
   \   0000007A   0x4028             ANDS     R0,R0,R5
   \   0000007C   0xD10C             BNE      ??FMSTR_Recorder2_5
   \   0000007E   0x6D20             LDR      R0,[R4, #+80]
   \   00000080   0x0001             MOVS     R1,R0
   \   00000082   0xD009             BEQ      ??FMSTR_Recorder2_5
    791              {
    792                  /* compare trigger threshold */
    793                  cmp = pcm_pCompareFunc();
   \   00000084   0x4780             BLX      R0
    794                  
    795                  /* negated logic (falling-edge) ? */
    796                  if(pcm_nRecTriggerMode == 2U)
   \   00000086   0x7821             LDRB     R1,[R4, #+0]
   \   00000088   0x2902             CMP      R1,#+2
   \   0000008A   0xD111             BNE      ??FMSTR_Recorder2_6
    797                  {
    798                      cmp = (FMSTR_BOOL) !cmp;
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD011             BEQ      ??FMSTR_Recorder2_7
    799                  }
    800                  
    801                  /* above threshold ? */
    802                  if(cmp)
    803                  {
    804                      /* were we at least once below threshold ? */
    805                      if(pcm_wRecFlags.flg.bTrgCrossActive)
    806                      {
    807                          /* EDGE TRIGGER ! */
    808                          FMSTR_TriggerRec();
    809                      }
    810                  }
    811                  else
    812                  {
    813                      /* we got bellow threshold, now wait for being above threshold */
    814                      pcm_wRecFlags.flg.bTrgCrossActive = 1U;
   \                     ??FMSTR_Recorder2_8: (+1)
   \   00000090   0x68E0             LDR      R0,[R4, #+12]
   \   00000092   0x2110             MOVS     R1,#+16
   \   00000094   0x4301             ORRS     R1,R1,R0
   \   00000096   0x60E1             STR      R1,[R4, #+12]
    815                  }
    816              }
    817              
    818              /* in stopping mode ? (note that this bit might have been set just above!) */
    819              if(pcm_wRecFlags.flg.bIsStopping)
   \                     ??FMSTR_Recorder2_5: (+1)
   \   00000098   0x68E0             LDR      R0,[R4, #+12]
   \   0000009A   0x0880             LSRS     R0,R0,#+2
   \   0000009C   0x4005             ANDS     R5,R5,R0
   \   0000009E   0xD01A             BEQ      ??FMSTR_Recorder2_1
    820              {
    821                  /* count down post-trigger samples expired ? */
    822                  if(!pcm_wStoprecCountDown)
   \   000000A0   0x8BA0             LDRH     R0,[R4, #+28]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD115             BNE      ??FMSTR_Recorder2_9
    823                  {
    824                      /* STOP RECORDER */
    825                      pcm_wRecFlags.flg.bIsRunning = 0U;
   \   000000A6   0x68E0             LDR      R0,[R4, #+12]
   \   000000A8   0x2102             MOVS     R1,#+2
   \   000000AA   0x4388             BICS     R0,R0,R1
   \   000000AC   0x60E0             STR      R0,[R4, #+12]
    826                      return;
   \   000000AE   0xE012             B        ??FMSTR_Recorder2_1
    827                  }
   \                     ??FMSTR_Recorder2_6: (+1)
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD0ED             BEQ      ??FMSTR_Recorder2_8
   \                     ??FMSTR_Recorder2_7: (+1)
   \   000000B4   0x68E0             LDR      R0,[R4, #+12]
   \   000000B6   0x0900             LSRS     R0,R0,#+4
   \   000000B8   0x4028             ANDS     R0,R0,R5
   \   000000BA   0xD0ED             BEQ      ??FMSTR_Recorder2_5
   \   000000BC   0x68E0             LDR      R0,[R4, #+12]
   \   000000BE   0x0880             LSRS     R0,R0,#+2
   \   000000C0   0x4028             ANDS     R0,R0,R5
   \   000000C2   0xD1E9             BNE      ??FMSTR_Recorder2_5
   \   000000C4   0x68E0             LDR      R0,[R4, #+12]
   \   000000C6   0x2104             MOVS     R1,#+4
   \   000000C8   0x4301             ORRS     R1,R1,R0
   \   000000CA   0x60E1             STR      R1,[R4, #+12]
   \   000000CC   0x8AE0             LDRH     R0,[R4, #+22]
   \   000000CE   0x83A0             STRH     R0,[R4, #+28]
   \   000000D0   0xE7E2             B        ??FMSTR_Recorder2_5
    828                  
    829                  /* perhaps next time */
    830                  pcm_wStoprecCountDown--;
   \                     ??FMSTR_Recorder2_9: (+1)
   \   000000D2   0x1E40             SUBS     R0,R0,#+1
   \   000000D4   0x83A0             STRH     R0,[R4, #+28]
    831              }
    832          }
   \                     ??FMSTR_Recorder2_1: (+1)
   \   000000D6   0xB003             ADD      SP,SP,#+12
   \   000000D8   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     pcm_nRecTriggerMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     FMSTR_Compare8S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x00001001         DC32     0x1001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     FMSTR_Compare8U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     FMSTR_Compare16S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     FMSTR_Compare16U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     FMSTR_Compare32S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     FMSTR_Compare32U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     pcm_nRecTriggerMode
    833          
    834          #endif /* (FMSTR_USE_FASTREC) == 0 */
    835          
    836          #else /* FMSTR_USE_RECORDER */
    837          
    838          /* use void recorder API functions */
    839          void FMSTR_Recorder(void) 
    840          { 
    841          }
    842          
    843          void FMSTR_TriggerRec(void) 
    844          { 
    845          }
    846          
    847          void FMSTR_SetUpRecBuff(FMSTR_ADDR pBuffer, FMSTR_SIZE wBuffSize) 
    848          { 
    849              FMSTR_UNUSED(pBuffer);
    850              FMSTR_UNUSED(wBuffSize);
    851          }
    852          
    853          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    854          
    855          #endif /* FMSTR_USE_RECORDER */
    856          
    857          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMSTR_Compare16S
       0   FMSTR_Compare16U
       0   FMSTR_Compare32S
       0   FMSTR_Compare32U
       0   FMSTR_Compare8S
       0   FMSTR_Compare8U
       8   FMSTR_GetRecBuff
         8   -> FMSTR_AddressToBuffer
         8   -> FMSTR_ValueToBuffer16
       0   FMSTR_GetRecBuffSize
       0   FMSTR_GetRecStatus
       0   FMSTR_InitRec
       8   FMSTR_IsInRecBuffer
       8   FMSTR_Recorder
         8   -> FMSTR_Recorder2
      32   FMSTR_Recorder2
        32   -- Indirect call
        32   -> FMSTR_CopyMemory
      40   FMSTR_SetUpRec
        40   -> FMSTR_AddressFromBuffer
        40   -> FMSTR_CheckTsaSpace
        40   -> FMSTR_ValueFromBuffer16
        40   -> FMSTR_ValueFromBuffer32
       0   FMSTR_SetUpRecBuff
       8   FMSTR_StartRec
       0   FMSTR_StopRec
       0   FMSTR_TriggerRec


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
      10  ?Subroutine0
      24  FMSTR_Compare16S
       8  FMSTR_Compare16U
      20  FMSTR_Compare32S
      12  FMSTR_Compare32U
      24  FMSTR_Compare8S
      10  FMSTR_Compare8U
      50  FMSTR_GetRecBuff
       6  FMSTR_GetRecBuffSize
      28  FMSTR_GetRecStatus
      14  FMSTR_InitRec
      32  FMSTR_IsInRecBuffer
      20  FMSTR_Recorder
     218  FMSTR_Recorder2
     320  FMSTR_SetUpRec
       6  FMSTR_SetUpRecBuff
      74  FMSTR_StartRec
      54  FMSTR_StopRec
      24  FMSTR_TriggerRec
    4180  pcm_nRecTriggerMode
          pcm_nRecVarCount
          pcm_nTrgVarSize
          pcm_bTrgVarSigned
          pcm_pRecVarSize
          pcm_wRecFlags
          pcm_uTrgThreshold
          pcm_wRecTotalSmps
          pcm_wRecPostTrigger
          pcm_wRecTimeDiv
          pcm_wRecTimeDivCtr
          pcm_wStoprecCountDown
          pcm_wRecBuffStartIx
          pcm_pRecVarAddr
          pcm_dwRecWritePtr
          pcm_dwRecEndBuffPtr
          pcm_nTrgVarAddr
          pcm_nRecBuffAddr
          pcm_pCompareFunc
          pcm_pOwnRecBuffer
       2  pcm_wRecBuffSize

 
 4 182 bytes in section .bss
   990 bytes in section .text
 
   990 bytes of CODE memory
 4 182 bytes of DATA memory

Errors: none
Warnings: none
