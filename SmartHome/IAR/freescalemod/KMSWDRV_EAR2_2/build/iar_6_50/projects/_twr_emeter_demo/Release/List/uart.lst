###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        30/Jan/2016  15:22:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\uart\uart.c
#    Command line =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\uart\uart.c
#        -D NDEBUG -lCN
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\
#        -o
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\
#        --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\common\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\drivers\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\freemaster\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\projects\_twr_emeter_demo\
#        -Oh --require_prototypes
#    List file    =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\uart.lst
#    Object file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\uart.o
#
###############################################################################

E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\drivers\uart\uart.c
      1          /*****************************************************************************
      2           * (c) Copyright 2010-2013, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      uart.c
      6           * @version   1.0.4.0
      7           * @date      May-14-2012
      8           * @brief     Universal Asynchronous Receiver/Transmitter (UART) driver source 
      9           *            code.
     10           ******************************************************************************/
     11          #include "common.h"
     12          #include "uart.h"
     13          
     14          /******************************************************************************
     15           * data type definitions                                                      *
     16           ******************************************************************************/

   \                                 In section .bss, align 4
     17          static UART_CALLBACK pCallbackUART0_UART1=NULL;
   \                     pCallbackUART0_UART1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     18          static UART_CALLBACK pCallbackUART2_UART3=NULL;
   \                     pCallbackUART2_UART3:
   \   00000000                      DS8 4
     19          
     20          /******************************************************************************
     21           * interrupt function prototypes                                              *
     22           ******************************************************************************/
     23          void UART0_UART1_isr (void);
     24          void UART2_UART3_isr (void);
     25          
     26          /******************************************************************************
     27           * Public function definitions                                                *
     28           ******************************************************************************/
     29          #pragma diag_suppress=Pa082

   \                                 In section .text, align 2, keep-with-next
     30          void UART_InstallCallbackUART0_UART1 (uint8 ip, UART_CALLBACK pCallback)
     31          {
     32            if (pCallback != NULL) 
   \                     UART_InstallCallbackUART0_UART1: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0xD010             BEQ      ??UART_InstallCallbackUART0_UART1_0
     33            { 
     34              pCallbackUART0_UART1 = pCallback; 
   \   00000004   0x....             LDR      R2,??DataTable4
   \   00000006   0x6011             STR      R1,[R2, #+0]
     35              NVIC_SetIsr(INT_SCI0_SCI1,ip);
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   0000000C   0x....             LDR      R2,??DataTable4_1  ;; 0xe000e280
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x430B             ORRS     R3,R3,R1
   \   00000012   0x6013             STR      R3,[R2, #+0]
   \   00000014   0x....             LDR      R2,??DataTable4_2  ;; 0xe000e100
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable5  ;; 0xe000e410
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0780             LSLS     R0,R0,#+30
   \   00000022   0x4310             ORRS     R0,R0,R2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     36            }
     37          }
   \                     ??UART_InstallCallbackUART0_UART1_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
     38          

   \                                 In section .text, align 2, keep-with-next
     39          void UART_InstallCallbackUART2_UART3 (uint8 ip, UART_CALLBACK pCallback)
     40          {
     41            if (pCallback != NULL) 
   \                     UART_InstallCallbackUART2_UART3: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0xD100             BNE      ??UART_InstallCallbackUART2_UART3_0
   \   00000004   0x4770             BX       LR
     42            { 
     43              NVIC_SetIsr(INT_SCI2_SCI3,ip);
   \                     ??UART_InstallCallbackUART2_UART3_0: (+1)
   \   00000006   0xB418             PUSH     {R3,R4}
   \   00000008   0x2280             MOVS     R2,#+128
   \   0000000A   0x0352             LSLS     R2,R2,#+13       ;; #+1048576
   \   0000000C   0x....             LDR      R3,??DataTable4_1  ;; 0xe000e280
   \   0000000E   0x681C             LDR      R4,[R3, #+0]
   \   00000010   0x4314             ORRS     R4,R4,R2
   \   00000012   0x601C             STR      R4,[R3, #+0]
   \   00000014   0x....             LDR      R3,??DataTable4_2  ;; 0xe000e100
   \   00000016   0x681C             LDR      R4,[R3, #+0]
   \   00000018   0x4322             ORRS     R2,R2,R4
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   \   0000001C   0x....             LDR      R2,??DataTable5_1  ;; 0xe000e414
   \   0000001E   0x6813             LDR      R3,[R2, #+0]
   \   00000020   0x0180             LSLS     R0,R0,#+6
   \   00000022   0x4318             ORRS     R0,R0,R3
   \   00000024   0x6010             STR      R0,[R2, #+0]
     44              pCallbackUART2_UART3 = pCallback; 
   \   00000026   0x....             LDR      R0,??DataTable5_2
   \   00000028   0x6001             STR      R1,[R0, #+0]
     45            }
     46          }
   \   0000002A   0xBC11             POP      {R0,R4}
   \   0000002C   0x4770             BX       LR               ;; return
     47          

   \                                 In section .text, align 2, keep-with-next
     48          void UART0_Init (tUART sci)
     49          {   
   \                     UART0_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
     50            UART0_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000002   0x....             LDR      R0,??DataTable5_3  ;; 0x4006a000
   \   00000004   0x....             B.N      ?Subroutine1
     51            UART0_BDH     = sci.BDH;
     52            UART0_BDL     = sci.BDL;
     53            UART0_C1      = sci.C1;
     54            UART0_S2      = sci.S2;
     55            UART0_C3      = sci.C3;
     56            UART0_MA1     = sci.MA1;
     57            UART0_MA2     = sci.MA2;
     58            UART0_C4      = sci.C4;
     59            UART0_C5      = sci.C5;
     60            UART0_C2      = sci.C2;                           /* enable uart operation  */
     61          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x78C1             LDRB     R1,[R0, #+3]
   \   00000002   0x22F3             MOVS     R2,#+243
   \   00000004   0x400A             ANDS     R2,R2,R1
   \   00000006   0x70C2             STRB     R2,[R0, #+3]
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x7849             LDRB     R1,[R1, #+1]
   \   00000012   0x7041             STRB     R1,[R0, #+1]
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x7889             LDRB     R1,[R1, #+2]
   \   00000018   0x7081             STRB     R1,[R0, #+2]
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x7909             LDRB     R1,[R1, #+4]
   \   0000001E   0x7141             STRB     R1,[R0, #+5]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x7949             LDRB     R1,[R1, #+5]
   \   00000024   0x7181             STRB     R1,[R0, #+6]
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x7989             LDRB     R1,[R1, #+6]
   \   0000002A   0x7201             STRB     R1,[R0, #+8]
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x79C9             LDRB     R1,[R1, #+7]
   \   00000030   0x7241             STRB     R1,[R0, #+9]
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x7A09             LDRB     R1,[R1, #+8]
   \   00000036   0x7281             STRB     R1,[R0, #+10]
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x7A49             LDRB     R1,[R1, #+9]
   \   0000003C   0x72C1             STRB     R1,[R0, #+11]
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x78C9             LDRB     R1,[R1, #+3]
   \   00000042   0x70C1             STRB     R1,[R0, #+3]
   \   00000044   0xB004             ADD      SP,SP,#+16
   \   00000046   0x4770             BX       LR               ;; return
     62          

   \                                 In section .text, align 2, keep-with-next
     63          void UART1_Init (tUART sci)
     64          {   
   \                     UART1_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB081             SUB      SP,SP,#+4
     65            UART1_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000004   0x....             LDR      R0,??DataTable5_4  ;; 0x4006b000
   \   00000006   0x....             B.N      ?Subroutine0
     66            UART1_BDH     = sci.BDH;
     67            UART1_BDL     = sci.BDL;
     68            UART1_C1      = sci.C1;
     69            UART1_S2      = sci.S2;
     70            UART1_C3      = sci.C3;
     71            UART1_MA1     = sci.MA1;
     72            UART1_MA2     = sci.MA2;
     73            UART1_C4      = sci.C4;
     74            UART1_C5      = sci.C5;
     75            UART1_C7816   = sci.C7816;
     76            UART1_IE7816  = sci.IE7816;
     77            UART1_IS7816  = sci.IS7816;
     78            if (sci.C7816 & UART_C7816_TTYPE_MASK) { UART1_WP7816T1= sci.WP7816T1; }
     79            else                                   { UART1_WP7816T0= sci.WP7816T0; }
     80            UART1_WN7816  = sci.WN7816;
     81            UART1_WF7816  = sci.WF7816;
     82            UART1_ET7816  = sci.ET7816;
     83            UART1_TL7816  = sci.TL7816;
     84            UART1_C2      = sci.C2;                            /* enable uart operation */  
     85          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x78C1             LDRB     R1,[R0, #+3]
   \   00000002   0x22F3             MOVS     R2,#+243
   \   00000004   0x400A             ANDS     R2,R2,R1
   \   00000006   0x70C2             STRB     R2,[R0, #+3]
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7909             LDRB     R1,[R1, #+4]
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   \   0000000E   0xA901             ADD      R1,SP,#+4
   \   00000010   0x7849             LDRB     R1,[R1, #+1]
   \   00000012   0x7041             STRB     R1,[R0, #+1]
   \   00000014   0xA901             ADD      R1,SP,#+4
   \   00000016   0x7889             LDRB     R1,[R1, #+2]
   \   00000018   0x7081             STRB     R1,[R0, #+2]
   \   0000001A   0xA901             ADD      R1,SP,#+4
   \   0000001C   0x7909             LDRB     R1,[R1, #+4]
   \   0000001E   0x7141             STRB     R1,[R0, #+5]
   \   00000020   0xA901             ADD      R1,SP,#+4
   \   00000022   0x7949             LDRB     R1,[R1, #+5]
   \   00000024   0x7181             STRB     R1,[R0, #+6]
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x7989             LDRB     R1,[R1, #+6]
   \   0000002A   0x7201             STRB     R1,[R0, #+8]
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0x79C9             LDRB     R1,[R1, #+7]
   \   00000030   0x7241             STRB     R1,[R0, #+9]
   \   00000032   0xA901             ADD      R1,SP,#+4
   \   00000034   0x7A09             LDRB     R1,[R1, #+8]
   \   00000036   0x7281             STRB     R1,[R0, #+10]
   \   00000038   0xA901             ADD      R1,SP,#+4
   \   0000003A   0x7A49             LDRB     R1,[R1, #+9]
   \   0000003C   0x72C1             STRB     R1,[R0, #+11]
   \   0000003E   0xA901             ADD      R1,SP,#+4
   \   00000040   0x7A89             LDRB     R1,[R1, #+10]
   \   00000042   0x7601             STRB     R1,[R0, #+24]
   \   00000044   0xAA01             ADD      R2,SP,#+4
   \   00000046   0x7AD2             LDRB     R2,[R2, #+11]
   \   00000048   0x7642             STRB     R2,[R0, #+25]
   \   0000004A   0xAA01             ADD      R2,SP,#+4
   \   0000004C   0x7B12             LDRB     R2,[R2, #+12]
   \   0000004E   0x7682             STRB     R2,[R0, #+26]
   \   00000050   0x0789             LSLS     R1,R1,#+30
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0xD501             BPL      ??Subroutine0_0
   \   00000056   0x7B89             LDRB     R1,[R1, #+14]
   \   00000058   0xE000             B        ??Subroutine0_1
   \                     ??Subroutine0_0: (+1)
   \   0000005A   0x7B49             LDRB     R1,[R1, #+13]
   \                     ??Subroutine0_1: (+1)
   \   0000005C   0x76C1             STRB     R1,[R0, #+27]
   \   0000005E   0xA901             ADD      R1,SP,#+4
   \   00000060   0x7BC9             LDRB     R1,[R1, #+15]
   \   00000062   0x7701             STRB     R1,[R0, #+28]
   \   00000064   0xA901             ADD      R1,SP,#+4
   \   00000066   0x7C09             LDRB     R1,[R1, #+16]
   \   00000068   0x7741             STRB     R1,[R0, #+29]
   \   0000006A   0xA901             ADD      R1,SP,#+4
   \   0000006C   0x7C49             LDRB     R1,[R1, #+17]
   \   0000006E   0x7781             STRB     R1,[R0, #+30]
   \   00000070   0xA901             ADD      R1,SP,#+4
   \   00000072   0x7C89             LDRB     R1,[R1, #+18]
   \   00000074   0x77C1             STRB     R1,[R0, #+31]
   \   00000076   0xA901             ADD      R1,SP,#+4
   \   00000078   0x78C9             LDRB     R1,[R1, #+3]
   \   0000007A   0x70C1             STRB     R1,[R0, #+3]
   \   0000007C   0xB005             ADD      SP,SP,#+20
   \   0000007E   0x4770             BX       LR               ;; return
     86          

   \                                 In section .text, align 2, keep-with-next
     87          void UART2_Init (tUART sci)
     88          {   
   \                     UART2_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
     89            UART2_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000002   0x....             LDR      R0,??DataTable5_5  ;; 0x4006c000
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
     90            UART2_BDH     = sci.BDH;
     91            UART2_BDL     = sci.BDL;
     92            UART2_C1      = sci.C1;
     93            UART2_S2      = sci.S2;
     94            UART2_C3      = sci.C3;
     95            UART2_MA1     = sci.MA1;
     96            UART2_MA2     = sci.MA2;
     97            UART2_C4      = sci.C4;
     98            UART2_C5      = sci.C5;
     99            UART2_C2      = sci.C2;                            /* enable uart operation */  
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          void UART3_Init (tUART sci)
    103          {   
   \                     UART3_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB081             SUB      SP,SP,#+4
    104            UART3_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000004   0x....             LDR      R0,??DataTable5_6  ;; 0x4006d000
   \   00000006                      REQUIRE ?Subroutine0
   \   00000006                      ;; // Fall through to label ?Subroutine0
    105            UART3_BDH     = sci.BDH;
    106            UART3_BDL     = sci.BDL;
    107            UART3_C1      = sci.C1;
    108            UART3_S2      = sci.S2;
    109            UART3_C3      = sci.C3;
    110            UART3_MA1     = sci.MA1;
    111            UART3_MA2     = sci.MA2;
    112            UART3_C4      = sci.C4;
    113            UART3_C5      = sci.C5;
    114            UART3_C7816   = sci.C7816;
    115            UART3_IE7816  = sci.IE7816;
    116            UART3_IS7816  = sci.IS7816;
    117            if (sci.C7816 & UART_C7816_TTYPE_MASK) { UART3_WP7816T1= sci.WP7816T1; }
    118            else                                   { UART3_WP7816T0= sci.WP7816T0; }
    119            UART3_WN7816  = sci.WN7816;
    120            UART3_WF7816  = sci.WF7816;
    121            UART3_ET7816  = sci.ET7816;
    122            UART3_TL7816  = sci.TL7816;
    123            UART3_C2      = sci.C2;                           /* enable uart operation  */  
    124          }
    125          
    126          /******************************************************************************
    127           * interrupt function definitions                                             *
    128           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    129          void UART0_UART1_isr (void)
    130          {
   \                     UART0_UART1_isr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    131            register uint8 tmp;
    132           
    133            if (pCallbackUART0_UART1 != (UART_CALLBACK)NULL) 
   \   00000002   0x....             LDR      R5,??DataTable4
   \   00000004   0x682B             LDR      R3,[R5, #+0]
   \   00000006   0x0018             MOVS     R0,R3
   \   00000008   0xD05B             BEQ      ??UART0_UART1_isr_0
    134            { 
    135              /* process UART0 interrupts                                               */
    136              if (SIM_SCGC4 & SIM_SCGC4_UART0_MASK)
   \   0000000A   0x....             LDR      R6,??DataTable5_7  ;; 0x4003f034
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x0540             LSLS     R0,R0,#+21
   \   00000010   0xD529             BPL      ??UART0_UART1_isr_1
    137              {  
    138                tmp = UART0_S2 & (UART0_BDH & UART_BDH_RXEDGIE_MASK);
   \   00000012   0x....             LDR      R4,??DataTable5_3  ;; 0x4006a000
   \   00000014   0x7961             LDRB     R1,[R4, #+5]
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x7822             LDRB     R2,[R4, #+0]
   \   0000001A   0x400A             ANDS     R2,R2,R1
   \   0000001C   0x4002             ANDS     R2,R2,R0
    139                if(tmp != 0)
   \   0000001E   0xD004             BEQ      ??UART0_UART1_isr_2
    140                {
    141                  iosetb (UART0_S2,UART_S2_RXEDGIF_MASK);/* clear RXEDGIF interrupt flag*/
   \   00000020   0x....             LDR      R1,??DataTable5_8  ;; 0x4806a005
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    142                  pCallbackUART0_UART1 (UART0_CALLBACK, EDG_CALLBACK, tmp);
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x4798             BLX      R3
    143                }
    144          
    145                tmp = UART0_S1 & (UART0_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|       \
    146                                              UART_C2_TIE_MASK)); 
   \                     ??UART0_UART1_isr_2: (+1)
   \   0000002A   0x7920             LDRB     R0,[R4, #+4]
   \   0000002C   0x78E1             LDRB     R1,[R4, #+3]
   \   0000002E   0x4001             ANDS     R1,R1,R0
   \   00000030   0x27E0             MOVS     R7,#+224
   \   00000032   0x400F             ANDS     R7,R7,R1
    147                if(tmp & UART_S1_RDRF_MASK) 
   \   00000034   0x06B8             LSLS     R0,R7,#+26
   \   00000036   0xD504             BPL      ??UART0_UART1_isr_3
    148                  pCallbackUART0_UART1 (UART0_CALLBACK, RX_CALLBACK, tmp); 
   \   00000038   0xB27A             SXTB     R2,R7
   \   0000003A   0x2102             MOVS     R1,#+2
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x682B             LDR      R3,[R5, #+0]
   \   00000040   0x4798             BLX      R3
    149              
    150                if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??UART0_UART1_isr_3: (+1)
   \   00000042   0x20C0             MOVS     R0,#+192
   \   00000044   0x4038             ANDS     R0,R0,R7
   \   00000046   0xD004             BEQ      ??UART0_UART1_isr_4
    151                  pCallbackUART0_UART1 (UART0_CALLBACK ,TX_CALLBACK, tmp); 
   \   00000048   0xB27A             SXTB     R2,R7
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x682B             LDR      R3,[R5, #+0]
   \   00000050   0x4798             BLX      R3
    152              
    153                tmp = UART0_S1 & (UART0_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|      \
    154                                              UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));      
   \                     ??UART0_UART1_isr_4: (+1)
   \   00000052   0x7920             LDRB     R0,[R4, #+4]
   \   00000054   0x79A1             LDRB     R1,[R4, #+6]
   \   00000056   0x4001             ANDS     R1,R1,R0
   \   00000058   0x070A             LSLS     R2,R1,#+28
   \   0000005A   0x0F12             LSRS     R2,R2,#+28
    155                if(tmp != 0) 
   \   0000005C   0xD003             BEQ      ??UART0_UART1_isr_1
    156                  pCallbackUART0_UART1 (UART0_CALLBACK, ER_CALLBACK, tmp);
   \   0000005E   0x2104             MOVS     R1,#+4
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x682B             LDR      R3,[R5, #+0]
   \   00000064   0x4798             BLX      R3
    157              }
    158             
    159              /* process UART1 interrupts                                               */
    160              if (SIM_SCGC4 & SIM_SCGC4_UART1_MASK)
   \                     ??UART0_UART1_isr_1: (+1)
   \   00000066   0x6830             LDR      R0,[R6, #+0]
   \   00000068   0x0500             LSLS     R0,R0,#+20
   \   0000006A   0xD52A             BPL      ??UART0_UART1_isr_0
    161              { 
    162                tmp = UART1_S2 & (UART1_BDH & UART_BDH_RXEDGIE_MASK);      
   \   0000006C   0x....             LDR      R4,??DataTable5_4  ;; 0x4006b000
   \   0000006E   0x7961             LDRB     R1,[R4, #+5]
   \   00000070   0x2040             MOVS     R0,#+64
   \   00000072   0x7822             LDRB     R2,[R4, #+0]
   \   00000074   0x400A             ANDS     R2,R2,R1
   \   00000076   0x4002             ANDS     R2,R2,R0
    163                if(tmp != 0)
   \   00000078   0xD005             BEQ      ??UART0_UART1_isr_5
    164                {
    165                  iosetb (UART1_S2,UART_S2_RXEDGIF_MASK);/* clear RXEDGIF interrupt flag*/
   \   0000007A   0x....             LDR      R1,??DataTable5_9  ;; 0x4806b005
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
    166                  pCallbackUART0_UART1 (UART1_CALLBACK, EDG_CALLBACK, tmp);
   \   0000007E   0x2108             MOVS     R1,#+8
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x682B             LDR      R3,[R5, #+0]
   \   00000084   0x4798             BLX      R3
    167                }
    168           
    169                tmp = UART1_S1 & (UART1_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|       \
    170                                              UART_C2_TIE_MASK)); 
   \                     ??UART0_UART1_isr_5: (+1)
   \   00000086   0x7920             LDRB     R0,[R4, #+4]
   \   00000088   0x78E1             LDRB     R1,[R4, #+3]
   \   0000008A   0x4001             ANDS     R1,R1,R0
   \   0000008C   0x26E0             MOVS     R6,#+224
   \   0000008E   0x400E             ANDS     R6,R6,R1
    171                if(tmp & UART_S1_RDRF_MASK) 
   \   00000090   0x06B0             LSLS     R0,R6,#+26
   \   00000092   0xD504             BPL      ??UART0_UART1_isr_6
    172                  pCallbackUART0_UART1 (UART1_CALLBACK, RX_CALLBACK, tmp); 
   \   00000094   0xB272             SXTB     R2,R6
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x682B             LDR      R3,[R5, #+0]
   \   0000009C   0x4798             BLX      R3
    173              
    174                if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??UART0_UART1_isr_6: (+1)
   \   0000009E   0x20C0             MOVS     R0,#+192
   \   000000A0   0x4030             ANDS     R0,R0,R6
   \   000000A2   0xD004             BEQ      ??UART0_UART1_isr_7
    175                  pCallbackUART0_UART1 (UART1_CALLBACK, TX_CALLBACK, tmp); 
   \   000000A4   0xB272             SXTB     R2,R6
   \   000000A6   0x2101             MOVS     R1,#+1
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0x682B             LDR      R3,[R5, #+0]
   \   000000AC   0x4798             BLX      R3
    176              
    177                tmp = UART1_S1 & (UART1_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|      \
    178                                              UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));
   \                     ??UART0_UART1_isr_7: (+1)
   \   000000AE   0x7920             LDRB     R0,[R4, #+4]
   \   000000B0   0x79A1             LDRB     R1,[R4, #+6]
   \   000000B2   0x4001             ANDS     R1,R1,R0
   \   000000B4   0x070A             LSLS     R2,R1,#+28
   \   000000B6   0x0F12             LSRS     R2,R2,#+28
    179                if(tmp != 0) 
   \   000000B8   0xD003             BEQ      ??UART0_UART1_isr_0
    180                  pCallbackUART0_UART1 (UART1_CALLBACK, ER_CALLBACK, tmp);
   \   000000BA   0x2104             MOVS     R1,#+4
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0x682B             LDR      R3,[R5, #+0]
   \   000000C0   0x4798             BLX      R3
    181              }
    182            }   
    183          }
   \                     ??UART0_UART1_isr_0: (+1)
   \   000000C2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    184          

   \                                 In section .text, align 2, keep-with-next
    185          void UART2_UART3_isr (void)
    186          {
   \                     UART2_UART3_isr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    187            register uint8 tmp;
    188           
    189            if (pCallbackUART2_UART3 != (UART_CALLBACK)NULL) 
   \   00000002   0x....             LDR      R5,??DataTable5_2
   \   00000004   0x682B             LDR      R3,[R5, #+0]
   \   00000006   0x0018             MOVS     R0,R3
   \   00000008   0xD05B             BEQ      ??UART2_UART3_isr_0
    190            { 
    191              /* process UART2 interrupts                                               */
    192              if (SIM_SCGC4 & SIM_SCGC4_UART2_MASK)
   \   0000000A   0x....             LDR      R6,??DataTable5_7  ;; 0x4003f034
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x04C0             LSLS     R0,R0,#+19
   \   00000010   0xD529             BPL      ??UART2_UART3_isr_1
    193              {  
    194                tmp = UART2_S2 & (UART2_BDH & UART_BDH_RXEDGIE_MASK);      
   \   00000012   0x....             LDR      R4,??DataTable5_5  ;; 0x4006c000
   \   00000014   0x7961             LDRB     R1,[R4, #+5]
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x7822             LDRB     R2,[R4, #+0]
   \   0000001A   0x400A             ANDS     R2,R2,R1
   \   0000001C   0x4002             ANDS     R2,R2,R0
    195                if(tmp != 0)
   \   0000001E   0xD004             BEQ      ??UART2_UART3_isr_2
    196                {
    197                  iosetb (UART2_S2,UART_S2_RXEDGIF_MASK);/* clear RXEDGIF interrupt flag*/
   \   00000020   0x....             LDR      R1,??DataTable5_10  ;; 0x4806c005
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    198                  pCallbackUART2_UART3 (UART2_CALLBACK, EDG_CALLBACK, tmp);
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x4798             BLX      R3
    199                }
    200          
    201                tmp = UART2_S1 & (UART2_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|       \
    202                                              UART_C2_TIE_MASK)); 
   \                     ??UART2_UART3_isr_2: (+1)
   \   0000002A   0x7920             LDRB     R0,[R4, #+4]
   \   0000002C   0x78E1             LDRB     R1,[R4, #+3]
   \   0000002E   0x4001             ANDS     R1,R1,R0
   \   00000030   0x27E0             MOVS     R7,#+224
   \   00000032   0x400F             ANDS     R7,R7,R1
    203                if(tmp & UART_S1_RDRF_MASK) 
   \   00000034   0x06B8             LSLS     R0,R7,#+26
   \   00000036   0xD504             BPL      ??UART2_UART3_isr_3
    204                  pCallbackUART2_UART3 (UART2_CALLBACK, RX_CALLBACK, tmp); 
   \   00000038   0xB27A             SXTB     R2,R7
   \   0000003A   0x2102             MOVS     R1,#+2
   \   0000003C   0x2004             MOVS     R0,#+4
   \   0000003E   0x682B             LDR      R3,[R5, #+0]
   \   00000040   0x4798             BLX      R3
    205              
    206                if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??UART2_UART3_isr_3: (+1)
   \   00000042   0x20C0             MOVS     R0,#+192
   \   00000044   0x4038             ANDS     R0,R0,R7
   \   00000046   0xD004             BEQ      ??UART2_UART3_isr_4
    207                  pCallbackUART2_UART3 (UART2_CALLBACK, TX_CALLBACK, tmp); 
   \   00000048   0xB27A             SXTB     R2,R7
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x682B             LDR      R3,[R5, #+0]
   \   00000050   0x4798             BLX      R3
    208              
    209                tmp = UART2_S1 & (UART2_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|      \
    210                                              UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));
   \                     ??UART2_UART3_isr_4: (+1)
   \   00000052   0x7920             LDRB     R0,[R4, #+4]
   \   00000054   0x79A1             LDRB     R1,[R4, #+6]
   \   00000056   0x4001             ANDS     R1,R1,R0
   \   00000058   0x070A             LSLS     R2,R1,#+28
   \   0000005A   0x0F12             LSRS     R2,R2,#+28
    211                if(tmp != 0) 
   \   0000005C   0xD003             BEQ      ??UART2_UART3_isr_1
    212                  pCallbackUART2_UART3 (UART2_CALLBACK, ER_CALLBACK, tmp);      
   \   0000005E   0x2104             MOVS     R1,#+4
   \   00000060   0x2004             MOVS     R0,#+4
   \   00000062   0x682B             LDR      R3,[R5, #+0]
   \   00000064   0x4798             BLX      R3
    213              }
    214             
    215              /* process UART3 interrupts                                               */
    216              if (SIM_SCGC4 & SIM_SCGC4_UART3_MASK)
   \                     ??UART2_UART3_isr_1: (+1)
   \   00000066   0x6830             LDR      R0,[R6, #+0]
   \   00000068   0x0480             LSLS     R0,R0,#+18
   \   0000006A   0xD52A             BPL      ??UART2_UART3_isr_0
    217              {  
    218                tmp = UART3_S2 & (UART3_BDH & UART_BDH_RXEDGIE_MASK);      
   \   0000006C   0x....             LDR      R4,??DataTable5_6  ;; 0x4006d000
   \   0000006E   0x7961             LDRB     R1,[R4, #+5]
   \   00000070   0x2040             MOVS     R0,#+64
   \   00000072   0x7822             LDRB     R2,[R4, #+0]
   \   00000074   0x400A             ANDS     R2,R2,R1
   \   00000076   0x4002             ANDS     R2,R2,R0
    219                if(tmp != 0)
   \   00000078   0xD005             BEQ      ??UART2_UART3_isr_5
    220                {
    221                  iosetb (UART3_S2,UART_S2_RXEDGIF_MASK);/* clear RXEDGIF interrupt flag*/     
   \   0000007A   0x....             LDR      R1,??DataTable5_11  ;; 0x4806d005
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
    222                  pCallbackUART2_UART3 (UART3_CALLBACK, EDG_CALLBACK, tmp);
   \   0000007E   0x2108             MOVS     R1,#+8
   \   00000080   0x2008             MOVS     R0,#+8
   \   00000082   0x682B             LDR      R3,[R5, #+0]
   \   00000084   0x4798             BLX      R3
    223                }
    224                
    225                tmp = UART3_S1 & (UART3_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|       \
    226                                              UART_C2_TIE_MASK)); 
   \                     ??UART2_UART3_isr_5: (+1)
   \   00000086   0x7920             LDRB     R0,[R4, #+4]
   \   00000088   0x78E1             LDRB     R1,[R4, #+3]
   \   0000008A   0x4001             ANDS     R1,R1,R0
   \   0000008C   0x26E0             MOVS     R6,#+224
   \   0000008E   0x400E             ANDS     R6,R6,R1
    227                if(tmp & UART_S1_RDRF_MASK) 
   \   00000090   0x06B0             LSLS     R0,R6,#+26
   \   00000092   0xD504             BPL      ??UART2_UART3_isr_6
    228                  pCallbackUART2_UART3 (UART3_CALLBACK, RX_CALLBACK, tmp); 
   \   00000094   0xB272             SXTB     R2,R6
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0x2008             MOVS     R0,#+8
   \   0000009A   0x682B             LDR      R3,[R5, #+0]
   \   0000009C   0x4798             BLX      R3
    229              
    230                if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??UART2_UART3_isr_6: (+1)
   \   0000009E   0x20C0             MOVS     R0,#+192
   \   000000A0   0x4030             ANDS     R0,R0,R6
   \   000000A2   0xD004             BEQ      ??UART2_UART3_isr_7
    231                  pCallbackUART2_UART3 (UART3_CALLBACK ,TX_CALLBACK, tmp); 
   \   000000A4   0xB272             SXTB     R2,R6
   \   000000A6   0x2101             MOVS     R1,#+1
   \   000000A8   0x2008             MOVS     R0,#+8
   \   000000AA   0x682B             LDR      R3,[R5, #+0]
   \   000000AC   0x4798             BLX      R3
    232              
    233                tmp = UART3_S1 & (UART3_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|      \
    234                                              UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));
   \                     ??UART2_UART3_isr_7: (+1)
   \   000000AE   0x7920             LDRB     R0,[R4, #+4]
   \   000000B0   0x79A1             LDRB     R1,[R4, #+6]
   \   000000B2   0x4001             ANDS     R1,R1,R0
   \   000000B4   0x070A             LSLS     R2,R1,#+28
   \   000000B6   0x0F12             LSRS     R2,R2,#+28
    235                if(tmp != 0) 
   \   000000B8   0xD003             BEQ      ??UART2_UART3_isr_0
    236                  pCallbackUART2_UART3 (UART3_CALLBACK, ER_CALLBACK, tmp);
   \   000000BA   0x2104             MOVS     R1,#+4
   \   000000BC   0x2008             MOVS     R0,#+8
   \   000000BE   0x682B             LDR      R3,[R5, #+0]
   \   000000C0   0x4798             BLX      R3
    237              }
    238            }
    239          }
   \                     ??UART2_UART3_isr_0: (+1)
   \   000000C2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     pCallbackUART0_UART1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0xE000E410         DC32     0xe000e410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0xE000E414         DC32     0xe000e414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     pCallbackUART2_UART3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x4003F034         DC32     0x4003f034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x4806A005         DC32     0x4806a005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x4806B005         DC32     0x4806b005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x4806C005         DC32     0x4806c005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x4806D005         DC32     0x4806d005
    240          /******************************************************************************
    241           * End of module                                                              *
    242           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   UART0_Init
      24   UART0_UART1_isr
        24   -- Indirect call
      20   UART1_Init
      16   UART2_Init
      24   UART2_UART3_isr
        24   -- Indirect call
      20   UART3_Init
       0   UART_InstallCallbackUART0_UART1
       8   UART_InstallCallbackUART2_UART3


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
     128  ?Subroutine0
      72  ?Subroutine1
       6  UART0_Init
     196  UART0_UART1_isr
       8  UART1_Init
       4  UART2_Init
     196  UART2_UART3_isr
       6  UART3_Init
      40  UART_InstallCallbackUART0_UART1
      46  UART_InstallCallbackUART2_UART3
       4  pCallbackUART0_UART1
       4  pCallbackUART2_UART3

 
   8 bytes in section .bss
 762 bytes in section .text
 
 762 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
