###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        30/Jan/2016  15:22:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\projects\_twr_emeter_demo\LCD.c
#    Command line =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\projects\_twr_emeter_demo\LCD.c
#        -D NDEBUG -lCN
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\
#        -o
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\
#        --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\build\iar_6_50\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\fraclib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\meterlib\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\common\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\drivers\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\freemaster\
#        -I
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\..\..\..\..\src\projects\_twr_emeter_demo\
#        -Oh --require_prototypes
#    List file    =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\List\LCD.lst
#    Object file  =  
#        E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\build\iar_6_50\projects\_twr_emeter_demo\Release\Obj\LCD.o
#
###############################################################################

E:\TCL\PROJECT\SmartHome\资料\freescale\KMSWDRV_EAR2_2\src\projects\_twr_emeter_demo\LCD.c
      1          /******************************************************************************
      2          * 
      3          * Copyright (c) 2009 Freescale Semiconductor;
      4          * All Rights Reserved                       
      5          *
      6          *******************************************************************************
      7          *
      8          * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR 
      9          * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
     10          * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
     11          * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     12          * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
     13          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
     14          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
     15          * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     16          * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     17          * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     18          * THE POSSIBILITY OF SUCH DAMAGE.
     19          *
     20          ***************************************************************************//*!
     21          *
     22          * @file      LCD.c
     23          * @author    b19186
     24          * @version   0.0.2.0
     25          * @date      April-11-2011
     26          * @brief     Driver header for LCD on TWR board, type S-Tek Displays GDH-1247WP
     27          * 					
     28          ******************************************************************************/
     29          #include <string.h>
     30          #include "common.h"
     31          #include "LCD.h"
     32          

   \                                 In section .bss, align 4
     33          unsigned char LCD_buffer[_LCD_CHARNUM1+1];   /* LCD buffer */
   \                     LCD_buffer:
   \   00000000                      DS8 12
     34          unsigned char bLCD_CharPosition;             /* current pos. of the character */
   \                     bLCD_CharPosition:
   \   0000000C                      DS8 1
     35          

   \                                 In section .data, align 4
     36          unsigned char *bpaPlace[ ] =
   \                     bpaPlace:
   \   00000000   0x4004303B         DC32 4004303BH, 4004303AH, 40043039H, 40043038H, 40043037H, 40043036H
   \              0x4004303A   
   \              0x40043039   
   \              0x40043038   
   \              0x40043037   
   \              0x40043036   
   \   00000018   0x40043035         DC32 40043035H, 40043034H, 40043033H, 40043042H, 40043043H, 40043044H
   \              0x40043034   
   \              0x40043033   
   \              0x40043042   
   \              0x40043043   
   \              0x40043044   
   \   00000030   0x40043045         DC32 40043045H, 4004304BH, 40043041H
   \              0x4004304B   
   \              0x40043041   
     37          { 
     38           (unsigned char *)&Char1,   
     39           (unsigned char *)&Char2,   
     40           (unsigned char *)&Char3,   
     41           (unsigned char *)&Char4,   
     42           (unsigned char *)&Char5,   
     43           (unsigned char *)&Char6,   
     44           (unsigned char *)&Char7,   
     45           (unsigned char *)&Char8,   
     46           (unsigned char *)&Char9,   
     47           (unsigned char *)&Char10,   
     48           (unsigned char *)&Char11,   
     49           (unsigned char *)&Char12,   
     50           (unsigned char *)&Char13,   
     51           (unsigned char *)&Char14,   
     52           (unsigned char *)&Char15,   
     53           };
     54          
     55          /* Codification from Ascci code from '0' to 'Z' for the main char. group */

   \                                 In section .text, align 4, keep-with-next
     56          const unsigned char baAscii1 [ ] =
   \                     baAscii1:
   \   00000000   0xEE 0x48          DC8 238, 72, 186, 218, 92, 214, 246, 74, 254, 222, 0, 126, 244, 176
   \              0xBA 0xDA    
   \              0x5C 0xD6    
   \              0xF6 0x4A    
   \              0xFE 0xDE    
   \              0x00 0x7E    
   \              0xF4 0xB0    
   \   0000000E   0xF8 0xB6          DC8 248, 182, 54, 246, 116, 72, 232, 124, 164, 110, 112, 240, 62, 240
   \              0x36 0xF6    
   \              0x74 0x48    
   \              0xE8 0x7C    
   \              0xA4 0x6E    
   \              0x70 0xF0    
   \              0x3E 0xF0    
   \   0000001C   0x30 0xD6          DC8 48, 214, 180, 236, 224, 224, 124, 60, 186, 0, 0, 0
   \              0xB4 0xEC    
   \              0xE0 0xE0    
   \              0x7C 0x3C    
   \              0xBA 0x00    
   \              0x00 0x00    
     57          {
     58           ( SEG1A+ SEG1F+ SEG1B+ !SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = 0,   offset=0
     59           (!SEG1A+!SEG1F+ SEG1B+ !SEG1G+!SEG1E+ SEG1C+!SEG1D),     //Char = 1,   offset=1
     60           ( SEG1A+!SEG1F+ SEG1B+  SEG1G+ SEG1E+!SEG1C+ SEG1D),     //Char = 2,   offset=2
     61           ( SEG1A+!SEG1F+ SEG1B+  SEG1G+!SEG1E+ SEG1C+ SEG1D),     //Char = 3,   offset=3
     62           (!SEG1A+ SEG1F+ SEG1B+  SEG1G+!SEG1E+ SEG1C+!SEG1D),     //Char = 4,   offset=4
     63           ( SEG1A+ SEG1F+!SEG1B+  SEG1G+!SEG1E+ SEG1C+ SEG1D),     //Char = 5,   offset=5
     64           ( SEG1A+ SEG1F+!SEG1B+  SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = 6,   offset=6
     65           ( SEG1A+!SEG1F+ SEG1B+ !SEG1G+!SEG1E+ SEG1C+!SEG1D),     //Char = 7,   offset=7
     66           ( SEG1A+ SEG1F+ SEG1B+  SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = 8,   offset=8
     67           ( SEG1A+ SEG1F+ SEG1B+  SEG1G+!SEG1E+ SEG1C+ SEG1D),     //Char = 9,   offset=9
     68           (!SEG1A+!SEG1F+!SEG1B+ !SEG1G+!SEG1E+!SEG1C+!SEG1D),     //Char =  ,   offset=10
     69           ( SEG1A+ SEG1F+ SEG1B+  SEG1G+ SEG1E+ SEG1C+!SEG1D),     //Char = A,   offset=11
     70           (!SEG1A+ SEG1F+!SEG1B+  SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = b,   offset=12
     71           (!SEG1A+!SEG1F+!SEG1B+  SEG1G+ SEG1E+!SEG1C+ SEG1D),     //Char = c,   offset=13
     72           (!SEG1A+!SEG1F+ SEG1B+  SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = d,   offset=14
     73           ( SEG1A+ SEG1F+!SEG1B+  SEG1G+ SEG1E+!SEG1C+ SEG1D),     //Char = E,   offset=15
     74           ( SEG1A+ SEG1F+!SEG1B+  SEG1G+ SEG1E+!SEG1C+!SEG1D),     //Char = F,   offset=16
     75           ( SEG1A+ SEG1F+!SEG1B+  SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = G,   offset=17
     76           (!SEG1A+ SEG1F+!SEG1B+  SEG1G+ SEG1E+ SEG1C+!SEG1D),     //Char = H,   offset=18
     77           (!SEG1A+!SEG1F+ SEG1B+ !SEG1G+!SEG1E+ SEG1C+!SEG1D),     //Char = I,   offset=19
     78           (!SEG1A+!SEG1F+ SEG1B+ !SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = J,   offset=20
     79           (!SEG1A+ SEG1F+ SEG1B+  SEG1G+ SEG1E+ SEG1C+!SEG1D),     //Char = K,   offset=21
     80           (!SEG1A+ SEG1F+!SEG1B+ !SEG1G+ SEG1E+!SEG1C+ SEG1D),     //Char = L,   offset=22
     81           ( SEG1A+ SEG1F+ SEG1B+ !SEG1G+ SEG1E+ SEG1C+!SEG1D),     //Char = M,   offset=23
     82           (!SEG1A+!SEG1F+!SEG1B+  SEG1G+ SEG1E+ SEG1C+!SEG1D),     //Char = n,   offset=24
     83           (!SEG1A+!SEG1F+!SEG1B+  SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = o,   offset=25
     84           ( SEG1A+ SEG1F+ SEG1B+  SEG1G+ SEG1E+!SEG1C+!SEG1D),     //Char = P,   offset=26
     85           (!SEG1A+!SEG1F+!SEG1B+  SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = Q,   offset=27
     86           (!SEG1A+!SEG1F+!SEG1B+  SEG1G+ SEG1E+!SEG1C+!SEG1D),     //Char = r,   offset=28
     87           ( SEG1A+ SEG1F+!SEG1B+  SEG1G+!SEG1E+ SEG1C+ SEG1D),     //Char = s,   offset=29
     88           (!SEG1A+ SEG1F+!SEG1B+  SEG1G+ SEG1E+!SEG1C+ SEG1D),     //Char = t,   offset=30
     89           (!SEG1A+ SEG1F+ SEG1B+ !SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = U,   offset=31
     90           (!SEG1A+!SEG1F+!SEG1B+ !SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = v,   offset=32
     91           (!SEG1A+!SEG1F+!SEG1B+ !SEG1G+ SEG1E+ SEG1C+ SEG1D),     //Char = w,   offset=33
     92           (!SEG1A+ SEG1F+ SEG1B+  SEG1G+ SEG1E+ SEG1C+!SEG1D),     //Char = X,   offset=34
     93           (!SEG1A+ SEG1F+ SEG1B+  SEG1G+ SEG1E+!SEG1C+!SEG1D),     //Char = Y,   offset=35
     94           ( SEG1A+!SEG1F+ SEG1B+  SEG1G+ SEG1E+!SEG1C+ SEG1D),     //Char = Z,   offset=36
     95          };
     96          
     97          /* Codification from Ascci code from '0' to 'Z' for the OBIS code group */

   \                                 In section .text, align 4, keep-with-next
     98          const unsigned char baAscii2 [ ] =
   \                     baAscii2:
   \   00000000   0xEE 0x48          DC8 238, 72, 214, 218, 120, 186, 190, 200, 254, 250, 0, 252, 62, 22, 94
   \              0xD6 0xDA    
   \              0x78 0xBA    
   \              0xBE 0xC8    
   \              0xFE 0xFA    
   \              0x00 0xFC    
   \              0x3E 0x16    
   \              0x5E         
   \   0000000F   0xB6 0xB4          DC8 182, 180, 190, 60, 72, 78, 124, 38, 236, 28, 30, 244, 30, 20, 186
   \              0xBE 0x3C    
   \              0x48 0x4E    
   \              0x7C 0x26    
   \              0xEC 0x1C    
   \              0x1E 0xF4    
   \              0x1E 0x14    
   \              0xBA         
   \   0000001E   0x36 0x6E          DC8 54, 110, 14, 14, 124, 116, 214, 0, 0, 0
   \              0x0E 0x0E    
   \              0x7C 0x74    
   \              0xD6 0x00    
   \              0x00 0x00    
     99          {
    100           ( SEG2A+ SEG2F+ SEG2B+ !SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = 0,   offset=0
    101           (!SEG2A+!SEG2F+ SEG2B+ !SEG2G+!SEG2E+ SEG2C+!SEG2D),     //Char = 1,   offset=1
    102           ( SEG2A+!SEG2F+ SEG2B+  SEG2G+ SEG2E+!SEG2C+ SEG2D),     //Char = 2,   offset=2
    103           ( SEG2A+!SEG2F+ SEG2B+  SEG2G+!SEG2E+ SEG2C+ SEG2D),     //Char = 3,   offset=3
    104           (!SEG2A+ SEG2F+ SEG2B+  SEG2G+!SEG2E+ SEG2C+!SEG2D),     //Char = 4,   offset=4
    105           ( SEG2A+ SEG2F+!SEG2B+  SEG2G+!SEG2E+ SEG2C+ SEG2D),     //Char = 5,   offset=5
    106           ( SEG2A+ SEG2F+!SEG2B+  SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = 6,   offset=6
    107           ( SEG2A+!SEG2F+ SEG2B+ !SEG2G+!SEG2E+ SEG2C+!SEG2D),     //Char = 7,   offset=7
    108           ( SEG2A+ SEG2F+ SEG2B+  SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = 8,   offset=8
    109           ( SEG2A+ SEG2F+ SEG2B+  SEG2G+!SEG2E+ SEG2C+ SEG2D),     //Char = 9,   offset=9
    110           (!SEG2A+!SEG2F+!SEG2B+ !SEG2G+!SEG2E+!SEG2C+!SEG2D),     //Char =  ,   offset=10
    111           ( SEG2A+ SEG2F+ SEG2B+  SEG2G+ SEG2E+ SEG2C+!SEG2D),     //Char = A,   offset=11
    112           (!SEG2A+ SEG2F+!SEG2B+  SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = b,   offset=12
    113           (!SEG2A+!SEG2F+!SEG2B+  SEG2G+ SEG2E+!SEG2C+ SEG2D),     //Char = c,   offset=13
    114           (!SEG2A+!SEG2F+ SEG2B+  SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = d,   offset=14
    115           ( SEG2A+ SEG2F+!SEG2B+  SEG2G+ SEG2E+!SEG2C+ SEG2D),     //Char = E,   offset=15
    116           ( SEG2A+ SEG2F+!SEG2B+  SEG2G+ SEG2E+!SEG2C+!SEG2D),     //Char = F,   offset=16
    117           ( SEG2A+ SEG2F+!SEG2B+  SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = G,   offset=17
    118           (!SEG2A+ SEG2F+!SEG2B+  SEG2G+ SEG2E+ SEG2C+!SEG2D),     //Char = H,   offset=18
    119           (!SEG2A+!SEG2F+ SEG2B+ !SEG2G+!SEG2E+ SEG2C+!SEG2D),     //Char = I,   offset=19
    120           (!SEG2A+!SEG2F+ SEG2B+ !SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = J,   offset=20
    121           (!SEG2A+ SEG2F+ SEG2B+  SEG2G+ SEG2E+ SEG2C+!SEG2D),     //Char = K,   offset=21
    122           (!SEG2A+ SEG2F+!SEG2B+ !SEG2G+ SEG2E+!SEG2C+ SEG2D),     //Char = L,   offset=22
    123           ( SEG2A+ SEG2F+ SEG2B+ !SEG2G+ SEG2E+ SEG2C+!SEG2D),     //Char = M,   offset=23
    124           (!SEG2A+!SEG2F+!SEG2B+  SEG2G+ SEG2E+ SEG2C+!SEG2D),     //Char = n,   offset=24
    125           (!SEG2A+!SEG2F+!SEG2B+  SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = o,   offset=25
    126           ( SEG2A+ SEG2F+ SEG2B+  SEG2G+ SEG2E+!SEG2C+!SEG2D),     //Char = P,   offset=26
    127           (!SEG2A+!SEG2F+!SEG2B+  SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = Q,   offset=27
    128           (!SEG2A+!SEG2F+!SEG2B+  SEG2G+ SEG2E+!SEG2C+!SEG2D),     //Char = r,   offset=28
    129           ( SEG2A+ SEG2F+!SEG2B+  SEG2G+!SEG2E+ SEG2C+ SEG2D),     //Char = s,   offset=29
    130           (!SEG2A+ SEG2F+!SEG2B+  SEG2G+ SEG2E+!SEG2C+ SEG2D),     //Char = t,   offset=30
    131           (!SEG2A+ SEG2F+ SEG2B+ !SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = U,   offset=31
    132           (!SEG2A+!SEG2F+!SEG2B+ !SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = v,   offset=32
    133           (!SEG2A+!SEG2F+!SEG2B+ !SEG2G+ SEG2E+ SEG2C+ SEG2D),     //Char = w,   offset=33
    134           (!SEG2A+ SEG2F+ SEG2B+  SEG2G+ SEG2E+ SEG2C+!SEG2D),     //Char = X,   offset=34
    135           (!SEG2A+ SEG2F+ SEG2B+  SEG2G+ SEG2E+!SEG2C+!SEG2D),     //Char = Y,   offset=35
    136           ( SEG2A+!SEG2F+ SEG2B+  SEG2G+ SEG2E+!SEG2C+ SEG2D),     //Char = Z,   offset=36
    137          };
    138          
    139          /* Codification from Ascci code from '0' to '9' for the alone segment */

   \                                 In section .text, align 4, keep-with-next
    140          const unsigned char baAscii3 [ ] =
   \                     baAscii3:
   \   00000000   0x77 0x24          DC8 119, 36, 107, 109, 60, 93, 95, 100, 127, 125, 0, 0
   \              0x6B 0x6D    
   \              0x3C 0x5D    
   \              0x5F 0x64    
   \              0x7F 0x7D    
   \              0x00 0x00    
    141          {
    142           ( SEG3A+ SEG3F+ SEG3B+ !SEG3G+ SEG3E+ SEG3C+ SEG3D),     //Char = 0,   offset=0
    143           (!SEG3A+!SEG3F+ SEG3B+ !SEG3G+!SEG3E+ SEG3C+!SEG3D),     //Char = 1,   offset=1
    144           ( SEG3A+!SEG3F+ SEG3B+  SEG3G+ SEG3E+!SEG3C+ SEG3D),     //Char = 2,   offset=2
    145           ( SEG3A+!SEG3F+ SEG3B+  SEG3G+!SEG3E+ SEG3C+ SEG3D),     //Char = 3,   offset=3
    146           (!SEG3A+ SEG3F+ SEG3B+  SEG3G+!SEG3E+ SEG3C+!SEG3D),     //Char = 4,   offset=4
    147           ( SEG3A+ SEG3F+!SEG3B+  SEG3G+!SEG3E+ SEG3C+ SEG3D),     //Char = 5,   offset=5
    148           ( SEG3A+ SEG3F+!SEG3B+  SEG3G+ SEG3E+ SEG3C+ SEG3D),     //Char = 6,   offset=6
    149           ( SEG3A+!SEG3F+ SEG3B+ !SEG3G+!SEG3E+ SEG3C+!SEG3D),     //Char = 7,   offset=7
    150           ( SEG3A+ SEG3F+ SEG3B+  SEG3G+ SEG3E+ SEG3C+ SEG3D),     //Char = 8,   offset=8
    151           ( SEG3A+ SEG3F+ SEG3B+  SEG3G+!SEG3E+ SEG3C+ SEG3D),     //Char = 9,   offset=9
    152           (!SEG3A+!SEG3F+!SEG3B+ !SEG3G+!SEG3E+!SEG3C+!SEG3D),     //Char =  ,   offset=10
    153          };
    154          
    155          /***************************************************************************//*!
    156          *
    157          * @brief    Initialization of LCD   
    158          *
    159          * @param    nothing
    160          * @return   nothing
    161          *
    162          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    163          void vfnLCD_Init(void)
    164          {
    165            MCG_C1|= 0x02;                  // enable IRCLK
   \                     vfnLCD_Init: (+1)
   \   00000000   0x....             LDR      R0,??DataTable11  ;; 0x40064000
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2202             MOVS     R2,#+2
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x7002             STRB     R2,[R0, #+0]
    166             
    167            LCD_PENL= 0x9FFFfe00;           // enable LCD pins (28 pins)
   \   0000000A   0x....             LDR      R0,??DataTable11_1  ;; 0x40043000
   \   0000000C   0x....             LDR      R1,??DataTable11_2  ;; 0x9ffffe00
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    168            LCD_PENH= 0x0000083F;
   \   00000010   0x....             LDR      R1,??DataTable11_3  ;; 0x83f
   \   00000012   0x6141             STR      R1,[R0, #+20]
    169            
    170            LCD_BPENL = 0x0001FE00;         // enable LCD backplanes 9...16
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x0249             LSLS     R1,R1,#+9        ;; #+130560
   \   00000018   0x6181             STR      R1,[R0, #+24]
    171          
    172            LCD_WF19TO16 = 0x00000001;      // assign backplanes 
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x6301             STR      R1,[R0, #+48]
    173            LCD_WF15TO12 = 0x02040810;      // assign backplanes 
   \   0000001E   0x....             LDR      R1,??DataTable11_4  ;; 0x2040810
   \   00000020   0x62C1             STR      R1,[R0, #+44]
    174            LCD_WF11TO8 = 0x20408000;      // assign backplanes 
   \   00000022   0x....             LDR      R1,??DataTable11_5  ;; 0x20408000
   \   00000024   0x6281             STR      R1,[R0, #+40]
    175          
    176            LCD_GCR&=~LCD_GCR_LCDDOZE_MASK; 
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x....             LDR      R2,??DataTable11_6  ;; 0xfffffdff
   \   0000002A   0x400A             ANDS     R2,R2,R1
   \   0000002C   0x6002             STR      R2,[R0, #+0]
    177            LCD_GCR|=LCD_GCR_CPSEL_MASK;
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x2280             MOVS     R2,#+128
   \   00000032   0x0412             LSLS     R2,R2,#+16       ;; #+8388608
   \   00000034   0x430A             ORRS     R2,R2,R1
   \   00000036   0x6002             STR      R2,[R0, #+0]
    178            LCD_GCR|=LCD_GCR_LADJ(0);       // !!!
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    179            LCD_GCR|=LCD_GCR_DUTY(7);
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x2207             MOVS     R2,#+7
   \   00000040   0x430A             ORRS     R2,R2,R1
   \   00000042   0x6002             STR      R2,[R0, #+0]
    180            LCD_GCR|=LCD_GCR_LCLK(1);       
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0x2208             MOVS     R2,#+8
   \   00000048   0x430A             ORRS     R2,R2,R1
   \   0000004A   0x....             B.N      ?Subroutine1
    181            LCD_GCR|=LCD_GCR_LCDEN_MASK;   //Enable LCD
    182          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x6002             STR      R2,[R0, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x2280             MOVS     R2,#+128
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x4770             BX       LR               ;; return
    183            
    184          /***************************************************************************//*!
    185          *
    186          * @brief    Switching the LCD off
    187          *
    188          * @param    nothing
    189          * @return   nothing
    190          *
    191          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    192          void vfnLCD_OFF(void)
    193          {
    194            LCD_GCR|= LCD_GCR_LCDDOZE_MASK;   
   \                     vfnLCD_OFF: (+1)
   \   00000000   0x....             LDR      R0,??DataTable11_1  ;; 0x40043000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0D42             LSRS     R2,R0,#+21
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x6002             STR      R2,[R0, #+0]
    195            LCD_GCR&= ~LCD_GCR_LCDEN_MASK;   //Disable LCD
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x2280             MOVS     R2,#+128
   \   0000000E   0x4391             BICS     R1,R1,R2
   \   00000010   0x6001             STR      R1,[R0, #+0]
    196          }
   \   00000012   0x4770             BX       LR               ;; return
    197          
    198          /***************************************************************************//*!
    199          *
    200          * @brief    Switching the LCD on
    201          *
    202          * @param    nothing
    203          * @return   nothing
    204          *
    205          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    206          void vfnLCD_ON(void)
    207          {
    208            LCD_GCR&= ~LCD_GCR_LCDDOZE_MASK;   
   \                     vfnLCD_ON: (+1)
   \   00000000   0x....             LDR      R0,??DataTable11_1  ;; 0x40043000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x....             LDR      R2,??DataTable11_6  ;; 0xfffffdff
   \   00000006   0x400A             ANDS     R2,R2,R1
   \   00000008                      REQUIRE ?Subroutine1
   \   00000008                      ;; // Fall through to label ?Subroutine1
    209            LCD_GCR|= LCD_GCR_LCDEN_MASK;   //Enable LCD
    210          }
    211          
    212          /***************************************************************************//*!
    213          *
    214          * @brief    Change of contrast of LCD   
    215          *
    216          * @param    value (0..15)
    217          * @return   nothing
    218          *
    219          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void vfnLCD_Contrast (unsigned char lbContrast)
    221          {
    222            lbContrast &= 0x0F;                                                                                                           
    223           // LCD_GCR|= LCD_GCR_RVEN_MASK; 
    224            
    225            LCD_GCR &= ~LCD_GCR_RVTRIM_MASK;
   \                     vfnLCD_Contrast: (+1)
   \   00000000   0x....             LDR      R1,??DataTable11_1  ;; 0x40043000
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable11_7  ;; 0xf0ffffff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x600B             STR      R3,[R1, #+0]
    226            LCD_GCR |= LCD_GCR_RVTRIM(lbContrast);                 
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x0600             LSLS     R0,R0,#+24
   \   0000000E   0x23F0             MOVS     R3,#+240
   \   00000010   0x051B             LSLS     R3,R3,#+20       ;; #+251658240
   \   00000012   0x4003             ANDS     R3,R3,R0
   \   00000014   0x4313             ORRS     R3,R3,R2
   \   00000016   0x600B             STR      R3,[R1, #+0]
    227          }
   \   00000018   0x4770             BX       LR               ;; return
    228           
    229          /******************************************************************************
    230                                  Symbol mask for LCD segments 1..14
    231          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    232          const unsigned char symbol_mask[] = {
   \                     symbol_mask:
   \   00000000   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 128, 0
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x80 0x00    
    233              0x01,        // Char 1
    234              0x01,        // Char 2
    235              0x01,        // Char 3
    236              0x01,        // Char 4
    237              0x01,        // Char 5
    238              0x01,        // Char 6
    239              0x01,        // Char 7
    240              0x01,        // Char 8
    241              0x01,        // Char 9
    242              0x01,        // Char 10
    243              0x01,        // Char 11
    244              0x01,        // Char 12
    245              0x01,        // Char 13
    246              0x01,        // Char 14
    247              0x80,        // Char 15
    248          };
    249          
    250          /***************************************************************************//*!
    251          *
    252          * @brief    Write one character to LCD   
    253          *
    254          * @param    character (ASCII format), support only '0'..'9',':','a'..'z'
    255          *           position of LCD digit (0..13)
    256          * @return   nothing
    257          *
    258          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    259          void vfnLCD_Write_Char (unsigned char lbValue, unsigned char pos)
    260          {
   \                     vfnLCD_Write_Char: (+1)
   \   00000000   0xB438             PUSH     {R3-R5}
    261              unsigned char *lbpLCDWF;
    262              unsigned char lbCounter;
    263              unsigned char lbShadow;
    264              unsigned char lbIndex;
    265          
    266              /* Only ASCII character, numbers and space */
    267              if (lbValue >='a' && lbValue <='z') lbValue -= 32;  // UpperCase
   \   00000002   0x0002             MOVS     R2,R0
   \   00000004   0x3A61             SUBS     R2,R2,#+97
   \   00000006   0x2A1A             CMP      R2,#+26
   \   00000008   0xD200             BCS      ??vfnLCD_Write_Char_0
   \   0000000A   0x3820             SUBS     R0,R0,#+32
    268              if (lbValue >='A' && lbValue <='Z') lbValue -= 6;   // Only characters and numbers
   \                     ??vfnLCD_Write_Char_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0002             MOVS     R2,R0
   \   00000010   0x3A41             SUBS     R2,R2,#+65
   \   00000012   0x2A1A             CMP      R2,#+26
   \   00000014   0xD200             BCS      ??vfnLCD_Write_Char_1
   \   00000016   0x1F80             SUBS     R0,R0,#+6
    269              if (lbValue < '0' || lbValue > 'Z') lbValue = ':';  // default value as space
   \                     ??vfnLCD_Write_Char_1: (+1)
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x0002             MOVS     R2,R0
   \   0000001C   0x3A30             SUBS     R2,R2,#+48
   \   0000001E   0x2A2B             CMP      R2,#+43
   \   00000020   0xD300             BCC      ??vfnLCD_Write_Char_2
   \   00000022   0x203A             MOVS     R0,#+58
    270              
    271              lbValue -= '0';       // Remove the offset to search in the ASCII table
    272              lbValue *= _LCDTYPE;  // Compensate matrix offset
   \                     ??vfnLCD_Write_Char_2: (+1)
   \   00000024   0x3830             SUBS     R0,R0,#+48
    273          
    274              lbCounter = _LCDTYPE;  //number of writings to complete one char
   \   00000026   0xB2C0             UXTB     R0,R0
    275          
    276              while (lbCounter-- /* && bLCD_CharPosition < (_LCD_CHARNUM1+1) */ )
    277              {
    278                  lbIndex = (unsigned char)(lbCounter + (pos&0x0f) * _LCDTYPE);
   \   00000028   0x070B             LSLS     R3,R1,#+28
   \   0000002A   0x0F1B             LSRS     R3,R3,#+28
    279                  lbpLCDWF = bpaPlace[lbIndex];
   \   0000002C   0x009A             LSLS     R2,R3,#+2
   \   0000002E   0x....             LDR      R4,??DataTable12
   \   00000030   0x58A2             LDR      R2,[R4, R2]
    280                  lbShadow  = *lbpLCDWF;
    281                  lbShadow &= symbol_mask[lbIndex];
   \   00000032   0x7814             LDRB     R4,[R2, #+0]
   \   00000034   0x....             ADR.N    R5,symbol_mask
   \   00000036   0x5CEB             LDRB     R3,[R5, R3]
   \   00000038   0x4023             ANDS     R3,R3,R4
    282                  if (pos<=8) lbShadow |= baAscii1[lbValue + lbCounter];
   \   0000003A   0x2909             CMP      R1,#+9
   \   0000003C   0xDA02             BGE      ??vfnLCD_Write_Char_3
   \   0000003E   0xBF00             Nop      
   \   00000040   0x....             ADR.N    R1,baAscii1
   \   00000042   0xE006             B        ??vfnLCD_Write_Char_4
    283                  else if ((pos>=9) && (pos<=13)) lbShadow |= baAscii2[lbValue + lbCounter];
   \                     ??vfnLCD_Write_Char_3: (+1)
   \   00000044   0x3909             SUBS     R1,R1,#+9
   \   00000046   0x2905             CMP      R1,#+5
   \   00000048   0xD202             BCS      ??vfnLCD_Write_Char_5
   \   0000004A   0xBF00             Nop      
   \   0000004C   0x....             ADR.N    R1,baAscii2
   \   0000004E   0xE000             B        ??vfnLCD_Write_Char_4
    284                  else lbShadow |= baAscii3[lbValue + lbCounter];
   \                     ??vfnLCD_Write_Char_5: (+1)
   \   00000050   0x....             ADR.N    R1,baAscii3
   \                     ??vfnLCD_Write_Char_4: (+1)
   \   00000052   0x5C08             LDRB     R0,[R1, R0]
   \   00000054   0x4318             ORRS     R0,R0,R3
    285                  *lbpLCDWF = lbShadow;
   \   00000056   0x7010             STRB     R0,[R2, #+0]
    286              }
    287          }
   \   00000058   0xBC31             POP      {R0,R4,R5}
   \   0000005A   0x4770             BX       LR               ;; return
    288          
    289          /***************************************************************************//*!
    290          *
    291          * @brief    Write message to upper or lower LCD digits  
    292          *
    293          * @param    message (ASCII format)
    294          * @return   nothing
    295          *
    296          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    297          void  vfnLCD_Write_Msg (unsigned char maxDigits, unsigned char *lbpMessage)
    298          {
   \                     vfnLCD_Write_Msg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    299              unsigned char lbSize = 0;          
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0xE008             B        ??vfnLCD_Write_Msg_0
    300              while (lbSize < maxDigits  && *lbpMessage) 
    301              {
    302                 vfnLCD_Write_Char (*lbpMessage,bLCD_CharPosition++);
   \                     ??vfnLCD_Write_Msg_1: (+1)
   \   0000000A   0x....             LDR      R0,??DataTable12_1
   \   0000000C   0x7B01             LDRB     R1,[R0, #+12]
   \   0000000E   0x1C4A             ADDS     R2,R1,#+1
   \   00000010   0x7302             STRB     R2,[R0, #+12]
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       vfnLCD_Write_Char
    303                 lbSize++;    
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
    304                 lbpMessage++;
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
    305              }
   \                     ??vfnLCD_Write_Msg_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0x42B5             CMP      R5,R6
   \   00000020   0xD202             BCS      ??vfnLCD_Write_Msg_2
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD1F0             BNE      ??vfnLCD_Write_Msg_1
    306          }
   \                     ??vfnLCD_Write_Msg_2: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    307           
    308          /***************************************************************************//*!
    309          *
    310          * @brief    Text message roll  
    311          *
    312          * @param    text for scrolling on upper LCD digits
    313          * @return   nothing
    314          *
    315          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    316            void vfnLCD_MessageRoll (unsigned char *text) {
   \                     vfnLCD_MessageRoll: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    317              unsigned char i,j;
    318              unsigned char *pTextAll,*pTextScr;
    319          
    320              pTextAll = text;                   // initial text message on LCD
   \   00000004   0x9001             STR      R0,[SP, #+4]
    321              for (i=0;i<strlen((const char*)text);i++) {
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x700C             STRB     R4,[R1, #+0]
   \   0000000C   0x....             LDR      R6,??DataTable12_2  ;; 0x40043031
   \   0000000E   0xE03E             B        ??vfnLCD_MessageRoll_0
    322                pTextScr = pTextAll;
   \                     ??vfnLCD_MessageRoll_1: (+1)
   \   00000010   0x9801             LDR      R0,[SP, #+4]
    323                for (j=0;j<_LCD_CHARNUM1;j++) {
   \   00000012   0x....             LDR      R1,??DataTable12_1
   \   00000014   0x2203             MOVS     R2,#+3
    324                  LCD_buffer[j] = *pTextScr++;
   \                     ??vfnLCD_MessageRoll_2: (+1)
   \   00000016   0x7803             LDRB     R3,[R0, #+0]
   \   00000018   0x700B             STRB     R3,[R1, #+0]
   \   0000001A   0x7843             LDRB     R3,[R0, #+1]
   \   0000001C   0x704B             STRB     R3,[R1, #+1]
   \   0000001E   0x7883             LDRB     R3,[R0, #+2]
   \   00000020   0x708B             STRB     R3,[R1, #+2]
   \   00000022   0x1CC0             ADDS     R0,R0,#+3
    325                }
   \   00000024   0x1CC9             ADDS     R1,R1,#+3
   \   00000026   0x1E52             SUBS     R2,R2,#+1
   \   00000028   0xD1F5             BNE      ??vfnLCD_MessageRoll_2
    326                LCD_buffer[_LCD_CHARNUM1] = '\0';
   \   0000002A   0x....             LDR      R1,??DataTable12_1
   \   0000002C   0x724C             STRB     R4,[R1, #+9]
    327                vfnLCD_All_Segments_OFF();
   \   0000002E   0x76B4             STRB     R4,[R6, #+26]
   \   00000030   0x7534             STRB     R4,[R6, #+20]
   \   00000032   0x74F4             STRB     R4,[R6, #+19]
   \   00000034   0x74B4             STRB     R4,[R6, #+18]
   \   00000036   0x7474             STRB     R4,[R6, #+17]
   \   00000038   0x7434             STRB     R4,[R6, #+16]
   \   0000003A   0x73F4             STRB     R4,[R6, #+15]
   \   0000003C   0x73B4             STRB     R4,[R6, #+14]
   \   0000003E   0x72F4             STRB     R4,[R6, #+11]
   \   00000040   0x72B4             STRB     R4,[R6, #+10]
   \   00000042   0x7274             STRB     R4,[R6, #+9]
   \   00000044   0x7234             STRB     R4,[R6, #+8]
   \   00000046   0x71F4             STRB     R4,[R6, #+7]
   \   00000048   0x71B4             STRB     R4,[R6, #+6]
   \   0000004A   0x7174             STRB     R4,[R6, #+5]
   \   0000004C   0x7134             STRB     R4,[R6, #+4]
   \   0000004E   0x70F4             STRB     R4,[R6, #+3]
   \   00000050   0x70B4             STRB     R4,[R6, #+2]
   \   00000052   0x7074             STRB     R4,[R6, #+1]
   \   00000054   0x7034             STRB     R4,[R6, #+0]
    328                bLCD_CharPosition = 0;  //Home display
   \   00000056   0x730C             STRB     R4,[R1, #+12]
    329                vfnLCD_Write_Msg(_LCD_CHARNUM1,LCD_buffer);
   \   00000058   0x460F             MOV      R7,R1
   \   0000005A   0x2509             MOVS     R5,#+9
   \                     ??vfnLCD_MessageRoll_3: (+1)
   \   0000005C   0x7838             LDRB     R0,[R7, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD00A             BEQ      ??vfnLCD_MessageRoll_4
   \   00000062   0x....             LDR      R0,??DataTable12_1
   \   00000064   0x7B01             LDRB     R1,[R0, #+12]
   \   00000066   0x1C48             ADDS     R0,R1,#+1
   \   00000068   0x....             LDR      R2,??DataTable12_1
   \   0000006A   0x7310             STRB     R0,[R2, #+12]
   \   0000006C   0x7838             LDRB     R0,[R7, #+0]
   \   0000006E   0x.... 0x....      BL       vfnLCD_Write_Char
   \   00000072   0x1C7F             ADDS     R7,R7,#+1
   \   00000074   0x1E6D             SUBS     R5,R5,#+1
   \   00000076   0xD1F1             BNE      ??vfnLCD_MessageRoll_3
    330                arch_delay(8000000l);          // wait ms         
   \                     ??vfnLCD_MessageRoll_4: (+1)
   \   00000078   0x....             LDR      R0,??DataTable12_3  ;; 0x7a1200
   \   0000007A   0x.... 0x....      BL       arch_delay
    331                pTextAll++;
   \   0000007E   0x9801             LDR      R0,[SP, #+4]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x9001             STR      R0,[SP, #+4]
    332              }
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
   \                     ??vfnLCD_MessageRoll_0: (+1)
   \   0000008E   0x9802             LDR      R0,[SP, #+8]
   \   00000090   0x.... 0x....      BL       strlen
   \   00000094   0x4669             MOV      R1,SP
   \   00000096   0x7809             LDRB     R1,[R1, #+0]
   \   00000098   0x4281             CMP      R1,R0
   \   0000009A   0xD3B9             BCC      ??vfnLCD_MessageRoll_1
    333            }
   \   0000009C   0xB003             ADD      SP,SP,#+12
   \   0000009E   0xBDF0             POP      {R4-R7,PC}       ;; return
    334          
    335          /***************************************************************************//*!
    336          *
    337          * @brief    Write string to LCD 
    338          *
    339          * @param    string (if > 8 digits then string is scrolled) - upper stage
    340          *           string (if > 5 digits then string is cut-off) - lower stage
    341          *           stage=1 for upper stage, stage=2 for lower stage
    342          * @return   nothing
    343          * @note     when number and text is written on one LCD stage, it is recommended
    344          *           to call vfnLCD_Write_Num firstly and then vfnLCD_Write_Str, because
    345          *           vfnLCD_Write_Num fills up all LCD digits on the stage
    346          *           String is lined up from left to right
    347          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    348          void  vfnLCD_Write_Str (unsigned char *lbpMessage, unsigned char stage)
    349          {
   \                     vfnLCD_Write_Str: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    350              unsigned char lbSize = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x2500             MOVS     R5,#+0
    351              unsigned char *pMsg;
    352          
    353              if ((stage == 1) || (stage == 2)) {       // only stage 1 or 2
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD001             BEQ      ??vfnLCD_Write_Str_0
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD121             BNE      ??vfnLCD_Write_Str_1
    354                  pMsg = lbpMessage;
   \                     ??vfnLCD_Write_Str_0: (+1)
   \   00000010   0x0022             MOVS     R2,R4
   \   00000012   0xE001             B        ??vfnLCD_Write_Str_2
    355                  while(*pMsg++) lbSize++;
   \                     ??vfnLCD_Write_Str_3: (+1)
   \   00000014   0x1C52             ADDS     R2,R2,#+1
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??vfnLCD_Write_Str_2: (+1)
   \   00000018   0x7813             LDRB     R3,[R2, #+0]
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD1FA             BNE      ??vfnLCD_Write_Str_3
    356                  
    357                  if (stage == 1) {
   \   0000001E   0x2901             CMP      R1,#+1
   \   00000020   0xD004             BEQ      ??vfnLCD_Write_Str_4
    358                    bLCD_CharPosition=0;                //upper part of display
    359                   }
    360                  else
    361                  {
    362                    if (lbSize > (_MAX_NUM_DIGITS2) ) 
   \   00000022   0xB2ED             UXTB     R5,R5
   \   00000024   0x2D06             CMP      R5,#+6
   \   00000026   0xDB00             BLT      ??vfnLCD_Write_Str_5
    363                      lbSize = _MAX_NUM_DIGITS2;        // cut-off remaining digits on lower stage
   \   00000028   0x2505             MOVS     R5,#+5
    364                    bLCD_CharPosition=9;                //lower part of display
   \                     ??vfnLCD_Write_Str_5: (+1)
   \   0000002A   0x2009             MOVS     R0,#+9
   \                     ??vfnLCD_Write_Str_4: (+1)
   \   0000002C   0x....             LDR      R6,??DataTable12_1
   \   0000002E   0x7330             STRB     R0,[R6, #+12]
    365                  }
    366                  
    367                  if (lbSize > (_MAX_NUM_DIGITS1) )
   \   00000030   0xB2ED             UXTB     R5,R5
   \   00000032   0x2D0A             CMP      R5,#+10
   \   00000034   0xDB03             BLT      ??vfnLCD_Write_Str_6
    368                  {
    369                    // string on upper LCD stage is too long to show - must be scrolled
    370                    vfnLCD_MessageRoll(lbpMessage);   
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       vfnLCD_MessageRoll
   \   0000003C   0xBD70             POP      {R4-R6,PC}
    371                  }
    372                  else
    373                  {
    374                     do
    375                      {
    376                          vfnLCD_Write_Char (*lbpMessage,bLCD_CharPosition++);
   \                     ??vfnLCD_Write_Str_6: (+1)
   \   0000003E   0x7B31             LDRB     R1,[R6, #+12]
   \   00000040   0x1C48             ADDS     R0,R1,#+1
   \   00000042   0x7330             STRB     R0,[R6, #+12]
   \   00000044   0x7820             LDRB     R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       vfnLCD_Write_Char
    377                          lbpMessage ++;
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
    378                          
    379                      } while (--lbSize);
   \   0000004C   0x1E6D             SUBS     R5,R5,#+1
   \   0000004E   0xB2ED             UXTB     R5,R5
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD1F4             BNE      ??vfnLCD_Write_Str_6
    380                  }
    381              }
    382          }
   \                     ??vfnLCD_Write_Str_1: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    383           
    384          /***************************************************************************//*!
    385          *
    386          * @brief    Turn-on all LCD segments 
    387          *
    388          * @param    nothing
    389          * @return   nothing
    390          *
    391          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    392          void vfnLCD_All_Segments_ON(void)
    393          {              
    394            CharacterPlace(43) = ALLON;
   \                     vfnLCD_All_Segments_ON: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12_2  ;; 0x40043031
   \   00000002   0x21FF             MOVS     R1,#+255
   \   00000004   0x....             B.N      ?Subroutine0
    395            CharacterPlace(37) = ALLON;
    396            CharacterPlace(36) = ALLON;
    397            CharacterPlace(35) = ALLON;
    398            CharacterPlace(34) = ALLON;
    399            CharacterPlace(33) = ALLON;
    400            CharacterPlace(32) = ALLON;
    401            CharacterPlace(31) = ALLON;
    402            CharacterPlace(28) = ALLON;
    403            CharacterPlace(27) = ALLON;
    404            CharacterPlace(26) = ALLON;
    405            CharacterPlace(25) = ALLON;
    406            CharacterPlace(24) = ALLON;
    407            CharacterPlace(23) = ALLON;
    408            CharacterPlace(22) = ALLON;
    409            CharacterPlace(21) = ALLON;
    410            CharacterPlace(20) = ALLON;
    411            CharacterPlace(19) = ALLON;
    412            CharacterPlace(18) = ALLON;
    413            CharacterPlace(17) = ALLON;
    414          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x7681             STRB     R1,[R0, #+26]
   \   00000002   0x7501             STRB     R1,[R0, #+20]
   \   00000004   0x74C1             STRB     R1,[R0, #+19]
   \   00000006   0x7481             STRB     R1,[R0, #+18]
   \   00000008   0x7441             STRB     R1,[R0, #+17]
   \   0000000A   0x7401             STRB     R1,[R0, #+16]
   \   0000000C   0x73C1             STRB     R1,[R0, #+15]
   \   0000000E   0x7381             STRB     R1,[R0, #+14]
   \   00000010   0x72C1             STRB     R1,[R0, #+11]
   \   00000012   0x7281             STRB     R1,[R0, #+10]
   \   00000014   0x7241             STRB     R1,[R0, #+9]
   \   00000016   0x7201             STRB     R1,[R0, #+8]
   \   00000018   0x71C1             STRB     R1,[R0, #+7]
   \   0000001A   0x7181             STRB     R1,[R0, #+6]
   \   0000001C   0x7141             STRB     R1,[R0, #+5]
   \   0000001E   0x7101             STRB     R1,[R0, #+4]
   \   00000020   0x70C1             STRB     R1,[R0, #+3]
   \   00000022   0x7081             STRB     R1,[R0, #+2]
   \   00000024   0x7041             STRB     R1,[R0, #+1]
   \   00000026   0x7001             STRB     R1,[R0, #+0]
   \   00000028   0x4770             BX       LR               ;; return
    415          
    416          /***************************************************************************//*!
    417          *
    418          * @brief    Turn-off all LCD segments 
    419          *
    420          * @param    nothing
    421          * @return   nothing
    422          *
    423          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    424          void vfnLCD_All_Segments_OFF (void)
    425          {              
    426            CharacterPlace(43) = ALLOFF;
   \                     vfnLCD_All_Segments_OFF: (+1)
   \   00000000   0x....             LDR      R0,??DataTable12_2  ;; 0x40043031
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004                      REQUIRE ?Subroutine0
   \   00000004                      ;; // Fall through to label ?Subroutine0
    427            CharacterPlace(37) = ALLOFF;
    428            CharacterPlace(36) = ALLOFF;
    429            CharacterPlace(35) = ALLOFF;
    430            CharacterPlace(34) = ALLOFF;
    431            CharacterPlace(33) = ALLOFF;
    432            CharacterPlace(32) = ALLOFF;
    433            CharacterPlace(31) = ALLOFF;
    434            CharacterPlace(28) = ALLOFF;
    435            CharacterPlace(27) = ALLOFF;
    436            CharacterPlace(26) = ALLOFF;
    437            CharacterPlace(25) = ALLOFF;
    438            CharacterPlace(24) = ALLOFF;
    439            CharacterPlace(23) = ALLOFF;
    440            CharacterPlace(22) = ALLOFF;
    441            CharacterPlace(21) = ALLOFF;
    442            CharacterPlace(20) = ALLOFF;
    443            CharacterPlace(19) = ALLOFF;
    444            CharacterPlace(18) = ALLOFF;
    445            CharacterPlace(17) = ALLOFF;
    446          }
    447          
    448          /***************************************************************************//*!
    449          *
    450          * @brief    Fill LCD buffer with number and send it to LCD 
    451          *
    452          * @param    number - max. 7 digits with sign or 8 digits without sign
    453          *           mindigits - minimum number of digits to show on LCD (number format)
    454          *           stage - 1=upper LCD stage (8 digits max.), 2=lower LCD stage (5 digits max.)
    455          * @return   nothing
    456          * @note     when number and text is written on one LCD stage, it is recommended
    457          *           to call vfnLCD_Write_Num firstly and then vfnLCD_Write_Str, because
    458          *           vfnLCD_Write_Num fills up all LCD digits on the stage
    459          *           Number is lined up from right to left
    460          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    461          void vfnLCD_Write_Num(long number, unsigned char minDigits, unsigned char stage) {
   \                     vfnLCD_Write_Num: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x2500             MOVS     R5,#+0
    462            unsigned char dig,i;
    463            long reghelp;
    464            unsigned char position=0;
    465            long decimal;
    466            unsigned char numPos=0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD002             BEQ      ??vfnLCD_Write_Num_0
   \   0000000C   0x2A02             CMP      R2,#+2
   \   0000000E   0xD000             BEQ      .+4
   \   00000010   0xE080             B        ??vfnLCD_Write_Num_1
    467            unsigned char tempLCDb[_MAX_NUM_DIGITS1];
    468            unsigned char *s=LCD_buffer;
    469            unsigned char maxDigits;
    470              
    471            if ((stage == 1) || (stage == 2)) {       // only stage 1 or 2
    472                if (number < 0)
   \                     ??vfnLCD_Write_Num_0: (+1)
   \   00000012   0x9806             LDR      R0,[SP, #+24]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD500             BPL      ??vfnLCD_Write_Num_2
   \   00000018   0x4240             RSBS     R0,R0,#+0
   \                     ??vfnLCD_Write_Num_2: (+1)
   \   0000001A   0x9001             STR      R0,[SP, #+4]
    473                  reghelp=-number;
    474                else 
    475                  reghelp=number;
    476                
    477                if (stage == 1) {
   \   0000001C   0x2009             MOVS     R0,#+9
   \   0000001E   0xA908             ADD      R1,SP,#+32
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x2901             CMP      R1,#+1
   \   00000024   0xD103             BNE      ??vfnLCD_Write_Num_3
    478                  maxDigits = _MAX_NUM_DIGITS1;       // number of digits overflow
   \   00000026   0x9000             STR      R0,[SP, #+0]
    479                  bLCD_CharPosition=0;  //upper part of display
   \   00000028   0x2000             MOVS     R0,#+0
    480                  decimal=100000000;
   \   0000002A   0x....             LDR      R6,??DataTable12_4  ;; 0x5f5e100
   \   0000002C   0xE002             B        ??vfnLCD_Write_Num_4
    481                 }
    482                else
    483                {
    484                  maxDigits = _MAX_NUM_DIGITS2;       // number of digits overflow
   \                     ??vfnLCD_Write_Num_3: (+1)
   \   0000002E   0x2105             MOVS     R1,#+5
   \   00000030   0x9100             STR      R1,[SP, #+0]
    485                  bLCD_CharPosition=9;  //lower part of display
    486                  decimal=10000;
   \   00000032   0x....             LDR      R6,??DataTable12_5  ;; 0x2710
   \                     ??vfnLCD_Write_Num_4: (+1)
   \   00000034   0x....             LDR      R1,??DataTable12_1
   \   00000036   0x7308             STRB     R0,[R1, #+12]
    487                }
    488                if (minDigits>maxDigits) minDigits = maxDigits;        // number of digits overflow
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7F09             LDRB     R1,[R1, #+28]
   \   0000003E   0xB2C0             UXTB     R0,R0
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD202             BCS      ??vfnLCD_Write_Num_5
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x7708             STRB     R0,[R1, #+28]
   \                     ??vfnLCD_Write_Num_5: (+1)
   \   0000004A   0x9F00             LDR      R7,[SP, #+0]
    489               
    490                for (i=0;i<maxDigits;i++){
    491                  dig=(unsigned char)(reghelp / decimal);                    
   \                     ??vfnLCD_Write_Num_6: (+1)
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x0031             MOVS     R1,R6
   \   00000050   0x.... 0x....      BL       __aeabi_idiv
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x2800             CMP      R0,#+0
    492                  if ((dig==0) && (!numPos)) {
   \   00000058   0xD108             BNE      ??vfnLCD_Write_Num_7
   \   0000005A   0xB2E4             UXTB     R4,R4
   \   0000005C   0x2C00             CMP      R4,#+0
   \   0000005E   0xD105             BNE      ??vfnLCD_Write_Num_7
    493                    tempLCDb[position++] = (unsigned char) ('0');        // fill zero to upper left digits
   \   00000060   0x2130             MOVS     R1,#+48
   \   00000062   0xB2ED             UXTB     R5,R5
   \   00000064   0xAA02             ADD      R2,SP,#+8
   \   00000066   0x5551             STRB     R1,[R2, R5]
   \   00000068   0x1C6D             ADDS     R5,R5,#+1
   \   0000006A   0xE006             B        ??vfnLCD_Write_Num_8
    494                  }
    495                  else {
    496                    tempLCDb[position++] = (unsigned char) (dig + '0');  // fill numbers
   \                     ??vfnLCD_Write_Num_7: (+1)
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0x3130             ADDS     R1,R1,#+48
   \   00000070   0xB2ED             UXTB     R5,R5
   \   00000072   0xAA02             ADD      R2,SP,#+8
   \   00000074   0x5551             STRB     R1,[R2, R5]
   \   00000076   0x1C6D             ADDS     R5,R5,#+1
    497                    numPos++;
   \   00000078   0x1C64             ADDS     R4,R4,#+1
    498                  }
    499                  reghelp= (long)(reghelp-dig*decimal);             
   \                     ??vfnLCD_Write_Num_8: (+1)
   \   0000007A   0x9901             LDR      R1,[SP, #+4]
   \   0000007C   0x4370             MULS     R0,R6,R0
   \   0000007E   0x1A08             SUBS     R0,R1,R0
   \   00000080   0x9001             STR      R0,[SP, #+4]
    500                  decimal /= 10;
   \   00000082   0x0030             MOVS     R0,R6
   \   00000084   0x210A             MOVS     R1,#+10
   \   00000086   0x.... 0x....      BL       __aeabi_idiv
   \   0000008A   0x0006             MOVS     R6,R0
    501                }
   \   0000008C   0x1E7F             SUBS     R7,R7,#+1
   \   0000008E   0xD1DD             BNE      ??vfnLCD_Write_Num_6
    502                if (numPos<minDigits) numPos = minDigits;             // number of digits is less than minimum represented digits
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x7F00             LDRB     R0,[R0, #+28]
   \   00000094   0xB2E4             UXTB     R4,R4
   \   00000096   0x4284             CMP      R4,R0
   \   00000098   0xD200             BCS      ??vfnLCD_Write_Num_9
   \   0000009A   0x0004             MOVS     R4,R0
    503                
    504                position = 0;
   \                     ??vfnLCD_Write_Num_9: (+1)
   \   0000009C   0x2500             MOVS     R5,#+0
    505              
    506                for (i=0;i<(maxDigits-numPos);i++){             // normal state of digits
   \   0000009E   0x9900             LDR      R1,[SP, #+0]
   \   000000A0   0x1B09             SUBS     R1,R1,R4
   \   000000A2   0x2901             CMP      R1,#+1
   \   000000A4   0xDB08             BLT      ??vfnLCD_Write_Num_10
   \   000000A6   0x....             LDR      R1,??DataTable12_1
   \   000000A8   0x9A00             LDR      R2,[SP, #+0]
   \   000000AA   0x1B10             SUBS     R0,R2,R4
   \   000000AC   0x2220             MOVS     R2,#+32
    507                  s[position++] = ' ';
   \                     ??vfnLCD_Write_Num_11: (+1)
   \   000000AE   0x700A             STRB     R2,[R1, #+0]
   \   000000B0   0x1C6D             ADDS     R5,R5,#+1
    508                }
   \   000000B2   0x1C49             ADDS     R1,R1,#+1
   \   000000B4   0x1E40             SUBS     R0,R0,#+1
   \   000000B6   0xD1FA             BNE      ??vfnLCD_Write_Num_11
    509                i = (unsigned char)(maxDigits-numPos);
   \                     ??vfnLCD_Write_Num_10: (+1)
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0x1B00             SUBS     R0,R0,R4
   \   000000BC   0x9900             LDR      R1,[SP, #+0]
   \   000000BE   0xB2C0             UXTB     R0,R0
   \   000000C0   0xB2C9             UXTB     R1,R1
   \   000000C2   0x4288             CMP      R0,R1
   \   000000C4   0xD20B             BCS      ??vfnLCD_Write_Num_12
   \   000000C6   0xA902             ADD      R1,SP,#+8
   \   000000C8   0x1808             ADDS     R0,R1,R0
   \   000000CA   0xB2ED             UXTB     R5,R5
   \   000000CC   0x....             LDR      R1,??DataTable12_1
   \   000000CE   0x1949             ADDS     R1,R1,R5
    510              
    511                for (;i<maxDigits;i++){                    // fill number
    512                  s[position++] = tempLCDb[i];
   \                     ??vfnLCD_Write_Num_13: (+1)
   \   000000D0   0x7802             LDRB     R2,[R0, #+0]
   \   000000D2   0x700A             STRB     R2,[R1, #+0]
   \   000000D4   0x1C6D             ADDS     R5,R5,#+1
    513                }
   \   000000D6   0x1C49             ADDS     R1,R1,#+1
   \   000000D8   0x1C40             ADDS     R0,R0,#+1
   \   000000DA   0x1E64             SUBS     R4,R4,#+1
   \   000000DC   0xD1F8             BNE      ??vfnLCD_Write_Num_13
    514                
    515                s[position] = '\0';                             // end of string
   \                     ??vfnLCD_Write_Num_12: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xB2ED             UXTB     R5,R5
   \   000000E2   0x....             LDR      R1,??DataTable12_1
   \   000000E4   0x5548             STRB     R0,[R1, R5]
    516              
    517                vfnLCD_Write_Msg(maxDigits,LCD_buffer);               // send data to LCD !
   \   000000E6   0x9800             LDR      R0,[SP, #+0]
   \   000000E8   0xB2C0             UXTB     R0,R0
   \   000000EA   0x.... 0x....      BL       vfnLCD_Write_Msg
    518                if ((stage == 1) && (LCD_buffer[0] == ' ')) { 
   \   000000EE   0xA808             ADD      R0,SP,#+32
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x2801             CMP      R0,#+1
   \   000000F4   0xD10E             BNE      ??vfnLCD_Write_Num_1
   \   000000F6   0x....             LDR      R0,??DataTable12_1
   \   000000F8   0x7800             LDRB     R0,[R0, #+0]
   \   000000FA   0x2820             CMP      R0,#+32
   \   000000FC   0xD10A             BNE      ??vfnLCD_Write_Num_1
    519                  if (number<0) _LCD_MINUS_ON()
   \   000000FE   0x....             LDR      R0,??DataTable12_6  ;; 0x4004303b
   \   00000100   0x7801             LDRB     R1,[R0, #+0]
   \   00000102   0x9A06             LDR      R2,[SP, #+24]
   \   00000104   0x2A00             CMP      R2,#+0
   \   00000106   0xD502             BPL      ??vfnLCD_Write_Num_14
   \   00000108   0x2210             MOVS     R2,#+16
   \   0000010A   0x430A             ORRS     R2,R2,R1
   \   0000010C   0xE001             B        ??vfnLCD_Write_Num_15
    520                  else _LCD_MINUS_OFF();
   \                     ??vfnLCD_Write_Num_14: (+1)
   \   0000010E   0x22EF             MOVS     R2,#+239
   \   00000110   0x400A             ANDS     R2,R2,R1
   \                     ??vfnLCD_Write_Num_15: (+1)
   \   00000112   0x7002             STRB     R2,[R0, #+0]
    521                }
    522            }
    523          }
   \                     ??vfnLCD_Write_Num_1: (+1)
   \   00000114   0xB009             ADD      SP,SP,#+36
   \   00000116   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x40043000         DC32     0x40043000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x9FFFFE00         DC32     0x9ffffe00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x0000083F         DC32     0x83f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x02040810         DC32     0x2040810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x20408000         DC32     0x20408000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0xFFFFFDFF         DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0xF0FFFFFF         DC32     0xf0ffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     bpaPlace

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     LCD_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40043031         DC32     0x40043031

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x05F5E100         DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x4004303B         DC32     0x4004303b

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   vfnLCD_All_Segments_OFF
       0   vfnLCD_All_Segments_ON
       0   vfnLCD_Contrast
       0   vfnLCD_Init
      32   vfnLCD_MessageRoll
        32   -> arch_delay
        32   -> strlen
        32   -> vfnLCD_Write_Char
       0   vfnLCD_OFF
       0   vfnLCD_ON
      12   vfnLCD_Write_Char
      16   vfnLCD_Write_Msg
        16   -> vfnLCD_Write_Char
      56   vfnLCD_Write_Num
        56   -> __aeabi_idiv
        56   -> vfnLCD_Write_Msg
      16   vfnLCD_Write_Str
        16   -> vfnLCD_MessageRoll
        16   -> vfnLCD_Write_Char


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
      42  ?Subroutine0
      12  ?Subroutine1
      13  LCD_buffer
          bLCD_CharPosition
      40  baAscii1
      40  baAscii2
      12  baAscii3
      60  bpaPlace
      16  symbol_mask
       4  vfnLCD_All_Segments_OFF
       6  vfnLCD_All_Segments_ON
      26  vfnLCD_Contrast
      76  vfnLCD_Init
     160  vfnLCD_MessageRoll
      20  vfnLCD_OFF
       8  vfnLCD_ON
      92  vfnLCD_Write_Char
      42  vfnLCD_Write_Msg
     280  vfnLCD_Write_Num
      86  vfnLCD_Write_Str

 
    13 bytes in section .bss
    60 bytes in section .data
 1 022 bytes in section .text
 
 1 022 bytes of CODE memory
    73 bytes of DATA memory

Errors: none
Warnings: none
